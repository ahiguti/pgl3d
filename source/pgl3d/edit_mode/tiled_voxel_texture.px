private threaded namespace pgl3d::edit_mode::tiled_voxel_texture "use-unsafe";
private import common -;
private import meta m;
private import pgl3d::edit_mode::common -;
private import text::serialize::compact_pod -;
private import pgl3d::texture::voxel -;
private import pgl3d::texture::filling -;
private import pgl3d::edit_mode::vecutil -;
private import pgl3d::edit_mode::texutil -;

public multithreaded struct tiled_voxel_texture()
{
  public texture_data voxtile;
  public tptr{texture_edit} tmap_edit = make_tptr{texture_edit}();
  public tptr{texture_edit} tpat_edit = make_tptr{texture_edit}();
  public filling_map fillmap;
}

private metafunction texture_data_mip_v0 varray{ptr{texture_data}};

private struct tiled_voxel_texture_v0()
{
  // 古いバージョンのフォーマット
  public texture_data voxtile;
  public texture_data_mip_v0 tmap_pri;
  public texture_data_mip_v0 tmap_sec;
  public texture_data_mip_v0 tpat_pri;
  public texture_data_mip_v0 tpat_sec;
}

public function void
tiled_voxel_texture_load_file(tiled_voxel_texture mutable& vox,
  cstrref const& fname, cstrref const& fname_v0, uvec3 tmszl2, uvec3 tpszl2,
  bool enable_short_circuit)
{
  // ファイルからデシリアライズしてvoxにセットする。
  // 現在の設定のテクスチャサイズとデシリアライズした結果のテクスチャサイズ
  // が異なるときは、現在の設定に合わせてリサイズする。拡大されると空白で
  // 埋められ、縮小されると切られた範囲のデータは失われる。
  // セーブファイルの名前を変更することによって、セーブデータを別サイズの
  // 設定で読み込むことができる。ただし切られた範囲のデータは失われるため、
  // とくにtpatを縮小するときは縮小後の範囲にあらかじめ寄せておいてから
  // セーブしておく必要があることに注意。
  // また、ロード後に一度dedupして標準配置に修正しないといけない。さもないと
  // 空白パターン割り当て時に使用中パターンを拾ってしまう可能性がある。
  string buf;
  bool load_v0 = false;
    // trueなら古いバージョンのバイナリデータをデシリアライズする
  sdl_load_file(fname, buf);
  debug_log("load voxel texture", fname, buf.size());
  if (buf.empty() && !fname_v0.empty()) {
    sdl_load_file(fname, buf);
    debug_log("load voxel texture", fname, buf.size());
    load_v0 = true;
  }
  if (!buf.empty()) {
    if (load_v0) {
      // 旧バージョンのフォーマット
      const v0 = from_string_compact_pod{tiled_voxel_texture_v0}(buf);
      vox.voxtile = v0.voxtile;
      const tmsz = (*v0.tmap_pri[0]).get_size_uvec3();
      const tpsz = (*v0.tpat_pri[0]).get_size_uvec3();
      vox.tmap_edit = make_tptr{texture_edit}();
      vox.tpat_edit = make_tptr{texture_edit}();
      function void conv_one(texture_data_mip_v0 const& src,
        texture_data_mip mutable& dest)
      {
        for (const i, const& t: src) {
          texture_reshaped tr;
          tr.set_size_l2(t->get_width(), t->get_height(), t->get_depth());
          dest.push_back(tr);
        }
      }
      conv_one(v0.tmap_pri, vox.tmap_edit->data_pri);
      conv_one(v0.tmap_sec, vox.tmap_edit->data_sec);
      conv_one(v0.tpat_pri, vox.tpat_edit->data_pri);
      conv_one(v0.tpat_sec, vox.tpat_edit->data_sec);
    } else {
      // 現行バージョンのフォーマット
      vox = from_string_compact_pod{tiled_voxel_texture}(buf);
    }
    // 必要ならテクスチャをリサイズする
    if (vox.tmap_edit->data_pri[0].get_size_l2_uvec3() != tmszl2) {
      debug_log("resize tmap from",
        vox.tmap_edit->data_pri[0].get_size_l2_uvec3(), "to", tmszl2);
      vox.tmap_edit->resize_texture(tmszl2, enable_short_circuit);
    }
    if (vox.tpat_edit->data_pri[0].get_size_l2_uvec3() != tpszl2) {
      debug_log("resize tpat from",
        vox.tpat_edit->data_pri[0].get_size_l2_uvec3(), "to", tpszl2);
      vox.tpat_edit->resize_texture(tpszl2, enable_short_circuit);
    }
    // fillmapは、tmapの各座標に定義されたfillingを保持する。fillmapのサイズは
    // tmapと同じである必要があるので、異なっていればリサイズする。
    if (vox.fillmap.get_size_l2() != tmszl2) {
      debug_log("resize filling from", vox.fillmap.get_size_l2(),
        "to", tmszl2);
      vox.fillmap.set_size_l2(tmszl2);
    }
  }
}

public function void
tiled_voxel_texture_save_file(tiled_voxel_texture const& vox,
  cstrref const& fname)
{
  sdl_save_file(fname, to_string_compact_pod(vox));
}


public function void
tiled_voxel_texture_update_mipmap(tiled_voxel_texture const& vox)
{
  debug_log("update_mipmap_all begin");
  const bool enable_short_circuit = true; // FIXME?
  function void update_mipmap_one(texture_reshaped mutable& pri0,
    texture_reshaped mutable& sec0, texture_reshaped mutable& pri1,
    texture_reshaped mutable& sec1)
  {
    const sz = pri0.get_size_l2_uvec3();
    mutable sz2 = make_uvec3(
      max(sz.x, 1u) - 1u, 
      max(sz.y, 1u) - 1u, 
      max(sz.z, 1u) - 1u);
    /*
    if (sz.x == 0u || sz.y == 0u || sz.z == 0u) {
      // pri0がすでに短辺1のテクスチャなのでそれ以上mipmapを作れない
      debug_log("update_mipmap_one: pri0 sz", sz);
    }
    */
    pri1.set_size_l2(sz2.x, sz2.y, sz2.z);
    sec1.set_size_l2(sz2.x, sz2.y, sz2.z);
    for (const z: 0 .. pri1.get_depth()) {
      for (const y: 0 .. pri1.get_height()) {
        for (const x: 0 .. pri1.get_width()) {
          ivec3 p = make_ivec3(si(x), si(y), si(z));
          texel_value dpri_v;
          texel_value dsec_v;
          shrink_voxel_value(true, pri0, sec0, dpri_v, dsec_v, p);
          /*
          if (!is_space_voxel(dpri_v)) {
            dpri_v = make_filled_voxel();
          }
          */
          pri1.set(ui(p.x), ui(p.y), ui(p.z), dpri_v);
          sec1.set(ui(p.x), ui(p.y), ui(p.z), dsec_v);
        }
      }
    }
  }
  // tpatのmipmap更新
  // vox.voxtile.get_width_l2() + 1;
    // タイルサイズが16なら16,8,4,2,1の5枚
  const pat_mip_num = 8u + 1u;
    // scale値が0から7まで、最大タイルサイズ256
  while (vox.tpat_edit->data_pri.size() < pat_mip_num) {
    vox.tpat_edit->data_pri.push_back(texture_reshaped());
  }
  while (vox.tpat_edit->data_sec.size() < pat_mip_num) {
    vox.tpat_edit->data_sec.push_back(texture_reshaped());
  }
  vox.tpat_edit->data_pri.resize(pat_mip_num, texture_reshaped());
  vox.tpat_edit->data_sec.resize(pat_mip_num, texture_reshaped());
  debug_log("update_mipmap_all set_distance begin");
  set_distance(enable_short_circuit, vox.tpat_edit->data_pri[0]);
    // tpatのmip0の距離を計算しなおす。(最適でないかもしれないので)
  for (const i: 1 .. vox.tpat_edit->data_pri.size()) {
    mutable& tpri = vox.tpat_edit->data_pri;
    mutable& tsec = vox.tpat_edit->data_sec;
    update_mipmap_one(tpri[i - 1], tsec[i - 1], tpri[i], tsec[i]);
    set_distance(enable_short_circuit, tpri[i]);
    debug_log("update_mipmap_all tpat", i);
  }
  // tmapのmiplevel==0の代替となるテクスチャの作成
  texture_reshaped pri0 = vox.tmap_edit->data_pri[0]; // copy
  texture_reshaped sec0 = vox.tmap_edit->data_sec[0]; // copy
  // node_reference以外の時はtmapのmip0のまま、node_referenceのときは
  // tpatの対応するmiplevelから値を拾ってきて書き込む
  for (const z: 0 .. pri0.get_depth()) {
    for (const y: 0 .. pri0.get_height()) {
      for (const x: 0 .. pri0.get_width()) {
        mutable vpri = pri0.get(x, y, z);
        mutable vsec = sec0.get(x, y, z);
        if (is_node_reference(vpri)) {
          const p = decode_noderef_param(vpri);
          const c = p.coord;
          const sc = p.scale;
          const lv = sc + 1;
          if (lv < pat_mip_num) {
            vpri = vox.tpat_edit->data_pri[lv].get(c.x, c.y, c.z);
            vsec = vox.tpat_edit->data_sec[lv].get(c.x, c.y, c.z);
          } else {
            vpri = make_filled_voxel();
            vsec = 0u;
          }
        }
        pri0.set(x, y, z, vpri);
        sec0.set(x, y, z, vsec);
      }
    }
  }
  // tmapのmiplevel==1の更新
  update_mipmap_one(pri0, sec0, vox.tmap_edit->data_pri[1],
    vox.tmap_edit->data_sec[1]);
  set_distance(enable_short_circuit, vox.tmap_edit->data_pri[1]);
  debug_log("update_mipmap_all tmap", 1);
  // tmapのmiplevel==2以降の更新
  for (const i: 2 .. vox.tmap_edit->data_pri.size()) {
    debug_log("update_mipmap_all tmap", i);
    mutable& tpri = vox.tmap_edit->data_pri;
    mutable& tsec = vox.tmap_edit->data_sec;
    update_mipmap_one(tpri[i - 1], tsec[i - 1], tpri[i], tsec[i]);
    set_distance(enable_short_circuit, tpri[i]);
  }
  debug_log("update_mipmap_all end");
}

