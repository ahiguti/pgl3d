private threaded namespace pgl3d::edit_mode::filling;
private import common -;
private import meta m;
private import glm -;
private import pgl3d::texture::voxel -;
private import pgl3d::texture::texture -;
private import pgl3d::engine::util -;

metafunction filling_texture array3_pot{varray{ushort}, 0};

public threaded struct filling {
  public uvec3 offset; // パターンの起点がtmapのどのオフセットにあるか
  public farray{uint, 9} sizes; // x0, x1, x2, y0, y1, y2, z0, z1, z2
  public function uvec3 size() const {
    uvec3 r;
    r.x = sizes[0] + sizes[1] + sizes[2];
    r.y = sizes[3] + sizes[4] + sizes[5];
    r.z = sizes[6] + sizes[7] + sizes[9];
    return r;
  }
}

public threaded interface filling_map_i filling_map {
  public function void set_size_l2(uvec3 const& p);
  public function ushort get(uvec3 const& p) const;
  public function filling get_filling(uvec3 const& p) const;
  public function bool set_filling(uvec3 const& p, filling const& fi);
  public function bool erase_filling(uvec3 const& p);
}

public threaded struct filling_map <filling_map_i> {
  public function void set_size_l2(uvec3 const& p) {
    tex.set_size_l2(p.x, p.y, p.z);
  }
  public function ushort get(uvec3 const& p) const {
    return tex.get(p.x, p.y, p.z);
  }
  public function filling get_filling(uvec3 const& p) const {
    filling r;
    const v = get(p);
    if (v != 0) {
      const pmi = get_filling_min_offset(p);
      const pmx = get_filling_max_offset(p);
      r.offset = pmi;
      for (uint i: 0u .. 3u) {
        const dsz = get_filling_sizes_dir(pmi, i);
        for (uint j: 0u .. 3u) {
          r.sizes[i * 3 + j] = dsz[j];
        }
      }
    }
    return r;
  }
  public function bool set_filling(uvec3 const& p, filling const& fi) {
    const sz = fi.size();
    bool empty = true;
    range_foreach(sz) threaded function void (uint x, uint y, uint z) {
      const v = tex.get(p.x + x, p.y + y, p.z + z);
      empty &= (v == 0);
    }
    if (!empty) {
      return false;
    }
    range_foreach(sz) threaded function void (uint x, uint y, uint z) {
      threaded function uint calc_one_dir(cslice{uint} const& dsz, uint i) {
        if (dsz[0] + dsz[1] <= i) {
          return 3u;
        } else if (dsz[0] <= i) {
          return 2u;
        } else {
          return 1u;
        }
      }
      const dx = calc_one_dir(fi.sizes[0u .. 3u], x);
      const dy = calc_one_dir(fi.sizes[3u .. 6u], y);
      const dz = calc_one_dir(fi.sizes[6u .. 9u], z);
      const dv = encode_filling_dir(dx, dy, dz);
      tex.set(p.x + x, p.y + y, p.z + z, dv);
    }
    return true;
  }
  public function bool erase_filling(uvec3 const& p) {
    const fi = get_filling(p);
    const sz = fi.size();
    if (sz == uvec3()) {
      return false;
    }
    range_foreach(sz) threaded function void (uint x, uint y, uint z) {
      tex.set(p.x + x, p.y + y, p.z + z, ushort(0));
    }
    return true;
  }
  function farray{uint, 3} get_filling_sizes_dir(uvec3 const& p, uint d)
    const {
    const texsz = tex.get_size_uvec3();
    uvec3 pos = p;
    farray{uint, 3} a;
    while (true) {
      const v = tex.get(pos.x, pos.y, pos.z);
      const vd = decode_filling_dir(v, d);
      if (vd == 0 || (vd & 4u) != 0) {
        break;
      }
      uint const cfrag = (vd & 3u); // 左、中、右がそれぞれ1, 2, 3
      a[cfrag - 1u] += 1;
      // d方向へ移動
      if (d == 0) {
        if (pos.x + 1 == texsz.x) {
          break;
        }
        ++pos.x;
      } else if (d == 1) {
        if (pos.y + 1 == texsz.y) {
          break;
        }
        ++pos.y;
      } else if (d == 2) {
        if (pos.z + 1 == texsz.z) {
          break;
        }
        ++pos.z;
      } else {
        throw runtime_error_template{"get_filling_sizes_dir"}("d");
      }
    }
    return a;
  }
  function uvec3 get_filling_min_offset(uvec3 const& p) const {
    // fillingが定義されている範囲の始点(一番若いオフセット)を返す
    uvec3 pos = p;
    threaded function void move_offset(uint d) {
      // 一軸についてfillingの始点へ移動
      while (true) {
        const v = tex.get(pos.x, pos.y, pos.z);
        const vd = decode_filling_dir(v, d);
        if (vd == 0 || (vd & 4u) != 0) {
          break;
        }
        // d方向へ移動。filling始点マークがついているはずなのに無かったら
        // 例外を投げる
        if (d == 0) {
          if (pos.x == 0) {
            throw runtime_error_template{"get_filling_min_offset"}("x");
          }
          --pos.x;
        } else if (d == 1) {
          if (pos.y == 0) {
            throw runtime_error_template{"get_filling_min_offset"}("y");
          }
          --pos.y;
        } else if (d == 2) {
          if (pos.z == 0) {
            throw runtime_error_template{"get_filling_min_offset"}("z");
          }
          --pos.z;
        } else {
          throw runtime_error_template{"get_filling_min_offset"}("d");
        }
      }
    }
    move_offset(0);
    move_offset(1);
    move_offset(2);
    return pos;
  }
  function uvec3 get_filling_max_offset(uvec3 const& p) const {
    // fillingが定義されている範囲の終点を探す
    const texsz = tex.get_size_uvec3();
    uvec3 pos = p;
    threaded function void move_offset(uint d) {
      // 一軸についてfillingの終点へ移動
      while (true) {
        mutable npos = pos;
        if (d == 0) {
          if (npos.x + 1 == texsz.x) {
            break;
          }
          ++npos.x;
        } else if (d == 1) {
          if (npos.y + 1 == texsz.y) {
            break;
          }
          ++npos.y;
        } else if (d == 2) {
          if (npos.z + 1 == texsz.z) {
            break;
          }
          ++npos.z;
        } else {
          throw runtime_error_template{"get_filling_max_offset"}("d");
        }
        const v = tex.get(npos.x, npos.y, npos.z);
        const vd = decode_filling_dir(v, d);
        if (vd == 0 || (vd & 4u) != 0) {
          break;
        }
        pos = npos;
      }
    }
    move_offset(0);
    move_offset(1);
    move_offset(2);
    return pos;
  }
  filling_texture tex;
}

private threaded function ushort encode_filling_dir(uint x, uint y, uint z)
{
  return static_cast{ushort}((z << 8) | (y << 4) | (x << 0));
}

private threaded function uint decode_filling_dir(ushort v, uint d)
{
  if (d == 1) {
    v >>= 4;
  } else if (d == 2) {
    v >>= 8;
  }
  v &= 15u;
  // 下位2bit: 1=左, 2=中, 3=右
  // 上位1bit: fillingのその方向の始点
  return v;
}

private threaded function uvec3 decode_filling_value(ushort v)
{
  return make_uvec3(
    decode_filling_dir(v, 0),
    decode_filling_dir(v, 1),
    decode_filling_dir(v, 2));
}

