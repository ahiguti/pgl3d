private threaded namespace pgl3d::edit_mode::edit_mode_edit "use-unsafe";
private import common -;
private import meta m;
private import pgl3d::edit_mode::common -;
private import sdl2::api_types -;
private import sdl2::api_functions -;
private import text::serialize::compact_pod -;
private import pgl3d::texture::copy_data -;
private import pgl3d::texture::generator -;
private import pgl3d::edit_mode::procedural -;
private import pgl3d::edit_mode::vecutil -;
private import pgl3d::edit_mode::texutil -;
private import pgl3d::edit_mode::tiled_voxel_texture -;
private import pgl3d::edit_mode::tiled_texture_edit_view -;
private import pgl3d::edit_mode::edit_mode_texture -;
private import pgl3d::edit_mode::sync_gl -;
private import pgl3d::edit_mode::edit_mode_util -;
private import pgl3d::edit_mode::filling -;

private metafunction dbg_editmode{f} no_operation;
private metafunction dbg_conv{f} f;
private metafunction dbg_save{f} no_operation;
private metafunction dbg_console{f} no_operation;
private metafunction dbg_gen{f} no_operation;
private metafunction dbg_scale{f} no_operation;
private metafunction dbg_rotate{f} f; // no_operation;
private metafunction dbg_noderef{f} no_operation;

private metafunction save_dir "/build/saved/";

public struct edit_mode_edit(ptr{edit_mode_texture} const& emt0)
<edit_mode_i>
{
  public function void on_key_pressed(int scancode, uint modmask,
    glm::vec3 mutable& cursor_move_r, string mutable& msg_r)
  {
    message = "";
    cursor_move_r = glm::vec3();
    SDL_Scancode key = static_cast{SDL_Scancode}(scancode);
    prev_key_repeat = (prev_key == key && prev_modmask == modmask)
      ? prev_key_repeat + 1u : 0u;
    prev_key = key;
    prev_modmask = modmask;
    const mod_shift = (modmask & 1) == 1;
    const mod_rshift = (modmask & 2) == 2;
    const mod_ctrl = (modmask & 4) == 4;
    const mod_rctrl = (modmask & 8) == 8;
    const mod_cs = (modmask & 5) == 5;
    const mod_rcs = (modmask & 10) == 10;
    const cursor_spd = mod_shift ? 16 : 1;
    // debug_log("modmask", modmask);
    if (console_mode) {
      if (key == SDL_SCANCODE_ESCAPE || key == SDL_SCANCODE_RETURN) {
        if (key == SDL_SCANCODE_RETURN) {
          execute_console_command();
        }
        console_mode = false;
        SDL_StopTextInput();
        console_text = string();
        console_text_cursor = 0;
        msg_r = message;
        return;
      }
      if (key == SDL_SCANCODE_BACKSPACE) {
        if (console_text_cursor > 0) {
          dbg_console() {
            debug_log("cur,txt", console_text_cursor, console_text);
          }
          const s = console_text[0 .. console_text_cursor - 1u] +
            console_text[console_text_cursor .. console_text.size()];
          console_text = s;
          --console_text_cursor;
        }
      } else if (key == SDL_SCANCODE_LEFT) {
        if (console_text_cursor > 0) {
          --console_text_cursor;
        }
      } else if (key == SDL_SCANCODE_RIGHT) {
        if (console_text_cursor < console_text.size()) {
          ++console_text_cursor;
        }
      }
      msg_r = get_console_text();
      return;
    }
    if (key == SDL_SCANCODE_ESCAPE) {
      console_mode = true;
      SDL_StartTextInput();
      console_text = string();
      console_text_cursor = 0;
      msg_r = get_console_text();
      return;
    } else if (key == SDL_SCANCODE_F5 || key == SDL_SCANCODE_F12) {
      // SHIFT+F12ならmipmap更新を省略する
      if (key == SDL_SCANCODE_F5 || !mod_shift) {
        emt->vox.update_mipmap();
        sync_gl_mipmap_all(*emt);
      } else {
        debug_log("F12: updating mipmap skipped");
      }
      if (key == SDL_SCANCODE_F12) {
        save_state();
      }
    } else if (key == SDL_SCANCODE_1) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_blank, modmask, prev_key_repeat);
      } else {
        edit_params_mode = edit_params_mode_none;
        update_cursor_color();
        // message = "exiting edit-params mode";
      }
    } else if (key == SDL_SCANCODE_2) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_wall, modmask, prev_key_repeat);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_color;
      update_cursor_color();
      // message = "entering edit-color mode";
    } else if (key == SDL_SCANCODE_3) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_plane, modmask, prev_key_repeat);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_plane;
      update_cursor_color();
      // message = "entering edit-plane-params mode";
    } else if (key == SDL_SCANCODE_4) {
      if (mod_shift) {
        change_fill_type(edit_fill_type_sphere, modmask, prev_key_repeat);
      }
      reset_edit_params();
      edit_params_mode = edit_params_mode_sphere_1;
      update_cursor_color();
      // message = "entering edit-sphere-center-distance mode";
    } else if (key == SDL_SCANCODE_9) {
      if (mod_shift) {
        gen_test_param = min(gen_test_param + 1, 15);
        *rndp = *rndp_saved;
      } else if (mod_ctrl) {
        gen_test_param = max(gen_test_param - 1, -15);
        *rndp = *rndp_saved;
      }
      dbg_gen() {
        debug_log("gen_test_param", gen_test_param);
      }
      *rndp_saved = *rndp;
      gen_test();
    }
    if (edit_params_mode == edit_params_mode_none) {
      // パラメータ変更モードでは無い場合。カーソル移動やコピペなどの
      // 操作を処理する。
      if (key == SDL_SCANCODE_MINUS) {
        set_space();
      } else if (key == SDL_SCANCODE_C) {
        if (mod_rshift) {
          filling_create(cursor_move_r);
        } else {
          copy_value();
        }
      } else if (key == SDL_SCANCODE_V) {
        merge_mode const mmod =
          mod_ctrl ? merge_mode_or_ori() : merge_mode_opaque();
        paste_value(mod_shift ? 0x02u : 0xffu, mmod);
          // mod_shiftなら色だけ貼り付け
      } else if (key == SDL_SCANCODE_COMMA) {
        if (mod_shift) {
          shrink_range();
        } else if (mod_rshift) {
          filling_next(true, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_PERIOD) {
        if (mod_shift) {
          scale_range();
        } else if (mod_rshift) {
          filling_next(false, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_I) {
        if (mod_shift) {
          swap_cursor();
        } else if (mod_rshift) {
          filling_select(cursor_move_r);
        } else {
          set_mark();
        }
      } else if (key == SDL_SCANCODE_H) {
        if (mod_rcs) {
          cdir.x = -cdir.x;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          rotate_range(glm::make_imat3(1, 0, 0, 0, 0, -1, 0, 1, 0));
        } else if (mod_ctrl) {
          // x軸反転
          rotate_range(glm::make_imat3(-1, 0, 0, 0, 1, 0, 0, 0, 1));
        } else if (mod_rshift) {
          filling_modify(-1, 0, 0);
        } else {
          move_cursor(-cdir.x * cursor_spd, 0, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_L) {
        if (mod_rcs) {
          cdir.x = -cdir.x;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          rotate_range(glm::make_imat3(1, 0, 0, 0, 0, 1, 0, -1, 0));
        } else if (mod_ctrl) {
          // x軸反転
          rotate_range(glm::make_imat3(-1, 0, 0, 0, 1, 0, 0, 0, 1));
        } else if (mod_rshift) {
          filling_modify(1, 0, 0);
        } else {
          move_cursor(cdir.x * cursor_spd, 0, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_J) {
        if (mod_rcs) {
          cdir.y = -cdir.y;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          rotate_range(glm::make_imat3(0, 0, 1, 0, 1, 0, -1, 0, 0));
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, -1, 0, 0, 0, 1));
        } else if (mod_rshift) {
          filling_modify(0, -1, 0);
        } else {
          move_cursor(0, -cdir.y * cursor_spd, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_K) {
        if (mod_rcs) {
          cdir.y = -cdir.y;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          rotate_range(glm::make_imat3(0, 0, -1, 0, 1, 0, 1, 0, 0));
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, -1, 0, 0, 0, 1));
        } else if (mod_rshift) {
          filling_modify(0, 1, 0);
        } else {
          move_cursor(0, cdir.y * cursor_spd, 0, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_N) {
        if (mod_rcs) {
          cdir.z = -cdir.z;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          rotate_range(glm::make_imat3(0, -1, 0, 1, 0, 0, 0, 0, 1));
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, 1, 0, 0, 0, -1));
        } else if (mod_rshift) {
          filling_modify(0, 0, -1);
        } else {
          move_cursor(0, 0, -cdir.z * cursor_spd, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_P) {
        if (mod_rcs) {
          cdir.z = -cdir.z;
        } else if (mod_cs) {
          const ssz = ttev->get_cursor_range().second;
          rotate_range(glm::make_imat3(0, 1, 0, -1, 0, 0, 0, 0, 1));
        } else if (mod_ctrl) {
          rotate_range(glm::make_imat3(1, 0, 0, 0, 1, 0, 0, 0, -1));
        } else if (mod_rshift) {
          filling_modify(0, 0, 1);
        } else {
          move_cursor(0, 0, cdir.z * cursor_spd, cursor_move_r);
        }
      } else if (key == SDL_SCANCODE_0) {
        if (get_cursor_tpat()) {
          dbg_conv() { debug_log("scancode_0"); }
          if (mod_shift) {
            dbg_conv() { debug_log("convert_to_tmap"); }
            convert_to_tmap();
          } else {
            set_cursor_tpat(false);
          }
        } else {
          if (mod_shift) {
            dbg_conv() { debug_log("convert_to_tpat"); }
            convert_to_tpat();
          } else {
            if (is_cur_tmap_node_reference()) {
              set_cursor_tpat(true);
            }
          }
        }
      } else if (key == SDL_SCANCODE_Q) {
        if (mod_rshift) {
          filling_erase();
        }
      }
    } else {
      // パラメータ変更モードの場合。それぞれのモードに応じて動作は変わる。
      if (key == SDL_SCANCODE_H) {
        set_param(cdir.x > 0 ? 0 : 1, modmask);
      } else if (key == SDL_SCANCODE_L) {
        set_param(cdir.x > 0 ? 1 : 0, modmask);
      } else if (key == SDL_SCANCODE_J) {
        set_param(cdir.y > 0 ? 2 : 3, modmask);
      } else if (key == SDL_SCANCODE_K) {
        set_param(cdir.y > 0 ? 3 : 2, modmask);
      } else if (key == SDL_SCANCODE_N) {
        set_param(cdir.z > 0 ? 4 : 5, modmask);
      } else if (key == SDL_SCANCODE_P) {
        set_param(cdir.z > 0 ? 5 : 4, modmask);
      } else if (key == SDL_SCANCODE_COMMA) {
        set_param(6, modmask);
      } else if (key == SDL_SCANCODE_PERIOD) {
        set_param(7, modmask);
      } else if (key == SDL_SCANCODE_SLASH) {
        set_param(8, modmask);
      }
      ttev->cursor_flick_hide();
    }
    // debug_log("scancode", scancode);
    if (message.empty()) {
      message = "cursor " + to_string(ttev->get_cursor_pos().first);
      if (mark_set) {
        message += " " + to_string(to_ivec3(
          ttev->get_cursor_pos().second - ttev->get_cursor_pos().first));
      }
      if (edit_params_mode == edit_params_mode_color) {
        message += " [color params]";
      } else if (edit_params_mode == edit_params_mode_plane) {
        message += " [plane params]";
      } else if (edit_params_mode == edit_params_mode_sphere_1) {
        message += " [sphere params]";
      }
      size_t mlv = 0u;
      if (prj.option_value2 >= 0.0) {
        mlv = static_cast{size_t}(prj.option_value2);
      }
      size_t mlpat;
      size_t mlmap;
      const vs = get_cur_value(texture_value_index_secondary, mlv, mlpat,
        mlmap);
      const vp = get_cur_value(texture_value_index_primary, mlv, mlpat, mlmap);
      if (is_space_voxel(vp)) {
        const dv = get_dist_3d(vp);
        message += " space " + to_string(dv) + " mip " + to_string(mlpat)
          + " " + to_string(mlmap);
      } else if (is_node_reference(vp)) {
        if (m::eq{dbg_noderef{1}, 1}) {
          const vp1 = get_cur_value(texture_value_index_primary, 4, mlpat,
            mlmap);
          message += " ref(ml2) " + to_hexstring(vp1);
          const vp2 = get_cur_value(texture_value_index_primary, 5, mlpat,
            mlmap);
          const vp2s = get_cur_value(texture_value_index_secondary, 5, mlpat,
            mlmap);
          message += " " + to_hexstring(vp2);
          message += " " + to_hexstring(vp2s);
        }
        const rp = decode_noderef_param(vp);
        message += " ref " + to_string(rp);
      } else if (is_filled(vp)) {
        message += " filled";
      } else if (is_plane_node(vp)) {
        const pp = decode_plane_node(vp);
        message += " plane " + to_string(pp);
      } else if (is_sphere_node(vp)) {
        const sp = decode_sphere_node(vp);
        message += " sphere " + to_string(sp);
      }
      if (!is_space_voxel(vp) && !is_node_reference(vp)) {
        const cp = decode_color_param(vs);
        message += " " + to_string(cp);
      }
      const fi = ttev->get_filling(ttev->get_cursor_pos().first);
      // debug_log("fi=", fi);
      if (fi.size().x != 0) {
        message += " fi=" + to_string(
          ttev->get_cursor_pos().first - fi.offset);
      }
    }
    msg_r = message;
  }
  public function void on_textinput(string const& s, string mutable& msg_r)
  {
    if (console_text_cursor >= console_text.size()) {
      console_text += s;
    } else {
      const r = console_text[0 .. console_text_cursor] + s
        + console_text[console_text_cursor .. console_text.size()];
      console_text = r;
    }
    console_text_cursor += s.size();
    dbg_editmode() {
      debug_log("on_textinput: ", s, console_text);
    }
    msg_r = get_console_text();
  }
  public function void set_camera_angle(glm::quat const& angle)
  {
  }
  public function void on_frame(projection_info const& prj0)
  {
    prj = prj0;
    ttev->cursor_flick();
  }
  public function void modify_tmap(uvec3 const& pos, uint value)
  {
    ttev->tmap_edit_set(pos, texture_value_index_primary, value);
  }
  public function bool is_textinput_mode() const
  {
    return console_mode;
  }
  /////////////////////////////////////////////////////////////////////
  private struct edit_state() {
    public ttev_state ttev;
    public glm::ivec3 cdir = glm::make_ivec3(1, 1, 1);
      // 各軸のカーソル移動を変換する
  }
  private ptr{edit_mode_texture} emt = emt0;
  private ptr{tiled_texture_edit_view} const ttev =
    make_ptr{tiled_texture_edit_view}(emt0);
  private projection_info prj;
  private copy_data_type copy_data;
  private ptr{rand_generator} rndp = make_rand_generator(123u);
  private ptr{rand_generator} rndp_saved = rndp;
  private int gen_test_param = 0;
  private glm::ivec3 cdir = glm::make_ivec3(1, 1, 1);
  private edit_params_mode_t edit_params_mode;
  private color_param edit_color_param;
  private plane_param edit_plane_param;
  private sphere_param edit_sphere_param;
  private bool mark_set;
  private bool copied;
  private glm::uvec3 find_empty_cur; // 空のタイルを探すのに使う
  private string message;
  private SDL_Scancode prev_key; // 同じキーを繰り返したかどうか判定するのに使う
  private uint prev_modmask;
  private uint prev_key_repeat;
  private bool console_mode;
  private string console_text;
  private size_t console_text_cursor;
  private uint cur_tile_scale_log2 = 4;
  init();
  /////////////////////////////////////////////////////////////////////
  private function void init()
  {
    dbg_editmode() {
      debug_log("edit_mode", "voxtmap",
        emt->vox.tmap_edit->data_pri[0].get_size_uvec3());
    }
    string buf;
    {
      sdl_load_file("/build/edit_selection.ser", buf);
      if (!buf.empty()) {
        copy_data = copy_data_type_compat_deserialize(buf);
      }
    }
    {
      edit_state est;
      sdl_load_file("/build/edit_state.raw", buf);
      if (!buf.empty()) {
        // TODO: from_string_compact_podがfarrayを使えない
        est = from_string{edit_state}(buf);
        ttev->set_state(est.ttev);
        cdir = est.cdir;
      }
    }
    update_cursor_color();
    debug_log("edit_mode: tpat_texture:", ttev->tpat_size);
    debug_log("edit_mode: tmap_texture:", ttev->tmap_size);
  }
  private function void save_state()
  {
    // 編集中のテクスチャなどを保存する。保存されたデータのロードは
    // アプリ側で行う必要がある。
    dbg_save() { debug_log("edit_mode: save"); }
    edit_state est;
    est.ttev = ttev->get_state();
    est.cdir = cdir;
    sdl_save_file("/build/edit_state.raw", to_string(est));
    const msz = emt->vox.tmap_edit->data_pri[0].get_size_l2_uvec3();
    const psz = emt->vox.tpat_edit->data_pri[0].get_size_l2_uvec3();
    {
      // "edit_2_9_9_6_10_9_9.raw"のようなファイル名。voxelデータをそのまま
      // 保存する。
      string fn = "/build/edit_2_"
        + to_string(msz.x) + "_"
        + to_string(msz.y) + "_"
        + to_string(msz.z) + "_"
        + to_string(psz.x) + "_"
        + to_string(psz.y) + "_"
        + to_string(psz.z) + ".raw";
      debug_log("edit_mode: save " + fn);
      sdl_save_file(fn, to_string_compact_pod(emt->vox));
    }
    {
      // 現在の選択データを保存。
      string fn = "/build/edit_selection.ser";
      sdl_save_file(fn, to_string(copy_data));
    }
    /*
    {
      // tpatテクスチャを保存。
      texture_edit const& tpat = *emt->vox.tpat_edit;
      string fn = "/build/edit_common_tpat.raw";
      sdl_save_file(fn, to_string(tpat));
    }
    {
      // tmapテクスチャのprimaryとsecondaryを保存。
      texture_reshaped const& tmpri = emt->vox.tmap_edit->data_pri[0];
      texture_reshaped tmpri_cpy;
      tmpri_cpy.set_size_l2(6u, 6u, 6u);
      texture_data_copy_range(tmpri_cpy, uvec3(), tmpri, uvec3(),
        make_uvec3(64u, 64u, 64u));
      sdl_save_file("/build/edit_common_tmpri.raw",
        to_string_compact_pod(tmpri_cpy));
      texture_reshaped const& tmsec = emt->vox.tmap_edit->data_sec[0];
      texture_reshaped tmsec_cpy;
      tmsec_cpy.set_size_l2(6u, 6u, 6u);
      texture_data_copy_range(tmsec_cpy, uvec3(), tmsec, uvec3(),
        make_uvec3(64u, 64u, 64u));
      sdl_save_file("/build/edit_common_tmsec.raw",
        to_string_compact_pod(tmsec_cpy));
    }
    */
    message = "edit_mode: saved";
  }
  private function string get_console_text() const
  {
    string r = console_text;
    if (console_text_cursor >= console_text.size()) {
      r.push_back(static_cast{uchar}(0x20 | 0x80));
    } else {
      r[console_text_cursor] |= 0x80;
    }
    return "> " + r;
  }
  private function void update_cursor_color()
  {
    uint c =
      edit_params_mode == edit_params_mode_none ? 0xffffffffu :
      edit_params_mode == edit_params_mode_color ? 0xffff0000u :
      edit_params_mode == edit_params_mode_plane ? 0xffffff00u :
      edit_params_mode == edit_params_mode_sphere_1 ? 0xffff00ffu :
      0xff0000ffu;
    ttev->set_cursor_color(c, 0xffc08040);
    dbg_editmode() {
      debug_log("update_cursor_color", c);
    }
  }
  private function void execute_console_command()
  {
    varray{string} toks;
    string_split{' '}(console_text, toks);
    if (toks.empty()) {
      return;
    }
    const& cmd = toks[0];
    if (cmd == "save" && toks.size() == 2) {
      // コピーバッファをファイルに保存する。
      const fn = save_dir + toks[1];
      {
        // コピーバッファを保存する。noderefの参照先は保存されない。
        if (!sdl_save_file(fn + ".pat", to_string(copy_data))) {
          debug_log("failed to save", fn + ".pat");
          return;
        }
      }
      {
        // コピーバッファとnoderef参照先を保存する。
        pattern_save_data psd;
        if (!convert_to_pattern_save_data(psd, copy_data, *ttev)) {
          debug_log("get_pattern_save_data failed");
          return;
        }
        if (!sdl_save_file(fn + ".psd", to_string(psd))) {
          debug_log("failed to save", fn + ".psd");
          return;
        }
      }
      debug_log("saved", fn);
    } else if (cmd == "load" && toks.size() == 2) {
      // パターンデータを読み込んでコピーバッファに入れる
      string buf;
      const fn = save_dir + toks[1];
      sdl_load_file(fn + ".psd", buf);
      if (!buf.empty()) {
        // noderef参照先を含めたパターンデータを読み込む。
        const psd = from_string{pattern_save_data}(buf);
        convert_from_pattern_save_data(psd, copy_data,
          ttev->get_max_tile_scale_log2(), *ttev);
        debug_log("loaded", fn + ".psd");
        return;
      }
      sdl_load_file(fn + ".pat", buf);
      if (!buf.empty()) {
        // パターンデータを読み込む。noderef参照先は含まれない。
        copy_data = copy_data_type_compat_deserialize(buf);
        mark_set = true;
        copied = true;
        glm::vec3 cursor_move_r;
        move_cursor(0, 0, 0, cursor_move_r);
        debug_log("loaded", fn + ".pat");
        return;
      }
      debug_log("failed to load", fn);
    } else if (cmd == "scale" && toks.size() == 2) {
      // 現在のタイルサイズを変更する。新規タイル割り当ての際にこの
      // 値が影響する。
      const tsc = from_string{uint}(toks[1]);
      if (tsc < 1u || tsc > 8) {
        debug_log("invalid param:", toks[1]);
      } else {
        debug_log("tile scale:", tsc);
        cur_tile_scale_log2 = tsc;
        find_empty_cur = uvec3();
      }
    } else if (cmd == "maxscale" && toks.size() == 1) {
      // 最大タイルサイズを取得する。
      debug_log("maxscale", ttev->get_max_tile_scale_log2());
      const s = ttev->get_max_tile_scale_log2();
      const n = get_num_assignable_tile(*ttev, s);
      message = "maxscale " + to_string(s) + " assignable " + to_string(n);
    } else if (cmd == "maxscale" && toks.size() == 2) {
      // 最大タイルサイズを変更する。これを変更後dedupすると再配置される。
      uint const absmax_v = absmax_tile_scale_log2;
      const v = from_string{uint}(toks[1]);
      if (v <= absmax_v) {
        debug_log("setting maxscale", v);
        ttev->set_max_tile_scale_log2(v);
      }
      const s = ttev->get_max_tile_scale_log2();
      const n = get_num_assignable_tile(*ttev, s);
      message = "maxscale " + to_string(s) + " assignable " + to_string(n);
    } else if (cmd == "dedup" && toks.size() == 1) {
      // タイルパターンの重複排除と再配置をおこなう。現在のmaxscale値に
      // 応じた配置になる。参照されていないパターンは削除される。
      debug_log("dedup tpat");
      message = dedup_tpat(*ttev, ttev->get_max_tile_scale_log2(), false);
    } else if (cmd == "dedup" && toks.size() == 2 && toks[1] == "force") {
      // dedupを強制的におこなう。配置可能タイル数が不足していたときは
      // タイルパターンが失われる。
      debug_log("dedup tpat force");
      message = dedup_tpat(*ttev, ttev->get_max_tile_scale_log2(), true);
    } else if (cmd == "unused" && toks.size() == 1) {
      // 参照されていないタイルパターンを削除する。
      debug_log("erase_unused_tpat");
      erase_unused_tpat(*ttev);
    } else if (cmd == "gen" && toks.size() >= 5) {
      int proc = from_string{int}(toks[1]);
      uvec3 sz;
      sz.x = from_string{uint}(toks[2]);
      sz.y = from_string{uint}(toks[3]);
      sz.z = from_string{uint}(toks[4]);
      varray{int} params;
      for (const i, const p: toks[5 .. toks.size()]) {
        params.push_back(from_string{int}(p));
      }
      procedural_gen(proc, sz, params);
    } else if (cmd == "test_noderef" && toks.size() == 1) {
      // 内部テスト。noderef_paramのimat3変換をテストする。
      debug_log("test_noderef");
      test_noderef_param();
    } else {
      debug_log("unrecognized command", toks);
      message = "unrecognized command";
    }
  }
  private function void set_mark()
  {
    const cur = ttev->get_cursor_pos();
    if (copied && cur.first == cur.second) {
      copied = false;
      mark_set = true;
    } else {
      mark_set = !mark_set;
      if (!mark_set) {
        copied = false;
      }
      ttev->set_cursor_pos(cur.first, cur.first);
    }
  }
  private function void swap_cursor()
  {
    const cur = ttev->get_cursor_pos();
    ttev->set_cursor_pos(cur.second, cur.first);
  }
  private function void move_cursor(int x, int y, int z,
    glm::vec3 mutable& cursor_move_r)
  {
    mutable cur = ttev->get_cursor_pos();
    const old_pos = to_ivec3(cur.first);
    mutable pos = old_pos;
    pos += make_ivec3(x, y, z);
    if (get_cursor_tpat()) {
      pos = clamp_grid(old_pos, pos);
    }
    pos = ttev->clamp_cursor_pos(pos);
    cur.first = to_uvec3(pos);
    if (copied) {
      mutable cpos = cur.first;
      const coff = copy_data.cursor_offset;
      const cmx = to_ivec3(copy_data.copy_size) - make_ivec3(1, 1, 1);
      ivec3 scur;
      scur.x = (coff.x == 0) ? cmx.x : -cmx.x;
      scur.y = (coff.y == 0) ? cmx.y : -cmx.y;
      scur.z = (coff.z == 0) ? cmx.z : -cmx.z;
      mutable spos = to_ivec3(cpos) + scur;
      spos = map{ivec3, max}(spos, make_ivec3(0, 0, 0));
      cur.second = to_uvec3(spos);
    } else if (!mark_set) {
      cur.second = cur.first;
    }
    ttev->set_cursor_pos(cur.first, cur.second);
    {
      // テクスチャ座標でのカーソル移動量を計算
      cursor_move_r = to_vec3(
        to_ivec3(ttev->get_cursor_pos().first) - old_pos);
      const tms_max = fold_list{max}(1u, ttev->tmap_size);
      cursor_move_r /= static_cast{float}(tms_max);
      if (get_cursor_tpat()) {
        cursor_move_r /= static_cast{float}(1 << cur_tile_scale_log2);
      }
    }
    {
      // 乱数のシードをカーソル位置から初期化
      uint v = (cur.first.x << 16u) | (cur.first.y << 8u) | (cur.first.z);
      rndp = make_rand_generator(v);
    }
  }
  private function bool get_cursor_tpat() const
  {
    return ttev->get_cursor_tpat();
  }
  private function void set_cursor_tpat(bool tpat)
  {
    if (tpat && !get_cursor_tpat()) {
      const tppos_sc = cur_tpat_base();
      if (tppos_sc.second == 0u) {
        return; // カーソル位置がnoderefでないので何もしない
      }
      cur_tile_scale_log2 = tppos_sc.second; // 1以上の値。4のとき16倍.
      ttev->set_tpat_cursor_pos(tppos_sc.first, tppos_sc.first);
    }
    ttev->set_cursor_tpat(tpat);
  }
  private function void set_param(int v, uint modmask)
  {
    const uchar mult = static_cast{uchar}(((modmask & 1) != 0 )? 16u : 1u);
    const use_plane = (modmask & 1) != 0;
    if (edit_params_mode == edit_params_mode_color) {
      set_param_color(v, mult);
    } else if (edit_params_mode == edit_params_mode_plane) {
      set_param_plane(v);
    } else if (edit_params_mode == edit_params_mode_sphere_1) {
      set_param_sphere_1(v, modmask);
    }
  }
  private function void set_param_color(int v, uchar mult)
  {
    mutable& p = edit_color_param;
    function void inc(uint mutable& v) {
      v = (v + mult < 255u) ? v + mult : 255u;
    }
    function void dec(uint mutable& v) {
      v = (v > mult) ? v - mult : 0u;
    }
    if (v == 0) {
      dec(p.rgb.r);
    } else if (v == 1) {
      inc(p.rgb.r);
    } else if (v == 2) {
      dec(p.rgb.g);
    } else if (v == 3) {
      inc(p.rgb.g);
    } else if (v == 4) {
      dec(p.rgb.b);
    } else if (v == 5) {
      inc(p.rgb.b);
    } else if (v == 6) {
      inc(p.roughness);
      p.roughness &= 0x0fu;
    } else if (v == 7) {
      if (p.emission != 0) {
        p.emission = 0;
        p.metalness = 1;
      } else if (p.metalness != 0) {
        p.emission = 0;
        p.metalness = 0;
      } else {
        p.emission = 1;
        p.metalness = 0;
      }
    }
    // debug_log("color_param", p);
    fill_range_color(p, false);
    message = "edit_mode: set color " + to_string(p);
  }
  private function void set_param_plane(int v)
  {
    mutable& p = edit_plane_param;
    if (v == 0) {
      p.nor.x -= 1;
    } else if (v == 1) {
      p.nor.x += 1;
    } else if (v == 2) {
      p.nor.y -= 1;
    } else if (v == 3) {
      p.nor.y += 1;
    } else if (v == 4) {
      p.nor.z -= 1;
    } else if (v == 5) {
      p.nor.z += 1;
    } else if (v == 6) {
      p.dist -= 1;
    } else if (v == 7) {
      p.dist += 1;
    }
    p.clamp_param();
    fill_range_plane(p, false);
    message = "edit_mode: set plane params " + to_string(p);
  }
  private function void set_param_sphere_1(int v, uint modifier)
  {
    mutable& p = edit_sphere_param;
    if ((modifier & 1) == 0) {
      if (v == 0) {
        p.center.x -= 1;
      } else if (v == 1) {
        p.center.x += 1;
      } else if (v == 2) {
        p.center.y -= 1;
      } else if (v == 3) {
        p.center.y += 1;
      } else if (v == 4) {
        p.center.z -= 1;
      } else if (v == 5) {
        p.center.z += 1;
      } else if (v == 6) {
        p.dist = p.dist > 1 ? p.dist - 1 : 1;
      } else if (v == 7) {
        p.dist = p.dist < 63 ? p.dist + 1 : 63;
      } else if (v == 8) {
        p.ura = !p.ura;
      }
    } else {
      if (v == 0) {
        p.scale.x = p.scale.x > 0 ? p.scale.x - 1 : 0;
      } else if (v == 1) {
        p.scale.x = p.scale.x < 3 ? p.scale.x + 1 : 3;
      } else if (v == 2) {
        p.scale.y = p.scale.y > 0 ? p.scale.y - 1 : 0;
      } else if (v == 3) {
        p.scale.y = p.scale.y < 3 ? p.scale.y + 1 : 3;
      } else if (v == 4) {
        p.scale.z = p.scale.z > 0 ? p.scale.z - 1 : 0;
      } else if (v == 5) {
        p.scale.z = p.scale.z < 3 ? p.scale.z + 1 : 3;
      }
    }
    fill_range_sphere(p, false, modifier);
    // FIXME?
    message = "edit_mode: set sphere center/dist params " + to_string(p);
  }
  private function void copy_value()
  {
    const cur = ttev->get_cursor_range();
    copy_data.copy_size = cur.second;
    copy_data.cursor_offset = ttev->get_cursor_pos().first - cur.first;
    debug_log("copy_value: cursor_offset", copy_data.cursor_offset);
    const sz_l2 = map{uvec3, integral_log2{uint}}(copy_data.copy_size);
    for (const i, mutable& tex: copy_data.tex) {
      tex.set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    ttev->edit_copy_range(cur.first, cur.second, copy_data.tex[0],
      copy_data.tex[1], uvec3());
    mark_set = true;
    copied = true;
    message = "edit_mode: copy value " + to_string(copy_data.copy_size);
  }
  private function ivec3 clamp_grid(ivec3 cpos, ivec3 pos)
  {
    function void clamp_one(int a, int mutable& b)
    {
      const sc = cur_tile_scale_log2;
      const am = a >> sc;
      const bm = b >> sc;
      if (bm < am) {
        b = am << sc;
      } else if (bm > am) {
        b = ((am + 1u) << sc) - 1u;
      }
    }
    clamp_one(cpos.x, pos.x);
    clamp_one(cpos.y, pos.y);
    clamp_one(cpos.z, pos.z);
    return pos;
  }
  private function void paste_value(uint index_mask, merge_mode const& mmod)
  {
    // 現在の選択領域の内容をカーソル位置にpasteする。カーソルがtpatにいる
    // ときは、カーソルと同一のgridの範囲にのみ書き込まれる。
    const cpos = ttev->get_cursor_pos().first;
    // ペースト先の領域を計算
    const mi_0 = to_ivec3(cpos) - to_ivec3(copy_data.cursor_offset);
    const mx_0 = mi_0 + to_ivec3(copy_data.copy_size) - make_ivec3(1, 1, 1);
    mutable mi = mi_0;
    mutable mx = mx_0;
    if (get_cursor_tpat()) {
      if (cur_tile_scale_log2 == 0) {
        debug_log("paste_value: no scale set");
        return;
      }
      // ペースト先の領域をグリッド境界を超えないようにclamp
      mi = clamp_grid(to_ivec3(cpos), mi_0);
      mx = clamp_grid(to_ivec3(cpos), mx_0);
      if (mi != mi_0 || mx != mx_0) {
        debug_log("paste_value: clamp_grid mi", mi_0, mi);
        debug_log("paste_value: clamp_grid mx", mx_0, mx);
      }
    }
    // ペースト先の領域をテクスチャ境界でclamp
    mi = ttev->clamp_cursor_pos(mi);
    mx = ttev->clamp_cursor_pos(mx);
    const sz = mx - mi + make_ivec3(1, 1, 1);
    // ペースト元の領域を計算。ペースト先領域をclampしたのに合わせてオフセット
    // を付ける。
    const cd_mi = mi - mi_0;
    /*
    debug_log("paste_value: cpos,mi_0,mx_0,mi,mx,sz,cd_mi", cpos,
      mi_0, mx_0, mi, mx, sz, cd_mi);
    */
    ttev->edit_paste_range(to_uvec3(mi), to_uvec3(sz), copy_data.tex[0],
      copy_data.tex[1], to_uvec3(cd_mi), index_mask, mmod);
    // message = "edit_mode: paste value " + to_string(sz);
  }
  private function void convert_to_tmap()
  {
    // TODO
  }
  private function void convert_to_tpat()
  {
    // 現在の選択領域を内容を持つようなタイルを新しく作る。
    dbg_conv() { debug_log("convert_to_tpat"); }
    if (get_cursor_tpat()) {
      debug_log("convert_to_tpat: failed(cursor tpat)");
      return;
    }
    const cur = ttev->get_cursor_pos().first;
    const v = ttev->tmap_edit_get(cur, texture_value_index_primary, 0u);
    if (is_node_reference(v)) {
      debug_log("convert_to_tpat: failed(noderef)");
      return;
    }
    const csz = copy_data.copy_size;
    const tilesz = 1u << cur_tile_scale_log2;
    const patsz = (csz + tilesz - 1u) / tilesz; // タイルパターン数
    // 空きタイルパターンを探す。現在の実装では1タイルを超えるサイズのときは
    // 連続領域で空いているものを探すが、連続でなくてもよいかもしれない。
    const nv = find_empty_tpat(*ttev, find_empty_cur, cur_tile_scale_log2,
      ttev->get_max_tile_scale_log2(), patsz);
    if (!is_node_reference(nv)) {
      debug_log("convert_to_tpat: fialed(nomem)");
      return;
    }
    debug_log("convert_to_tpat: noderef=", to_hexstring(nv));
    ttev->set_cursor_pos(cur, cur);
    copy_data.cursor_offset = make_uvec3(0u, 0u, 0u);
    // カーソル位置へタイル値を書き込む
    range_foreach(patsz) void (uint x, uint y, uint z) {
      mutable np = decode_noderef_param(nv);
      np.coord += make_uvec3(x, y, z);
      np.scale = cur_tile_scale_log2 - 1u;
      const cur_p = cur + make_uvec3(x, y, z);
      dbg_conv() { debug_log("convert_to_tpat: tmap set",
        cur_p, np); }
      ttev->tmap_edit_set(cur_p, texture_value_index_primary,
        encode_noderef_param(np));
    }
    // 元データをtpatへ貼り付ける
    set_cursor_tpat(true);
    paste_value(0xffu, merge_mode_opaque());
    debug_log("convert_to_tpat: cur_tile_scale_log2:", cur_tile_scale_log2);
    // 元データが小さいときはタイルに収まる範囲で拡大する
    while (le_all_uvec3(copy_data.copy_size * 2u, tilesz)) {
      debug_log("convert_to_tpat: scale to fit", copy_data.copy_size);
      scale_range();
    }
    debug_log("convert_to_tpat: done");
  }
  private function void shrink_range()
  {
    // 選択領域を各辺半分に縮小する
    {
      // 選択領域のサイズが2の倍数でなかったときの処理
      const cp = ttev->get_cursor_pos();
      mutable cd = to_ivec3(cp.second) - to_ivec3(cp.first);
      if (cd.x == 0 || cd.y == 0 || cd.z == 0) {
        return;
      }
      function void trunc_if_even(int mutable& v) {
        if (v % 2 == 0) {
          v += (v < 0) ? 1 : -1;
        }
      }
      trunc_if_even(cd.x);
      trunc_if_even(cd.y);
      trunc_if_even(cd.z);
      const cpm = to_uvec3(to_ivec3(cp.first) + cd);
      ttev->set_cursor_pos(cp.first, cp.second);
    }
    {
      // 縮小処理
      copy_value();
      const oszl2 = copy_data.tex[0].get_size_l2_uvec3();
      texture_data dpri;
      texture_data daux;
      dpri.set_size_l2(oszl2.x, oszl2.y, oszl2.z);
      daux.set_size_l2(oszl2.x, oszl2.y, oszl2.z);
      const sz = copy_data.copy_size / 2u;
      ivec3 dbase;
      dbase.x = (copy_data.cursor_offset.x == 0) ? 0 : si(sz.x);
      dbase.y = (copy_data.cursor_offset.y == 0) ? 0 : si(sz.y);
      dbase.z = (copy_data.cursor_offset.z == 0) ? 0 : si(sz.z);
      for (const z: 0 .. sz.z) {
        for (const y: 0 .. sz.y) {
          for (const x: 0 .. sz.x) {
            const p = make_ivec3(si(x), si(y), si(z));
            texel_value dpri_v;
            texel_value dsec_v;
            shrink_voxel_value(false, copy_data.tex[0], copy_data.tex[1],
              dpri_v, dsec_v, p);
            dpri.set(ui(p.x + dbase.x), ui(p.y + dbase.y), ui(p.z + dbase.z),
              dpri_v);
            daux.set(ui(p.x + dbase.x), ui(p.y + dbase.y), ui(p.z + dbase.z),
              dsec_v);
          }
        }
      }
      copy_data.tex[0] = dpri;
      copy_data.tex[1] = daux;
      paste_value(0xffu, merge_mode_opaque());
    }
    {
      // 選択領域を縮小
      const cp = ttev->get_cursor_pos();
      mutable cd = to_ivec3(cp.second) - to_ivec3(cp.first);
      cd /= 2;
      const cpm = to_ivec3(cp.first) + cd;
      ttev->set_cursor_pos(cp.first, to_uvec3(cpm));
      copy_value();
    }
  }
  private function void scale_range()
  {
    dbg_scale() {
      debug_log("scale_range: p0: copy_data:", copy_data,
        ttev->get_cursor_pos());
    }
    copy_value();
    dbg_scale() {
      debug_log("scale_range: p1: copy_data:", copy_data,
        ttev->get_cursor_pos());
    }
    texture_data spri;
    texture_data saux;
    const szl2 = copy_data.tex[0].get_size_l2_uvec3() + make_uvec3(1, 1, 1);
    spri.set_size_l2(szl2.x, szl2.y, szl2.z);
    saux.set_size_l2(szl2.x, szl2.y, szl2.z);
    const sz = copy_data.copy_size;
    bool succ = true;
    function texel_value tpat_get(uvec3 const& p, texture_value_index_e idx,
      size_t miplevel)
    {
      return ttev->tpat_edit_get(p, idx, miplevel);
    }
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
        for (const x: 0 .. sz.x) {
          succ &= scale_voxel_value{texture_reshaped, tpat_get}(
            copy_data.tex[0].get(x, y, z),
            copy_data.tex[1].get(x, y, z), spri, saux,
            si(x * 2), si(y * 2), si(z * 2));
        }
      }
    }
    if (!succ) {
      // タイル番号がエンコード可能な範囲を超えているときに起きる
      debug_log("scale_voxel_value failed");
      return;
    }
    copy_data.tex[0] = spri;
    copy_data.tex[1] = saux;
    copy_data.copy_size *= 2u;
    mutable& o = copy_data.cursor_offset;
    o *= 2u;
    if (o.x != 0u) { o.x += 1u; }
    if (o.y != 0u) { o.y += 1u; }
    if (o.z != 0u) { o.z += 1u; }
    dbg_scale() {
      debug_log("scale_range: 0: copy_data:", copy_data,
        ttev->get_cursor_pos());
    }
    paste_value(0xffu, merge_mode_opaque());
    dbg_scale() {
      debug_log("scale_range: 1: copy_data:", copy_data,
        ttev->get_cursor_pos());
    }
    // 選択領域を広げたので反映させるためにmove_cursorを呼ぶ
    glm::vec3 cursor_move_r;
    move_cursor(0, 0, 0, cursor_move_r);
    dbg_scale() {
      debug_log("scale_range: 2: copy_data:", copy_data,
        ttev->get_cursor_pos());
    }
  }
  private function void rotate_range(imat3 const& m)
  {
    function uvec3 rotate_size(uvec3 sz) {
      const isz = m * to_ivec3(sz);
      const asz = map{ivec3, abs{int}}(isz);
      return to_uvec3(asz);
    }
    copy_value();
    const ssz = copy_data.copy_size;
    const dsz = rotate_size(ssz);
    const stex = copy_data.tex; // copy
    if (ssz != dsz) {
      debug_log("cursor_offset pre", copy_data.cursor_offset);
      copy_data.cursor_offset = rotate_size(copy_data.cursor_offset);
      debug_log("cursor_offset post", copy_data.cursor_offset);
      copy_data.copy_size = dsz;
      for (const& i, mutable& tex: copy_data.tex) {
        tex.clear();
        tex.set_size_l2_uvec3(rotate_size(tex.get_size_l2_uvec3()));
      }
    }
    dbg_rotate() {
      debug_log("rotate_range", ssz, dsz);
      debug_log("tex[0]", copy_data.tex[0]);
      debug_log("spri", stex[0]);
    }
    rotate_texture_range(m, stex[0], stex[1], ssz, copy_data.tex[0],
      copy_data.tex[1]);
    paste_value(0xffu, merge_mode_opaque());
    glm::vec3 cursor_move_r;
    move_cursor(0, 0, 0, cursor_move_r);
  }
  private function void set_space()
  {
    if (!ttev->get_cursor_tpat()) {
      // tmapの広範囲を更新するのが遅いので1回でfillする処理にする。
      // ただしfixed pattern areaを書き換えてしまうので注意。
      const m = ttev->get_tmap_cursor_pos();
      const mi = map{uvec3, min}(m.first, m.second);
      const mx = map{uvec3, max}(m.first, m.second);
      debug_log("set_space tmap", m);
      const sz = mx - mi + make_uvec3(1, 1, 1);
      ttev->tmap_edit_fill_range(mi, sz, 0, 0);
      debug_log("set_space tmap done", m);
    } else {
      set_cur_value(texture_value_index_primary, 0u);
      set_cur_value(texture_value_index_secondary, 0u);
    }
    // message = "edit_mode: erased";
  }
  private function void reset_edit_params()
  {
    copy_value();
    const cur = ttev->get_cursor_range();
    const sz = cur.second;
    bool has_plane = false;
    bool has_sphere = false;
    plane_param pp;
    sphere_param sp;
    color_param cp;
    cp.rgb.r = 128;
    cp.rgb.g = 128;
    cp.rgb.b = 128;
    for (const z: 0 .. sz.z) {
      for (const y: 0 .. sz.y) {
        for (const x: 0 .. sz.x) {
          const v = copy_data.tex[0].get(x, y, z);
          if (is_plane_node(v)) {
            pp = decode_plane_node(v);
            const offset = make_ivec3(si(x*2+1), si(y*2+1), si(z*2+1))
              - to_ivec3(sz);
            pp.dist += dot_int(pp.nor, offset);
            has_plane = true;
          } else if (is_sphere_node(v)) {
            sp = decode_sphere_node(v);
            const offset2 = make_ivec3(
              si(x * 2 + 1), si(y * 2 + 1), si(z * 2 + 1))
              - to_ivec3(sz); // offset値の2倍
            sp.center += map{ivec3, operator::mul}(offset2, sp.scale) / 2;
            has_sphere = true;
          }
          if (!is_space_voxel(v) && !is_node_reference(v)) {
            cp = decode_color_param(copy_data.tex[1].get(x, y, z));
            debug_log("reset_edit_params: color", cp, to_hexstring(v));
          }
        }
      }
    }
    if (has_plane) {
      edit_plane_param = pp;
    } else if (has_sphere) {
      edit_sphere_param = sp;
    }
    edit_color_param = cp;
    // debug_log("reset_edit_params", copy_data);
  }
  private function void change_fill_type(edit_fill_type_t edit_fill_type,
    uint modifier, uint repeat)
  {
    const mod_ctrl = (modifier & 4) == 4;
    if (edit_fill_type == edit_fill_type_wall) {
      fill_range_value(255u << 24u, 0x00808080u, true);
      message = "change fill type: filled";
    } else if (edit_fill_type == edit_fill_type_plane) {
      edit_plane_param = make_plane_param_from_cursor(mod_ctrl, repeat);
      fill_range_plane(edit_plane_param, true);
      message = "change fill type: plane";
    } else if (edit_fill_type == edit_fill_type_sphere) {
      edit_sphere_param = sphere_param();
      fill_range_sphere(edit_sphere_param, true, modifier);
      message = "change fill type: sphere";
    } else {
      fill_range_value(0u, 0u, true);
    }
    // debug_log("new fill type", edit_fill_type);
  }
  private function plane_param make_plane_param_from_cursor(bool mod_ctrl,
    uint repeat) const
  {
    const cursor = ttev->get_cursor_pos();
    mutable cdir = to_ivec3(cursor.first) - to_ivec3(cursor.second);
    // サイズは各軸+1。ただし終点と始点が一致するときはむきがわからない
    cdir.x += cdir.x >= 0 ? 1 : -1;
    cdir.y += cdir.y >= 0 ? 1 : -1;
    cdir.z += cdir.z >= 0 ? 1 : -1;
    return make_plane_param_dir(cdir, !mod_ctrl, repeat);
  }
  private function {f} void fill_range_func(bool clear_pri, bool clear_sec)
  {
    const cur = ttev->get_cursor_range();
    // debug_log("fill_range: cursor=", cur, clear_pri, clear_sec);
    if (clear_pri || clear_sec) {
      copy_value();
    }
    const sz_l2 = map{uvec3, integral_log2{uint}}(copy_data.copy_size);
    if (clear_pri) {
      copy_data.tex[0].set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    if (clear_sec) {
      copy_data.tex[1].set_size_l2(sz_l2.x, sz_l2.y, sz_l2.z);
    }
    for (const z: 0 .. copy_data.copy_size.z) {
      for (const y: 0 .. copy_data.copy_size.y) {
        for (const x: 0 .. copy_data.copy_size.x) {
          f(copy_data, x, y, z);
        }
      }
    }
    paste_value(0xffu, merge_mode_opaque());
  }
  private function void fill_range_value(uint v_pri, uint v_sec, bool set_sec)
  {
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      if (set_sec) {
        data.tex[1].set(x, y, z, v_sec);
      } else {
        // 変更前が空白だったときはset_secが偽でもaux値をセットする
        const ov = data.tex[0].get(x, y, z);
        if (is_node_reference(ov) || is_space_voxel(ov)) {
          data.tex[1].set(x, y, z, v_sec);
        }
      }
      data.tex[0].set(x, y, z, v_pri);
    }
    fill_range_func{ffunc}(false, set_sec);
  }
  private function void fill_range_color(color_param const& p, bool clear)
  {
    const value = encode_color_param(p);
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex[0].get(x, y, z);
      if (is_node_reference(ov) || is_space_voxel(ov)) {
        return;
      }
      data.tex[1].set(x, y, z, value);
    }
    fill_range_func{ffunc}(false, clear);
  }
  private function void fill_range_plane(plane_param const& p, bool clear)
  {
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    debug_log("fill_range_plane", copy_size);
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex[0].get(x, y, z);
      if (is_node_reference(ov) || is_sphere_node(ov)) {
        return;
      }
      // pがテクスチャエントリに収まるかどうかはわからない。収まらないときは
      // なるべく近いパラメータが使われる。
      const v = make_plane_node(p, make_ivec3(
        si(x * 2 + 1) - si(copy_size.x),
        si(y * 2 + 1) - si(copy_size.y),
        si(z * 2 + 1) - si(copy_size.z)),
        1);
      data.tex[0].set(x, y, z, v);
      if (clear) {
        data.tex[1].set(x, y, z, 0x00808080u);
      }
    }
    fill_range_func{ffunc}(clear, false);
  }
  private function void fill_range_sphere(sphere_param const& p, bool clear,
    uint modifier)
  {
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    function void ffunc(copy_data_type mutable& data, uint x, uint y, uint z)
    {
      const ov = data.tex[0].get(x, y, z);
      if (is_node_reference(ov)) {
        return;
      }
      const v = make_sphere_node(p, make_ivec3(
        si(x * 2 + 1) - si(copy_size.x),
        si(y * 2 + 1) - si(copy_size.y),
        si(z * 2 + 1) - si(copy_size.z)),
        1, modifier);
      data.tex[0].set(x, y, z, v);
      if (clear) {
        data.tex[1].set(x, y, z, 0x00808080u);
      }
    }
    fill_range_func{ffunc}(clear, false);
  }
  private function pair{uvec3, uint} cur_tpat_base() const
  {
    // firstとしてtpmapカーソルにあるnoderefのパターン座標を返す
    // secondとしてnoderefのscale値(1基準)
    const v = get_cur_tmap(texture_value_index_primary, 0u);
    debug_log("cur_tpat_base:", to_hexstring(v));
    if (!is_node_reference(v)) {
      return pair(glm::uvec3(), 0u);
    }
    const param = decode_noderef_param(v);
    const p = param.coord;
    debug_log("cur_tpat_base:", p, param.scale);
    const scale = 2u << param.scale;
    const psc = p * scale;
    return pair(psc, param.scale + 1u);
  }
  private function uint get_cur_value(texture_value_index_e idx,
    size_t miplevel, size_t mutable& mlpat_r, size_t mutable mlmap_r) const
  {
    mlpat_r = miplevel;
    mlmap_r = miplevel;
    return ttev->get_cursor_tpat() ?
      get_cur_tpat(idx, mlpat_r) : get_cur_tmap(idx, mlmap_r);
  }
  private function void set_cur_value(texture_value_index_e idx, uint value)
  {
    if (ttev->get_cursor_tpat()) {
      set_cur_tpat(idx, value);
    } else {
      set_cur_tmap(idx, value);
    }
  }
  private function uint get_cur_tmap(texture_value_index_e idx,
    size_t miplevel) const
  {
    const mp = ttev->get_tmap_cursor_pos().first;
    return ttev->tmap_edit_get(mp, idx, miplevel);
  }
  private function void set_cur_tmap(texture_value_index_e idx, uint value)
  {
    // 範囲が大きいと超遅いので注意
    const m = ttev->get_tmap_cursor_pos();
    const mi = map{uvec3, min}(m.first, m.second);
    const mx = map{uvec3, max}(m.first, m.second);
    debug_log("set_cur_tmap", m);
    for (const z: mi.z .. mx.z + 1) {
      for (const y: mi.y .. mx.y + 1) {
        for (const x: mi.x .. mx.x + 1) {
          // debug_log("set_cur_tmap", x, y, z, value);
          ttev->tmap_edit_set(make_uvec3(x, y, z), idx, value);
        }
      }
    }
    debug_log("set_cur_tmap done", m);
  }
  private function uint get_cur_tpat(texture_value_index_e idx,
    size_t miplevel) const
  {
    return ttev->tpat_edit_get(get_cur_tpat_center(), idx, miplevel);
  }
  private function void set_cur_tpat(texture_value_index_e idx, uint value)
  {
    if (idx == texture_value_index_primary && is_node_reference(value)) {
      value = 0u;
    }
    return ttev->tpat_edit_set(get_cur_tpat_center(), idx, value);
  }
  private function uvec3 get_cur_tpat_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tpat_cursor_pos().first + ttev->get_tpat_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function uvec3 get_cur_tmap_center() const
  {
    return map{uvec3, operator::div}(
      ttev->get_tmap_cursor_pos().first + ttev->get_tmap_cursor_pos().second,
      make_uvec3(2, 2, 2));
  }
  private function bool is_cur_tmap_node_reference() const
  {
    return is_node_reference(get_cur_tmap(texture_value_index_primary, 0u));
  }
  private function uvec3 cur_tpat_index() const
  {
    return ttev->get_tpat_cursor_pos().first;
  }
  private function void procedural_gen(int proc, uvec3 sz, cslice{int} params)
  {
    sz = map{uvec3, max}(sz, make_uvec3(1u, 1u, 1u));
    debug_log("procedural_gen", proc, sz, params);
    const cpy_saved = copy_data;
    copy_data.copy_size = sz;
    copy_data.cursor_offset = sz - make_uvec3(1u, 1u, 1u);
    const p0 = params.size() > 0 ? params[0] : 0;
    const p = procedural_gen_spline(rndp, sz, p0);
    (*p)[0].swap(copy_data.tex[0]);
    (*p)[1].swap(copy_data.tex[1]);
    paste_value(0xff, merge_mode_opaque());
    copy_data = cpy_saved;
  }
  private function void gen_test()
  {
    // テスト中
    dbg_gen() {
      debug_log("gen_test");
    }
    const cur = ttev->get_cursor_range();
    const copy_size = cur.second;
    copy_value();
    const p = procedural_gen_spline(rndp, cur.second, gen_test_param);
    (*p)[0].swap(copy_data.tex[0]);
    (*p)[1].swap(copy_data.tex[1]);
    paste_value(0xff, merge_mode_opaque());
    copied = false;
  }
  private function void filling_erase()
  {
    debug_log("filling_erase");
    const c = ttev->get_cursor_pos();
    const succ = ttev->erase_filling(c.first);
    if (succ) {
      ttev->set_cursor_pos(c.first, c.second); // cursor fillingが解除される
    }
    debug_log("filling_erase", c.first, succ);
  }
  private function void filling_create(glm::vec3 mutable& cursor_move_r)
  {
    debug_log("filling_create");
    const cr = ttev->get_cursor_range();
    filling fi;
    fi.offset = cr.first;
    fi.sizes[1] = cr.second.x;
    fi.sizes[4] = cr.second.y;
    fi.sizes[7] = cr.second.z;
    const succ = ttev->set_filling(fi);
    if (succ) {
      debug_log("filling_create", cr.first, cr.second, succ);
      filling_set_cursor(fi, cursor_move_r);
    }
  }
  private function void filling_select(glm::vec3 mutable& cursor_move_r)
  {
    debug_log("filling_select");
    const fi = ttev->get_filling(ttev->get_cursor_pos().first);
    if (fi.size().x == 0) {
      debug_log("filling_select: not found");
      return;
    }
    filling_set_cursor(fi, cursor_move_r);
  }
  private function void filling_modify(int x, int y, int z)
  {
    const fi0 = ttev->get_filling(ttev->get_cursor_pos().first);
    if (fi0.size().x == 0) {
      debug_log("filling_modify: not found");
      return;
    }
    mutable fi = fi0;
    function void modify_dir(uint d, int v) {
      uint const o = d * 3;
      if (v < 0) {
        // 左側を大きくし、そのぶん中央を小さくする
        if (fi.sizes[o + 1] > 0) {
          fi.sizes[o + 1] -= 1;
          fi.sizes[o + 0] += 1;
        } else {
          fi.sizes[o + 1] = fi.sizes[o + 0];
          fi.sizes[o + 0] = 0;
        }
      } else if (v > 0) {
        // 右側を大きくし、そのぶん中央を小さくする
        if (fi.sizes[o + 1] > 0) {
          fi.sizes[o + 1] -= 1;
          fi.sizes[o + 2] += 1;
        } else {
          fi.sizes[o + 1] = fi.sizes[o + 2];
          fi.sizes[o + 2] = 0;
        }
      }
    }
    modify_dir(0, x);
    modify_dir(1, y);
    modify_dir(2, z);
    ttev->erase_filling(fi0.offset);
    ttev->set_filling(fi);
    ttev->set_cursor_filling(fi);
    debug_log("filling_modify", fi.sizes);
  }
  private function void filling_next(bool revert,
    glm::vec3 mutable& cursor_move_r)
  {
    const p = ttev->get_cursor_pos().first;
    const np = revert ? ttev->get_filling_prev(p) : ttev->get_filling_next(p);
    if (np == p) {
      debug_log("filling_next: not found");
      return;
    }
    const fi = ttev->get_filling(np);
    const d = to_ivec3(np) - to_ivec3(p);
    move_cursor(d.x, d.y, d.z, cursor_move_r);
    ttev->set_cursor_filling(fi);
  }
  private function void filling_set_cursor(filling const& fi,
    glm::vec3 mutable& cursor_move_r)
  {
    const p0 = to_ivec3(ttev->get_cursor_pos().first);
    const p1 = to_ivec3(fi.offset);
    const d = p1 - p0;
    move_cursor(d.x, d.y, d.z, cursor_move_r);
    ttev->set_cursor_filling(fi);
  }
}

// edit_mode.px
private enum edit_params_mode_t {
  edit_params_mode_none = 0,
  edit_params_mode_color = 1,
  edit_params_mode_plane = 2,
  edit_params_mode_sphere_1 = 3,
}

// edit_mode.px
private enum edit_fill_type_t {
  edit_fill_type_blank = 0,
  edit_fill_type_wall = 1,
  edit_fill_type_plane = 2,
  edit_fill_type_sphere = 3,
}

private function void
sync_gl_mipmap_all(edit_mode_texture mutable& emt)
{
  for (const i: 1 .. emt.vox.tpat_edit->data_pri.size()) {
    texture_data_sync_gl(emt.vox.tpat_edit->data_pri[i], si(i), uvec3(),
      emt.vox.tpat_edit->data_pri[i].get_size_uvec3(), emt.glt_voxtpat);
    texture_data_sync_gl(emt.vox.tpat_edit->data_sec[i], si(i), uvec3(),
      emt.vox.tpat_edit->data_sec[i].get_size_uvec3(), emt.glt_voxtpax);
  }
  for (const i: 1 .. emt.vox.tmap_edit->data_pri.size()) {
    texture_data_sync_gl(emt.vox.tmap_edit->data_pri[i], si(i), uvec3(),
      emt.vox.tmap_edit->data_pri[i].get_size_uvec3(), emt.glt_voxtmap);
    texture_data_sync_gl(emt.vox.tmap_edit->data_sec[i], si(i), uvec3(),
      emt.vox.tmap_edit->data_sec[i].get_size_uvec3(), emt.glt_voxtmax);
  }
}

