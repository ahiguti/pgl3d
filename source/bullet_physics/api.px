public namespace bullet_physics::api "export-unsafe";
public import core::common -;
public import core::container::raw -;
public import core::pointer::raw -;
public import core::meta m;
public import core::meta::vararg va;
public import bullet_physics::base -;
public pure struct extern "::btCollisionWorld::AllHitsRayResultCallback" "nodefault" btCollisionWorld_AllHitsRayResultCallback(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1)  {
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public btVector3 m_rayFromWorld;
  public btVector3 m_rayToWorld;
  public btScalar m_closestHitFraction;
  public crptr{btCollisionObject} m_collisionObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public uint m_flags;
}
public pure tsvaluetype struct extern "::btCollisionObject::AnisotropicFrictionFlags" "extenum" btCollisionObject_AnisotropicFrictionFlags { }
public extern "CF_ANISOTROPIC_FRICTION_DISABLED" btCollisionObject_AnisotropicFrictionFlags btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION_DISABLED;
public extern "CF_ANISOTROPIC_FRICTION" btCollisionObject_AnisotropicFrictionFlags btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_FRICTION;
public extern "CF_ANISOTROPIC_ROLLING_FRICTION" btCollisionObject_AnisotropicFrictionFlags btCollisionObject_AnisotropicFrictionFlags_CF_ANISOTROPIC_ROLLING_FRICTION;
public pure struct extern "::btConvexCast::CastResult" "nonmovable" btConvexCast_CastResult {
  public function extern "DebugDraw" void DebugDraw(btScalar fraction_0);
  public function extern "drawCoordSystem" void drawCoordSystem(btTransform const& trans_0);
  public function extern "reportFailure" void reportFailure(int errNo_0, int numIterations_1);
  public btTransform m_hitTransformA;
  public btTransform m_hitTransformB;
  public btVector3 m_normal;
  public btVector3 m_hitPoint;
  public btScalar m_fraction;
  public rptr{btIDebugDraw} m_debugDrawer;
  public btScalar m_allowedPenetration;
}
public pure struct extern "::btCollisionWorld::ClosestConvexResultCallback" "nodefault" btCollisionWorld_ClosestConvexResultCallback(btVector3 const& convexFromWorld_0, btVector3 const& convexToWorld_1)  {
  public metafunction __base__ {btCollisionWorld_ConvexResultCallback};
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public btVector3 m_convexFromWorld;
  public btVector3 m_convexToWorld;
  public btVector3 m_hitNormalWorld;
  public btVector3 m_hitPointWorld;
  public crptr{btCollisionObject} m_hitCollisionObject;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
}
public pure struct extern "::btDiscreteCollisionDetectorInterface::ClosestPointInput" btDiscreteCollisionDetectorInterface_ClosestPointInput {
  public btTransform m_transformA;
  public btTransform m_transformB;
  public btScalar m_maximumDistanceSquared;
}
public pure struct extern "::btCollisionWorld::ClosestRayResultCallback" "nodefault" btCollisionWorld_ClosestRayResultCallback(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1)  {
  public metafunction __base__ {btCollisionWorld_RayResultCallback};
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public btVector3 m_rayFromWorld;
  public btVector3 m_rayToWorld;
  public btVector3 m_hitNormalWorld;
  public btVector3 m_hitPointWorld;
  public btScalar m_closestHitFraction;
  public crptr{btCollisionObject} m_collisionObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public uint m_flags;
}
public pure tsvaluetype struct extern "::btBroadphaseProxy::CollisionFilterGroups" "extenum" btBroadphaseProxy_CollisionFilterGroups { }
public extern "DefaultFilter" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_DefaultFilter;
public extern "StaticFilter" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_StaticFilter;
public extern "KinematicFilter" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_KinematicFilter;
public extern "DebrisFilter" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_DebrisFilter;
public extern "SensorTrigger" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_SensorTrigger;
public extern "CharacterFilter" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_CharacterFilter;
public extern "AllFilter" btBroadphaseProxy_CollisionFilterGroups btBroadphaseProxy_CollisionFilterGroups_AllFilter;
public pure tsvaluetype struct extern "::btCollisionObject::CollisionFlags" "extenum" btCollisionObject_CollisionFlags { }
public extern "CF_STATIC_OBJECT" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_STATIC_OBJECT;
public extern "CF_KINEMATIC_OBJECT" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_KINEMATIC_OBJECT;
public extern "CF_NO_CONTACT_RESPONSE" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_NO_CONTACT_RESPONSE;
public extern "CF_CUSTOM_MATERIAL_CALLBACK" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_CUSTOM_MATERIAL_CALLBACK;
public extern "CF_CHARACTER_OBJECT" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_CHARACTER_OBJECT;
public extern "CF_DISABLE_VISUALIZE_OBJECT" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_DISABLE_VISUALIZE_OBJECT;
public extern "CF_DISABLE_SPU_COLLISION_PROCESSING" btCollisionObject_CollisionFlags btCollisionObject_CollisionFlags_CF_DISABLE_SPU_COLLISION_PROCESSING;
public pure tsvaluetype struct extern "::btCollisionObject::CollisionObjectTypes" "extenum" btCollisionObject_CollisionObjectTypes { }
public extern "CO_COLLISION_OBJECT" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_COLLISION_OBJECT;
public extern "CO_RIGID_BODY" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_RIGID_BODY;
public extern "CO_GHOST_OBJECT" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_GHOST_OBJECT;
public extern "CO_SOFT_BODY" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_SOFT_BODY;
public extern "CO_HF_FLUID" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_HF_FLUID;
public extern "CO_USER_TYPE" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_USER_TYPE;
public extern "CO_FEATHERSTONE_LINK" btCollisionObject_CollisionObjectTypes btCollisionObject_CollisionObjectTypes_CO_FEATHERSTONE_LINK;
public pure struct extern "::btCollisionWorld::ContactResultCallback" "nonmovable" btCollisionWorld_ContactResultCallback {
  public function extern "addSingleResult" btScalar addSingleResult(btManifoldPoint mutable& cp_0, crptr{btCollisionObjectWrapper} colObj0Wrap_1, int partId0_2, int index0_3, crptr{btCollisionObjectWrapper} colObj1Wrap_4, int partId1_5, int index1_6);
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
}
public pure struct extern "::btCollisionWorld::ConvexResultCallback" "nonmovable" btCollisionWorld_ConvexResultCallback {
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalConvexResult mutable& convexResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public btScalar m_closestHitFraction;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
}
public pure struct extern "::btBox2dBox2dCollisionAlgorithm::CreateFunc" "nonmovable" btBox2dBox2dCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btBoxBoxCollisionAlgorithm::CreateFunc" "nonmovable" btBoxBoxCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btCompoundCollisionAlgorithm::CreateFunc" "nonmovable" btCompoundCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btCompoundCompoundCollisionAlgorithm::CreateFunc" "nonmovable" btCompoundCompoundCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btConvex2dConvex2dAlgorithm::CreateFunc" "nodefault" btConvex2dConvex2dAlgorithm_CreateFunc(rptr{btVoronoiSimplexSolver} simplexSolver_0, rptr{btConvexPenetrationDepthSolver} pdSolver_1)  {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public rptr{btConvexPenetrationDepthSolver} m_pdSolver;
  public rptr{btVoronoiSimplexSolver} m_simplexSolver;
  public int m_numPerturbationIterations;
  public int m_minimumPointsPerturbationThreshold;
  public bool m_swapped;
}
public pure struct extern "::btConvexConcaveCollisionAlgorithm::CreateFunc" "nonmovable" btConvexConcaveCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btConvexPlaneCollisionAlgorithm::CreateFunc" "nonmovable" btConvexPlaneCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public int m_numPerturbationIterations;
  public int m_minimumPointsPerturbationThreshold;
  public bool m_swapped;
}
public pure struct extern "::btEmptyAlgorithm::CreateFunc" "nonmovable" btEmptyAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btSphereBoxCollisionAlgorithm::CreateFunc" "nonmovable" btSphereBoxCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btSphereSphereCollisionAlgorithm::CreateFunc" "nonmovable" btSphereSphereCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btSphereTriangleCollisionAlgorithm::CreateFunc" "nonmovable" btSphereTriangleCollisionAlgorithm_CreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure tsvaluetype struct extern "::btIDebugDraw::DebugDrawModes" "extenum" btIDebugDraw_DebugDrawModes { }
public extern "DBG_NoDebug" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_NoDebug;
public extern "DBG_DrawWireframe" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawWireframe;
public extern "DBG_DrawAabb" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawAabb;
public extern "DBG_DrawFeaturesText" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawFeaturesText;
public extern "DBG_DrawContactPoints" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawContactPoints;
public extern "DBG_NoDeactivation" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_NoDeactivation;
public extern "DBG_NoHelpText" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_NoHelpText;
public extern "DBG_DrawText" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawText;
public extern "DBG_ProfileTimings" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_ProfileTimings;
public extern "DBG_EnableSatComparison" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_EnableSatComparison;
public extern "DBG_DisableBulletLCP" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DisableBulletLCP;
public extern "DBG_EnableCCD" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_EnableCCD;
public extern "DBG_DrawConstraints" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawConstraints;
public extern "DBG_DrawConstraintLimits" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawConstraintLimits;
public extern "DBG_FastWireframe" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_FastWireframe;
public extern "DBG_DrawNormals" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawNormals;
public extern "DBG_DrawFrames" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_DrawFrames;
public extern "DBG_MAX_DEBUG_DRAW_MODE" btIDebugDraw_DebugDrawModes btIDebugDraw_DebugDrawModes_DBG_MAX_DEBUG_DRAW_MODE;
public pure tsvaluetype struct extern "::btDispatcherInfo::DispatchFunc" "extenum" btDispatcherInfo_DispatchFunc { }
public extern "DISPATCH_DISCRETE" btDispatcherInfo_DispatchFunc btDispatcherInfo_DispatchFunc_DISPATCH_DISCRETE;
public extern "DISPATCH_CONTINUOUS" btDispatcherInfo_DispatchFunc btDispatcherInfo_DispatchFunc_DISPATCH_CONTINUOUS;
public pure tsvaluetype struct extern "::btCollisionDispatcher::DispatcherFlags" "extenum" btCollisionDispatcher_DispatcherFlags { }
public extern "CD_STATIC_STATIC_REPORTED" btCollisionDispatcher_DispatcherFlags btCollisionDispatcher_DispatcherFlags_CD_STATIC_STATIC_REPORTED;
public extern "CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD" btCollisionDispatcher_DispatcherFlags btCollisionDispatcher_DispatcherFlags_CD_USE_RELATIVE_CONTACT_BREAKING_THRESHOLD;
public extern "CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION" btCollisionDispatcher_DispatcherFlags btCollisionDispatcher_DispatcherFlags_CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION;
public pure tsvaluetype struct extern "::btTriangleRaycastCallback::EFlags" "extenum" btTriangleRaycastCallback_EFlags { }
public extern "kF_None" btTriangleRaycastCallback_EFlags btTriangleRaycastCallback_EFlags_kF_None;
public extern "kF_FilterBackfaces" btTriangleRaycastCallback_EFlags btTriangleRaycastCallback_EFlags_kF_FilterBackfaces;
public extern "kF_KeepUnflippedNormal" btTriangleRaycastCallback_EFlags btTriangleRaycastCallback_EFlags_kF_KeepUnflippedNormal;
public extern "kF_UseSubSimplexConvexCastRaytest" btTriangleRaycastCallback_EFlags btTriangleRaycastCallback_EFlags_kF_UseSubSimplexConvexCastRaytest;
public extern "kF_UseGjkConvexCastRaytest" btTriangleRaycastCallback_EFlags btTriangleRaycastCallback_EFlags_kF_UseGjkConvexCastRaytest;
public extern "kF_Terminator" btTriangleRaycastCallback_EFlags btTriangleRaycastCallback_EFlags_kF_Terminator;
public pure struct extern "::btAxisSweep3Internal<unsigned short>::Edge" btAxisSweep3Internal_unsigned_short_Edge {
  public function extern "IsMax" ushort IsMax() const;
  public ushort m_pos;
  public ushort m_handle;
}
public pure struct extern "::btAxisSweep3Internal<unsigned int>::Edge" btAxisSweep3Internal_unsigned_int_Edge {
  public function extern "IsMax" uint IsMax() const;
  public uint m_pos;
  public uint m_handle;
}
public pure struct extern "::btConvexHullComputer::Edge" btConvexHullComputer_Edge {
  public function extern "getNextEdgeOfFace" crptr{btConvexHullComputer_Edge} getNextEdgeOfFace() const;
  public function extern "getNextEdgeOfVertex" crptr{btConvexHullComputer_Edge} getNextEdgeOfVertex() const;
  public function extern "getReverseEdge" crptr{btConvexHullComputer_Edge} getReverseEdge() const;
  public function extern "getSourceVertex" int getSourceVertex() const;
  public function extern "getTargetVertex" int getTargetVertex() const;
}
public pure struct extern "::btAxisSweep3Internal<unsigned short>::Handle" btAxisSweep3Internal_unsigned_short_Handle {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "GetNextFree" ushort GetNextFree() const;
  public function extern "SetNextFree" void SetNextFree(ushort next_0);
  public function extern "getUid" int getUid() const;
  public rawarray{ushort, 3} m_minEdges;
  public rawarray{ushort, 3} m_maxEdges;
  public rptr{btBroadphaseProxy} m_dbvtProxy;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
}
public pure struct extern "::btAxisSweep3Internal<unsigned int>::Handle" btAxisSweep3Internal_unsigned_int_Handle {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "GetNextFree" uint GetNextFree() const;
  public function extern "SetNextFree" void SetNextFree(uint next_0);
  public function extern "getUid" int getUid() const;
  public rawarray{uint, 3} m_minEdges;
  public rawarray{uint, 3} m_maxEdges;
  public rptr{btBroadphaseProxy} m_dbvtProxy;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
}
public pure struct extern "::btDbvt::IClone" "nonmovable" btDbvt_IClone {
  public function extern "CloneLeaf" void CloneLeaf(rptr{btDbvtNode} _0);
}
public pure struct extern "::btDbvt::ICollide" "nonmovable" btDbvt_ICollide {
  public function extern "AllLeaves" bool AllLeaves(crptr{btDbvtNode} _0);
  public function extern "Descent" bool Descent(crptr{btDbvtNode} _0);
  public function extern "Process" void Process1(crptr{btDbvtNode} _0);
  public function extern "Process" void Process_btDbvtNode_cp_btDbvtNode_cp(crptr{btDbvtNode} _0, crptr{btDbvtNode} _1);
  public function extern "Process" void Process_btDbvtNode_cp_btScalar(crptr{btDbvtNode} n_0, btScalar _1);
}
public pure struct extern "::btDbvt::IWriter" "nonmovable" btDbvt_IWriter {
  public function extern "Prepare" void Prepare(crptr{btDbvtNode} root_0, int numnodes_1);
  public function extern "WriteLeaf" void WriteLeaf(crptr{btDbvtNode} _0, int index_1, int parent_2);
  public function extern "WriteNode" void WriteNode(crptr{btDbvtNode} _0, int index_1, int parent_2, int child0_3, int child1_4);
}
public pure struct extern "::btSimulationIslandManager::IslandCallback" "nonmovable" btSimulationIslandManager_IslandCallback {
  public function extern "processIsland" void processIsland(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifolds_2, int numManifolds_3, int islandId_4);
}
public pure struct extern "::btCollisionWorld::LocalConvexResult" "nodefault" btCollisionWorld_LocalConvexResult(crptr{btCollisionObject} hitCollisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btVector3 const& hitPointLocal_3, btScalar hitFraction_4)  {
  public crptr{btCollisionObject} m_hitCollisionObject;
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btVector3 m_hitNormalLocal;
  public btVector3 m_hitPointLocal;
  public btScalar m_hitFraction;
}
public pure struct extern "::btCollisionWorld::LocalRayResult" "nodefault" btCollisionWorld_LocalRayResult(crptr{btCollisionObject} collisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btScalar hitFraction_3)  {
  public crptr{btCollisionObject} m_collisionObject;
  public rptr{btCollisionWorld_LocalShapeInfo} m_localShapeInfo;
  public btVector3 m_hitNormalLocal;
  public btScalar m_hitFraction;
}
public pure struct extern "::btCollisionWorld::LocalShapeInfo" btCollisionWorld_LocalShapeInfo {
  public int m_shapePart;
  public int m_triangleIndex;
}
public pure tsvaluetype struct extern "::PHY_ScalarType" "extenum" PHY_ScalarType { }
public extern "PHY_FLOAT" PHY_ScalarType PHY_ScalarType_PHY_FLOAT;
public extern "PHY_DOUBLE" PHY_ScalarType PHY_ScalarType_PHY_DOUBLE;
public extern "PHY_INTEGER" PHY_ScalarType PHY_ScalarType_PHY_INTEGER;
public extern "PHY_SHORT" PHY_ScalarType PHY_ScalarType_PHY_SHORT;
public extern "PHY_FIXEDPOINT88" PHY_ScalarType PHY_ScalarType_PHY_FIXEDPOINT88;
public extern "PHY_UCHAR" PHY_ScalarType PHY_ScalarType_PHY_UCHAR;
public pure struct extern "::btCollisionWorld::RayResultCallback" "nonmovable" btCollisionWorld_RayResultCallback {
  public function extern "addSingleResult" btScalar addSingleResult(btCollisionWorld_LocalRayResult mutable& rayResult_0, bool normalInWorldSpace_1);
  public function extern "hasHit" bool hasHit() const;
  public function extern "needsCollision" bool needsCollision(rptr{btBroadphaseProxy} proxy0_0) const;
  public btScalar m_closestHitFraction;
  public crptr{btCollisionObject} m_collisionObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public uint m_flags;
}
public pure struct extern "::btWheelInfo::RaycastInfo" btWheelInfo_RaycastInfo {
  public btVector3 m_contactNormalWS;
  public btVector3 m_contactPointWS;
  public btScalar m_suspensionLength;
  public btVector3 m_hardPointWS;
  public btVector3 m_wheelDirectionWS;
  public btVector3 m_wheelAxleWS;
  public bool m_isInContact;
  public rptr{void} m_groundObject;
}
public pure struct extern "::btDiscreteCollisionDetectorInterface::Result" "nonmovable" btDiscreteCollisionDetectorInterface_Result {
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
}
public pure struct extern "::btCompoundCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btCompoundCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btCompoundCompoundCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btCompoundCompoundCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btConvexConcaveCollisionAlgorithm::SwappedCreateFunc" "nonmovable" btConvexConcaveCollisionAlgorithm_SwappedCreateFunc {
  public metafunction __base__ {btCollisionAlgorithmCreateFunc};
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure tsvaluetype struct extern "::bt6DofFlags" "extenum" bt6DofFlags { }
public extern "BT_6DOF_FLAGS_CFM_NORM" bt6DofFlags bt6DofFlags_BT_6DOF_FLAGS_CFM_NORM;
public extern "BT_6DOF_FLAGS_CFM_STOP" bt6DofFlags bt6DofFlags_BT_6DOF_FLAGS_CFM_STOP;
public extern "BT_6DOF_FLAGS_ERP_STOP" bt6DofFlags bt6DofFlags_BT_6DOF_FLAGS_ERP_STOP;
public pure tsvaluetype struct extern "::bt6DofFlags2" "extenum" bt6DofFlags2 { }
public extern "BT_6DOF_FLAGS_CFM_STOP2" bt6DofFlags2 bt6DofFlags2_BT_6DOF_FLAGS_CFM_STOP2;
public extern "BT_6DOF_FLAGS_ERP_STOP2" bt6DofFlags2 bt6DofFlags2_BT_6DOF_FLAGS_ERP_STOP2;
public extern "BT_6DOF_FLAGS_CFM_MOTO2" bt6DofFlags2 bt6DofFlags2_BT_6DOF_FLAGS_CFM_MOTO2;
public extern "BT_6DOF_FLAGS_ERP_MOTO2" bt6DofFlags2 bt6DofFlags2_BT_6DOF_FLAGS_ERP_MOTO2;
public pure struct extern "::btActionInterface" "nonmovable" btActionInterface {
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTimeStep_1);
}
public pure struct extern "::btActivatingCollisionAlgorithm" "nodefault" btActivatingCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public metafunction btAlignedAllocFunc m::list{rptr{void}, size_t, int};
public pure struct extern "::btAlignedAllocator<GrahamVector3, 16>" btAlignedAllocator_GrahamVector3_16 {
}
public pure struct extern "::btAlignedAllocator<btActionInterface *, 16>" btAlignedAllocator_btActionInterface_p_16 {
  public function extern "address" btAlignedAllocator_btActionInterface_p_16_const_pointer address_btAlignedAllocator_btActionInterface_p_16_const_reference(btAlignedAllocator_btActionInterface_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btActionInterface_p_16_pointer address_btAlignedAllocator_btActionInterface_p_16_reference(btAlignedAllocator_btActionInterface_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btActionInterface_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btActionInterface_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btActionInterface_p_16_pointer ptr_0, btAlignedAllocator_btActionInterface_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btActionInterface_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btActionInterface_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btAlignedObjectArray<int>, 16>" btAlignedAllocator_btAlignedObjectArray_int_16 {
}
public pure struct extern "::btAlignedAllocator<btBroadphaseInterface *, 16>" btAlignedAllocator_btBroadphaseInterface_p_16 {
  public function extern "address" btAlignedAllocator_btBroadphaseInterface_p_16_const_pointer address_btAlignedAllocator_btBroadphaseInterface_p_16_const_reference(btAlignedAllocator_btBroadphaseInterface_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btBroadphaseInterface_p_16_pointer address_btAlignedAllocator_btBroadphaseInterface_p_16_reference(btAlignedAllocator_btBroadphaseInterface_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btBroadphaseInterface_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btBroadphaseInterface_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btBroadphaseInterface_p_16_pointer ptr_0, btAlignedAllocator_btBroadphaseInterface_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btBroadphaseInterface_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btBroadphaseInterface_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btBroadphasePair, 16>" btAlignedAllocator_btBroadphasePair_16 {
  public function extern "address" btAlignedAllocator_btBroadphasePair_16_const_pointer address_btAlignedAllocator_btBroadphasePair_16_const_reference(btAlignedAllocator_btBroadphasePair_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btBroadphasePair_16_pointer address_btAlignedAllocator_btBroadphasePair_16_reference(btAlignedAllocator_btBroadphasePair_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btBroadphasePair_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btBroadphasePair_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btBroadphasePair_16_pointer ptr_0, btAlignedAllocator_btBroadphasePair_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btBroadphasePair_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btBroadphasePair_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btBvhSubtreeInfo, 16>" btAlignedAllocator_btBvhSubtreeInfo_16 {
  public function extern "address" btAlignedAllocator_btBvhSubtreeInfo_16_const_pointer address_btAlignedAllocator_btBvhSubtreeInfo_16_const_reference(btAlignedAllocator_btBvhSubtreeInfo_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btBvhSubtreeInfo_16_pointer address_btAlignedAllocator_btBvhSubtreeInfo_16_reference(btAlignedAllocator_btBvhSubtreeInfo_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btBvhSubtreeInfo_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btBvhSubtreeInfo_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btBvhSubtreeInfo_16_pointer ptr_0, btAlignedAllocator_btBvhSubtreeInfo_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btBvhSubtreeInfo_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btBvhSubtreeInfo_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btChunk *, 16>" btAlignedAllocator_btChunk_p_16 {
  public function extern "address" btAlignedAllocator_btChunk_p_16_const_pointer address_btAlignedAllocator_btChunk_p_16_const_reference(btAlignedAllocator_btChunk_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btChunk_p_16_pointer address_btAlignedAllocator_btChunk_p_16_reference(btAlignedAllocator_btChunk_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btChunk_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btChunk_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btChunk_p_16_pointer ptr_0, btAlignedAllocator_btChunk_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btChunk_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btChunk_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCollisionAlgorithm *, 16>" btAlignedAllocator_btCollisionAlgorithm_p_16 {
  public function extern "address" btAlignedAllocator_btCollisionAlgorithm_p_16_const_pointer address_btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference(btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCollisionAlgorithm_p_16_pointer address_btAlignedAllocator_btCollisionAlgorithm_p_16_reference(btAlignedAllocator_btCollisionAlgorithm_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCollisionAlgorithm_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCollisionAlgorithm_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCollisionAlgorithm_p_16_pointer ptr_0, btAlignedAllocator_btCollisionAlgorithm_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCollisionAlgorithm_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCollisionAlgorithm_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCollisionObjectDoubleData *, 16>" btAlignedAllocator_btCollisionObjectDoubleData_p_16 {
  public function extern "address" btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_pointer address_btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference(btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCollisionObjectDoubleData_p_16_pointer address_btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference(btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCollisionObjectDoubleData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCollisionObjectDoubleData_p_16_pointer ptr_0, btAlignedAllocator_btCollisionObjectDoubleData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCollisionObjectDoubleData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCollisionObjectDoubleData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCollisionObjectFloatData *, 16>" btAlignedAllocator_btCollisionObjectFloatData_p_16 {
  public function extern "address" btAlignedAllocator_btCollisionObjectFloatData_p_16_const_pointer address_btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference(btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCollisionObjectFloatData_p_16_pointer address_btAlignedAllocator_btCollisionObjectFloatData_p_16_reference(btAlignedAllocator_btCollisionObjectFloatData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCollisionObjectFloatData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCollisionObjectFloatData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCollisionObjectFloatData_p_16_pointer ptr_0, btAlignedAllocator_btCollisionObjectFloatData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCollisionObjectFloatData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCollisionObjectFloatData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCollisionObject *, 16>" btAlignedAllocator_btCollisionObject_p_16 {
  public function extern "address" btAlignedAllocator_btCollisionObject_p_16_const_pointer address_btAlignedAllocator_btCollisionObject_p_16_const_reference(btAlignedAllocator_btCollisionObject_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCollisionObject_p_16_pointer address_btAlignedAllocator_btCollisionObject_p_16_reference(btAlignedAllocator_btCollisionObject_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCollisionObject_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCollisionObject_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCollisionObject_p_16_pointer ptr_0, btAlignedAllocator_btCollisionObject_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCollisionObject_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCollisionObject_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCollisionShapeData *, 16>" btAlignedAllocator_btCollisionShapeData_p_16 {
  public function extern "address" btAlignedAllocator_btCollisionShapeData_p_16_const_pointer address_btAlignedAllocator_btCollisionShapeData_p_16_const_reference(btAlignedAllocator_btCollisionShapeData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCollisionShapeData_p_16_pointer address_btAlignedAllocator_btCollisionShapeData_p_16_reference(btAlignedAllocator_btCollisionShapeData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCollisionShapeData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCollisionShapeData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCollisionShapeData_p_16_pointer ptr_0, btAlignedAllocator_btCollisionShapeData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCollisionShapeData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCollisionShapeData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCollisionShape *, 16>" btAlignedAllocator_btCollisionShape_p_16 {
  public function extern "address" btAlignedAllocator_btCollisionShape_p_16_const_pointer address_btAlignedAllocator_btCollisionShape_p_16_const_reference(btAlignedAllocator_btCollisionShape_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCollisionShape_p_16_pointer address_btAlignedAllocator_btCollisionShape_p_16_reference(btAlignedAllocator_btCollisionShape_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCollisionShape_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCollisionShape_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCollisionShape_p_16_pointer ptr_0, btAlignedAllocator_btCollisionShape_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCollisionShape_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCollisionShape_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btCompoundShapeChild, 16>" btAlignedAllocator_btCompoundShapeChild_16 {
  public function extern "address" btAlignedAllocator_btCompoundShapeChild_16_const_pointer address_btAlignedAllocator_btCompoundShapeChild_16_const_reference(btAlignedAllocator_btCompoundShapeChild_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btCompoundShapeChild_16_pointer address_btAlignedAllocator_btCompoundShapeChild_16_reference(btAlignedAllocator_btCompoundShapeChild_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btCompoundShapeChild_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btCompoundShapeChild_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btCompoundShapeChild_16_pointer ptr_0, btAlignedAllocator_btCompoundShapeChild_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btCompoundShapeChild_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btCompoundShapeChild_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btConvexHullComputer::Edge, 16>" btAlignedAllocator_btConvexHullComputer_Edge_16 {
  public function extern "address" btAlignedAllocator_btConvexHullComputer_Edge_16_const_pointer address_btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference(btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btConvexHullComputer_Edge_16_pointer address_btAlignedAllocator_btConvexHullComputer_Edge_16_reference(btAlignedAllocator_btConvexHullComputer_Edge_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btConvexHullComputer_Edge_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btConvexHullComputer_Edge_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btConvexHullComputer_Edge_16_pointer ptr_0, btAlignedAllocator_btConvexHullComputer_Edge_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btConvexHullComputer_Edge_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btConvexHullComputer_Edge_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btDbvt::sStkNN, 16>" btAlignedAllocator_btDbvt_sStkNN_16 {
  public function extern "address" btAlignedAllocator_btDbvt_sStkNN_16_const_pointer address_btAlignedAllocator_btDbvt_sStkNN_16_const_reference(btAlignedAllocator_btDbvt_sStkNN_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btDbvt_sStkNN_16_pointer address_btAlignedAllocator_btDbvt_sStkNN_16_reference(btAlignedAllocator_btDbvt_sStkNN_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btDbvt_sStkNN_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btDbvt_sStkNN_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btDbvt_sStkNN_16_pointer ptr_0, btAlignedAllocator_btDbvt_sStkNN_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btDbvt_sStkNN_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btDbvt_sStkNN_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btDbvt::sStkNPS, 16>" btAlignedAllocator_btDbvt_sStkNPS_16 {
  public function extern "address" btAlignedAllocator_btDbvt_sStkNPS_16_const_pointer address_btAlignedAllocator_btDbvt_sStkNPS_16_const_reference(btAlignedAllocator_btDbvt_sStkNPS_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btDbvt_sStkNPS_16_pointer address_btAlignedAllocator_btDbvt_sStkNPS_16_reference(btAlignedAllocator_btDbvt_sStkNPS_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btDbvt_sStkNPS_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btDbvt_sStkNPS_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btDbvt_sStkNPS_16_pointer ptr_0, btAlignedAllocator_btDbvt_sStkNPS_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btDbvt_sStkNPS_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btDbvt_sStkNPS_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btDbvt::sStkNP, 16>" btAlignedAllocator_btDbvt_sStkNP_16 {
  public function extern "address" btAlignedAllocator_btDbvt_sStkNP_16_const_pointer address_btAlignedAllocator_btDbvt_sStkNP_16_const_reference(btAlignedAllocator_btDbvt_sStkNP_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btDbvt_sStkNP_16_pointer address_btAlignedAllocator_btDbvt_sStkNP_16_reference(btAlignedAllocator_btDbvt_sStkNP_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btDbvt_sStkNP_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btDbvt_sStkNP_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btDbvt_sStkNP_16_pointer ptr_0, btAlignedAllocator_btDbvt_sStkNP_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btDbvt_sStkNP_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btDbvt_sStkNP_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btDynamicsWorldDoubleData *, 16>" btAlignedAllocator_btDynamicsWorldDoubleData_p_16 {
  public function extern "address" btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_pointer address_btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference(btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btDynamicsWorldDoubleData_p_16_pointer address_btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference(btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btDynamicsWorldDoubleData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btDynamicsWorldDoubleData_p_16_pointer ptr_0, btAlignedAllocator_btDynamicsWorldDoubleData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btDynamicsWorldDoubleData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btDynamicsWorldDoubleData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btDynamicsWorldFloatData *, 16>" btAlignedAllocator_btDynamicsWorldFloatData_p_16 {
  public function extern "address" btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_pointer address_btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference(btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btDynamicsWorldFloatData_p_16_pointer address_btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference(btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btDynamicsWorldFloatData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btDynamicsWorldFloatData_p_16_pointer ptr_0, btAlignedAllocator_btDynamicsWorldFloatData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btDynamicsWorldFloatData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btDynamicsWorldFloatData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btElement, 16>" btAlignedAllocator_btElement_16 {
  public function extern "address" btAlignedAllocator_btElement_16_const_pointer address_btAlignedAllocator_btElement_16_const_reference(btAlignedAllocator_btElement_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btElement_16_pointer address_btAlignedAllocator_btElement_16_reference(btAlignedAllocator_btElement_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btElement_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btElement_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btElement_16_pointer ptr_0, btAlignedAllocator_btElement_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btElement_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btElement_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btFace, 16>" btAlignedAllocator_btFace_16 {
  public function extern "address" btAlignedAllocator_btFace_16_const_pointer address_btAlignedAllocator_btFace_16_const_reference(btAlignedAllocator_btFace_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btFace_16_pointer address_btAlignedAllocator_btFace_16_reference(btAlignedAllocator_btFace_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btFace_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btFace_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btFace_16_pointer ptr_0, btAlignedAllocator_btFace_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btFace_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btFace_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btHashInt, 16>" btAlignedAllocator_btHashInt_16 {
  public function extern "address" btAlignedAllocator_btHashInt_16_const_pointer address_btAlignedAllocator_btHashInt_16_const_reference(btAlignedAllocator_btHashInt_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btHashInt_16_pointer address_btAlignedAllocator_btHashInt_16_reference(btAlignedAllocator_btHashInt_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btHashInt_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btHashInt_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btHashInt_16_pointer ptr_0, btAlignedAllocator_btHashInt_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btHashInt_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btHashInt_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btHashPtr, 16>" btAlignedAllocator_btHashPtr_16 {
  public function extern "address" btAlignedAllocator_btHashPtr_16_const_pointer address_btAlignedAllocator_btHashPtr_16_const_reference(btAlignedAllocator_btHashPtr_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btHashPtr_16_pointer address_btAlignedAllocator_btHashPtr_16_reference(btAlignedAllocator_btHashPtr_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btHashPtr_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btHashPtr_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btHashPtr_16_pointer ptr_0, btAlignedAllocator_btHashPtr_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btHashPtr_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btHashPtr_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btHashString, 16>" btAlignedAllocator_btHashString_16 {
  public function extern "address" btAlignedAllocator_btHashString_16_const_pointer address_btAlignedAllocator_btHashString_16_const_reference(btAlignedAllocator_btHashString_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btHashString_16_pointer address_btAlignedAllocator_btHashString_16_reference(btAlignedAllocator_btHashString_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btHashString_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btHashString_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btHashString_16_pointer ptr_0, btAlignedAllocator_btHashString_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btHashString_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btHashString_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btIndexedMesh, 16>" btAlignedAllocator_btIndexedMesh_16 {
  public function extern "address" btAlignedAllocator_btIndexedMesh_16_const_pointer address_btAlignedAllocator_btIndexedMesh_16_const_reference(btAlignedAllocator_btIndexedMesh_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btIndexedMesh_16_pointer address_btAlignedAllocator_btIndexedMesh_16_reference(btAlignedAllocator_btIndexedMesh_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btIndexedMesh_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btIndexedMesh_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btIndexedMesh_16_pointer ptr_0, btAlignedAllocator_btIndexedMesh_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btIndexedMesh_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btIndexedMesh_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btMaterialProperties, 16>" btAlignedAllocator_btMaterialProperties_16 {
  public function extern "address" btAlignedAllocator_btMaterialProperties_16_const_pointer address_btAlignedAllocator_btMaterialProperties_16_const_reference(btAlignedAllocator_btMaterialProperties_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btMaterialProperties_16_pointer address_btAlignedAllocator_btMaterialProperties_16_reference(btAlignedAllocator_btMaterialProperties_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btMaterialProperties_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btMaterialProperties_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btMaterialProperties_16_pointer ptr_0, btAlignedAllocator_btMaterialProperties_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btMaterialProperties_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btMaterialProperties_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btMaterial *, 16>" btAlignedAllocator_btMaterial_p_16 {
  public function extern "address" btAlignedAllocator_btMaterial_p_16_const_pointer address_btAlignedAllocator_btMaterial_p_16_const_reference(btAlignedAllocator_btMaterial_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btMaterial_p_16_pointer address_btAlignedAllocator_btMaterial_p_16_reference(btAlignedAllocator_btMaterial_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btMaterial_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btMaterial_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btMaterial_p_16_pointer ptr_0, btAlignedAllocator_btMaterial_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btMaterial_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btMaterial_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btMultiSapBroadphase::btBridgeProxy *, 16>" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16 {
  public function extern "address" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_pointer address_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference(btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_pointer address_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference(btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_pointer ptr_0, btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btMultiSapBroadphase::btMultiSapProxy *, 16>" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16 {
  public function extern "address" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_pointer address_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference(btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_pointer address_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference(btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_pointer ptr_0, btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btOptimizedBvhNode, 16>" btAlignedAllocator_btOptimizedBvhNode_16 {
  public function extern "address" btAlignedAllocator_btOptimizedBvhNode_16_const_pointer address_btAlignedAllocator_btOptimizedBvhNode_16_const_reference(btAlignedAllocator_btOptimizedBvhNode_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btOptimizedBvhNode_16_pointer address_btAlignedAllocator_btOptimizedBvhNode_16_reference(btAlignedAllocator_btOptimizedBvhNode_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btOptimizedBvhNode_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btOptimizedBvhNode_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btOptimizedBvhNode_16_pointer ptr_0, btAlignedAllocator_btOptimizedBvhNode_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btOptimizedBvhNode_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btOptimizedBvhNode_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btOptimizedBvh *, 16>" btAlignedAllocator_btOptimizedBvh_p_16 {
  public function extern "address" btAlignedAllocator_btOptimizedBvh_p_16_const_pointer address_btAlignedAllocator_btOptimizedBvh_p_16_const_reference(btAlignedAllocator_btOptimizedBvh_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btOptimizedBvh_p_16_pointer address_btAlignedAllocator_btOptimizedBvh_p_16_reference(btAlignedAllocator_btOptimizedBvh_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btOptimizedBvh_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btOptimizedBvh_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btOptimizedBvh_p_16_pointer ptr_0, btAlignedAllocator_btOptimizedBvh_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btOptimizedBvh_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btOptimizedBvh_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btPersistentManifold *, 16>" btAlignedAllocator_btPersistentManifold_p_16 {
  public function extern "address" btAlignedAllocator_btPersistentManifold_p_16_const_pointer address_btAlignedAllocator_btPersistentManifold_p_16_const_reference(btAlignedAllocator_btPersistentManifold_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btPersistentManifold_p_16_pointer address_btAlignedAllocator_btPersistentManifold_p_16_reference(btAlignedAllocator_btPersistentManifold_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btPersistentManifold_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btPersistentManifold_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btPersistentManifold_p_16_pointer ptr_0, btAlignedAllocator_btPersistentManifold_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btPersistentManifold_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btPersistentManifold_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btPointerUid, 16>" btAlignedAllocator_btPointerUid_16 {
  public function extern "address" btAlignedAllocator_btPointerUid_16_const_pointer address_btAlignedAllocator_btPointerUid_16_const_reference(btAlignedAllocator_btPointerUid_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btPointerUid_16_pointer address_btAlignedAllocator_btPointerUid_16_reference(btAlignedAllocator_btPointerUid_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btPointerUid_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btPointerUid_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btPointerUid_16_pointer ptr_0, btAlignedAllocator_btPointerUid_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btPointerUid_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btPointerUid_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btQuantizedBvhDoubleData *, 16>" btAlignedAllocator_btQuantizedBvhDoubleData_p_16 {
  public function extern "address" btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_pointer address_btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference(btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btQuantizedBvhDoubleData_p_16_pointer address_btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference(btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btQuantizedBvhDoubleData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btQuantizedBvhDoubleData_p_16_pointer ptr_0, btAlignedAllocator_btQuantizedBvhDoubleData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btQuantizedBvhDoubleData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btQuantizedBvhDoubleData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btQuantizedBvhFloatData *, 16>" btAlignedAllocator_btQuantizedBvhFloatData_p_16 {
  public function extern "address" btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_pointer address_btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference(btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btQuantizedBvhFloatData_p_16_pointer address_btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference(btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btQuantizedBvhFloatData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btQuantizedBvhFloatData_p_16_pointer ptr_0, btAlignedAllocator_btQuantizedBvhFloatData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btQuantizedBvhFloatData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btQuantizedBvhFloatData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btQuantizedBvhNode, 16>" btAlignedAllocator_btQuantizedBvhNode_16 {
  public function extern "address" btAlignedAllocator_btQuantizedBvhNode_16_const_pointer address_btAlignedAllocator_btQuantizedBvhNode_16_const_reference(btAlignedAllocator_btQuantizedBvhNode_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btQuantizedBvhNode_16_pointer address_btAlignedAllocator_btQuantizedBvhNode_16_reference(btAlignedAllocator_btQuantizedBvhNode_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btQuantizedBvhNode_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btQuantizedBvhNode_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btQuantizedBvhNode_16_pointer ptr_0, btAlignedAllocator_btQuantizedBvhNode_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btQuantizedBvhNode_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btQuantizedBvhNode_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btRigidBodyDoubleData *, 16>" btAlignedAllocator_btRigidBodyDoubleData_p_16 {
  public function extern "address" btAlignedAllocator_btRigidBodyDoubleData_p_16_const_pointer address_btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference(btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btRigidBodyDoubleData_p_16_pointer address_btAlignedAllocator_btRigidBodyDoubleData_p_16_reference(btAlignedAllocator_btRigidBodyDoubleData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btRigidBodyDoubleData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btRigidBodyDoubleData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btRigidBodyDoubleData_p_16_pointer ptr_0, btAlignedAllocator_btRigidBodyDoubleData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btRigidBodyDoubleData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btRigidBodyDoubleData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btRigidBodyFloatData *, 16>" btAlignedAllocator_btRigidBodyFloatData_p_16 {
  public function extern "address" btAlignedAllocator_btRigidBodyFloatData_p_16_const_pointer address_btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference(btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btRigidBodyFloatData_p_16_pointer address_btAlignedAllocator_btRigidBodyFloatData_p_16_reference(btAlignedAllocator_btRigidBodyFloatData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btRigidBodyFloatData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btRigidBodyFloatData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btRigidBodyFloatData_p_16_pointer ptr_0, btAlignedAllocator_btRigidBodyFloatData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btRigidBodyFloatData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btRigidBodyFloatData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btRigidBody *, 16>" btAlignedAllocator_btRigidBody_p_16 {
  public function extern "address" btAlignedAllocator_btRigidBody_p_16_const_pointer address_btAlignedAllocator_btRigidBody_p_16_const_reference(btAlignedAllocator_btRigidBody_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btRigidBody_p_16_pointer address_btAlignedAllocator_btRigidBody_p_16_reference(btAlignedAllocator_btRigidBody_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btRigidBody_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btRigidBody_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btRigidBody_p_16_pointer ptr_0, btAlignedAllocator_btRigidBody_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btRigidBody_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btRigidBody_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btSimplePair, 16>" btAlignedAllocator_btSimplePair_16 {
  public function extern "address" btAlignedAllocator_btSimplePair_16_const_pointer address_btAlignedAllocator_btSimplePair_16_const_reference(btAlignedAllocator_btSimplePair_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btSimplePair_16_pointer address_btAlignedAllocator_btSimplePair_16_reference(btAlignedAllocator_btSimplePair_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btSimplePair_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btSimplePair_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btSimplePair_16_pointer ptr_0, btAlignedAllocator_btSimplePair_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btSimplePair_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btSimplePair_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btSoftBodyDoubleData *, 16>" btAlignedAllocator_btSoftBodyDoubleData_p_16 {
}
public pure struct extern "::btAlignedAllocator<btSoftBodyFloatData *, 16>" btAlignedAllocator_btSoftBodyFloatData_p_16 {
}
public pure struct extern "::btAlignedAllocator<btSolverBody, 16>" btAlignedAllocator_btSolverBody_16 {
  public function extern "address" btAlignedAllocator_btSolverBody_16_const_pointer address_btAlignedAllocator_btSolverBody_16_const_reference(btAlignedAllocator_btSolverBody_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btSolverBody_16_pointer address_btAlignedAllocator_btSolverBody_16_reference(btAlignedAllocator_btSolverBody_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btSolverBody_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btSolverBody_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btSolverBody_16_pointer ptr_0, btAlignedAllocator_btSolverBody_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btSolverBody_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btSolverBody_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btSolverConstraint, 16>" btAlignedAllocator_btSolverConstraint_16 {
  public function extern "address" btAlignedAllocator_btSolverConstraint_16_const_pointer address_btAlignedAllocator_btSolverConstraint_16_const_reference(btAlignedAllocator_btSolverConstraint_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btSolverConstraint_16_pointer address_btAlignedAllocator_btSolverConstraint_16_reference(btAlignedAllocator_btSolverConstraint_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btSolverConstraint_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btSolverConstraint_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btSolverConstraint_16_pointer ptr_0, btAlignedAllocator_btSolverConstraint_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btSolverConstraint_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btSolverConstraint_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btStridingMeshInterfaceData *, 16>" btAlignedAllocator_btStridingMeshInterfaceData_p_16 {
  public function extern "address" btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_pointer address_btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference(btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btStridingMeshInterfaceData_p_16_pointer address_btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference(btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btStridingMeshInterfaceData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btStridingMeshInterfaceData_p_16_pointer ptr_0, btAlignedAllocator_btStridingMeshInterfaceData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btStridingMeshInterfaceData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btStridingMeshInterfaceData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTriangleIndexVertexArray *, 16>" btAlignedAllocator_btTriangleIndexVertexArray_p_16 {
  public function extern "address" btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_pointer address_btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference(btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTriangleIndexVertexArray_p_16_pointer address_btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference(btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTriangleIndexVertexArray_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTriangleIndexVertexArray_p_16_pointer ptr_0, btAlignedAllocator_btTriangleIndexVertexArray_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTriangleIndexVertexArray_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTriangleIndexVertexArray_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTriangleInfoMap *, 16>" btAlignedAllocator_btTriangleInfoMap_p_16 {
}
public pure struct extern "::btAlignedAllocator<btTriangleInfo, 16>" btAlignedAllocator_btTriangleInfo_16 {
  public function extern "address" btAlignedAllocator_btTriangleInfo_16_const_pointer address_btAlignedAllocator_btTriangleInfo_16_const_reference(btAlignedAllocator_btTriangleInfo_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTriangleInfo_16_pointer address_btAlignedAllocator_btTriangleInfo_16_reference(btAlignedAllocator_btTriangleInfo_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTriangleInfo_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTriangleInfo_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTriangleInfo_16_pointer ptr_0, btAlignedAllocator_btTriangleInfo_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTriangleInfo_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTriangleInfo_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTriangle, 16>" btAlignedAllocator_btTriangle_16 {
  public function extern "address" btAlignedAllocator_btTriangle_16_const_pointer address_btAlignedAllocator_btTriangle_16_const_reference(btAlignedAllocator_btTriangle_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTriangle_16_pointer address_btAlignedAllocator_btTriangle_16_reference(btAlignedAllocator_btTriangle_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTriangle_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTriangle_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTriangle_16_pointer ptr_0, btAlignedAllocator_btTriangle_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTriangle_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTriangle_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTypedConstraintData *, 16>" btAlignedAllocator_btTypedConstraintData_p_16 {
  public function extern "address" btAlignedAllocator_btTypedConstraintData_p_16_const_pointer address_btAlignedAllocator_btTypedConstraintData_p_16_const_reference(btAlignedAllocator_btTypedConstraintData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTypedConstraintData_p_16_pointer address_btAlignedAllocator_btTypedConstraintData_p_16_reference(btAlignedAllocator_btTypedConstraintData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTypedConstraintData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTypedConstraintData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTypedConstraintData_p_16_pointer ptr_0, btAlignedAllocator_btTypedConstraintData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTypedConstraintData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTypedConstraintData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTypedConstraintDoubleData *, 16>" btAlignedAllocator_btTypedConstraintDoubleData_p_16 {
  public function extern "address" btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_pointer address_btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference(btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTypedConstraintDoubleData_p_16_pointer address_btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference(btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTypedConstraintDoubleData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTypedConstraintDoubleData_p_16_pointer ptr_0, btAlignedAllocator_btTypedConstraintDoubleData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTypedConstraintDoubleData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTypedConstraintDoubleData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTypedConstraintFloatData *, 16>" btAlignedAllocator_btTypedConstraintFloatData_p_16 {
  public function extern "address" btAlignedAllocator_btTypedConstraintFloatData_p_16_const_pointer address_btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference(btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTypedConstraintFloatData_p_16_pointer address_btAlignedAllocator_btTypedConstraintFloatData_p_16_reference(btAlignedAllocator_btTypedConstraintFloatData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTypedConstraintFloatData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTypedConstraintFloatData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTypedConstraintFloatData_p_16_pointer ptr_0, btAlignedAllocator_btTypedConstraintFloatData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTypedConstraintFloatData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTypedConstraintFloatData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTypedConstraint::btConstraintInfo1, 16>" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16 {
  public function extern "address" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_pointer address_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference(btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_pointer address_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference(btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_pointer ptr_0, btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btTypedConstraint *, 16>" btAlignedAllocator_btTypedConstraint_p_16 {
  public function extern "address" btAlignedAllocator_btTypedConstraint_p_16_const_pointer address_btAlignedAllocator_btTypedConstraint_p_16_const_reference(btAlignedAllocator_btTypedConstraint_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btTypedConstraint_p_16_pointer address_btAlignedAllocator_btTypedConstraint_p_16_reference(btAlignedAllocator_btTypedConstraint_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btTypedConstraint_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btTypedConstraint_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btTypedConstraint_p_16_pointer ptr_0, btAlignedAllocator_btTypedConstraint_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btTypedConstraint_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btTypedConstraint_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btVector3DoubleData *, 16>" btAlignedAllocator_btVector3DoubleData_p_16 {
  public function extern "address" btAlignedAllocator_btVector3DoubleData_p_16_const_pointer address_btAlignedAllocator_btVector3DoubleData_p_16_const_reference(btAlignedAllocator_btVector3DoubleData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btVector3DoubleData_p_16_pointer address_btAlignedAllocator_btVector3DoubleData_p_16_reference(btAlignedAllocator_btVector3DoubleData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btVector3DoubleData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btVector3DoubleData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btVector3DoubleData_p_16_pointer ptr_0, btAlignedAllocator_btVector3DoubleData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btVector3DoubleData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btVector3DoubleData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btVector3FloatData *, 16>" btAlignedAllocator_btVector3FloatData_p_16 {
  public function extern "address" btAlignedAllocator_btVector3FloatData_p_16_const_pointer address_btAlignedAllocator_btVector3FloatData_p_16_const_reference(btAlignedAllocator_btVector3FloatData_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btVector3FloatData_p_16_pointer address_btAlignedAllocator_btVector3FloatData_p_16_reference(btAlignedAllocator_btVector3FloatData_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btVector3FloatData_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btVector3FloatData_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btVector3FloatData_p_16_pointer ptr_0, btAlignedAllocator_btVector3FloatData_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btVector3FloatData_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btVector3FloatData_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btVector3, 16>" btAlignedAllocator_btVector3_16 {
  public function extern "address" btAlignedAllocator_btVector3_16_const_pointer address_btAlignedAllocator_btVector3_16_const_reference(btAlignedAllocator_btVector3_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btVector3_16_pointer address_btAlignedAllocator_btVector3_16_reference(btAlignedAllocator_btVector3_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btVector3_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btVector3_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btVector3_16_pointer ptr_0, btAlignedAllocator_btVector3_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btVector3_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btVector3_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<btWheelInfo, 16>" btAlignedAllocator_btWheelInfo_16 {
  public function extern "address" btAlignedAllocator_btWheelInfo_16_const_pointer address_btAlignedAllocator_btWheelInfo_16_const_reference(btAlignedAllocator_btWheelInfo_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_btWheelInfo_16_pointer address_btAlignedAllocator_btWheelInfo_16_reference(btAlignedAllocator_btWheelInfo_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_btWheelInfo_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_btWheelInfo_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_btWheelInfo_16_pointer ptr_0, btAlignedAllocator_btWheelInfo_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_btWheelInfo_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_btWheelInfo_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<char *, 16>" btAlignedAllocator_char_p_16 {
  public function extern "address" btAlignedAllocator_char_p_16_const_pointer address_btAlignedAllocator_char_p_16_const_reference(btAlignedAllocator_char_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_char_p_16_pointer address_btAlignedAllocator_char_p_16_reference(btAlignedAllocator_char_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_char_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_char_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_char_p_16_pointer ptr_0, btAlignedAllocator_char_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_char_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_char_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<const btCollisionObject *, 16>" btAlignedAllocator_const_btCollisionObject_p_16 {
  public function extern "address" btAlignedAllocator_const_btCollisionObject_p_16_const_pointer address_btAlignedAllocator_const_btCollisionObject_p_16_const_reference(btAlignedAllocator_const_btCollisionObject_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_const_btCollisionObject_p_16_pointer address_btAlignedAllocator_const_btCollisionObject_p_16_reference(btAlignedAllocator_const_btCollisionObject_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_const_btCollisionObject_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_const_btCollisionObject_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_const_btCollisionObject_p_16_pointer ptr_0, btAlignedAllocator_const_btCollisionObject_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_const_btCollisionObject_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_const_btCollisionObject_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<const btDbvtNode *, 16>" btAlignedAllocator_const_btDbvtNode_p_16 {
  public function extern "address" btAlignedAllocator_const_btDbvtNode_p_16_const_pointer address_btAlignedAllocator_const_btDbvtNode_p_16_const_reference(btAlignedAllocator_const_btDbvtNode_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_const_btDbvtNode_p_16_pointer address_btAlignedAllocator_const_btDbvtNode_p_16_reference(btAlignedAllocator_const_btDbvtNode_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_const_btDbvtNode_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_const_btDbvtNode_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_const_btDbvtNode_p_16_pointer ptr_0, btAlignedAllocator_const_btDbvtNode_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_const_btDbvtNode_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_const_btDbvtNode_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<const char *, 16>" btAlignedAllocator_const_char_p_16 {
  public function extern "address" btAlignedAllocator_const_char_p_16_const_pointer address_btAlignedAllocator_const_char_p_16_const_reference(btAlignedAllocator_const_char_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_const_char_p_16_pointer address_btAlignedAllocator_const_char_p_16_reference(btAlignedAllocator_const_char_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_const_char_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_const_char_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_const_char_p_16_pointer ptr_0, btAlignedAllocator_const_char_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_const_char_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_const_char_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<double, 16>" btAlignedAllocator_double_16 {
  public function extern "address" btAlignedAllocator_double_16_const_pointer address_btAlignedAllocator_double_16_const_reference(btAlignedAllocator_double_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_double_16_pointer address_btAlignedAllocator_double_16_reference(btAlignedAllocator_double_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_double_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_double_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_double_16_pointer ptr_0, btAlignedAllocator_double_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_double_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_double_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<float, 16>" btAlignedAllocator_float_16 {
  public function extern "address" btAlignedAllocator_float_16_const_pointer address_btAlignedAllocator_float_16_const_reference(btAlignedAllocator_float_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_float_16_pointer address_btAlignedAllocator_float_16_reference(btAlignedAllocator_float_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_float_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_float_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_float_16_pointer ptr_0, btAlignedAllocator_float_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_float_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_float_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<int, 16>" btAlignedAllocator_int_16 {
  public function extern "address" btAlignedAllocator_int_16_const_pointer address_btAlignedAllocator_int_16_const_reference(btAlignedAllocator_int_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_int_16_pointer address_btAlignedAllocator_int_16_reference(btAlignedAllocator_int_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_int_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_int_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_int_16_pointer ptr_0, btAlignedAllocator_int_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_int_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_int_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<int *, 16>" btAlignedAllocator_int_p_16 {
  public function extern "address" btAlignedAllocator_int_p_16_const_pointer address_btAlignedAllocator_int_p_16_const_reference(btAlignedAllocator_int_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_int_p_16_pointer address_btAlignedAllocator_int_p_16_reference(btAlignedAllocator_int_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_int_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_int_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_int_p_16_pointer ptr_0, btAlignedAllocator_int_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_int_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_int_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<short, 16>" btAlignedAllocator_short_16 {
  public function extern "address" btAlignedAllocator_short_16_const_pointer address_btAlignedAllocator_short_16_const_reference(btAlignedAllocator_short_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_short_16_pointer address_btAlignedAllocator_short_16_reference(btAlignedAllocator_short_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_short_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_short_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_short_16_pointer ptr_0, btAlignedAllocator_short_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_short_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_short_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<short *, 16>" btAlignedAllocator_short_p_16 {
  public function extern "address" btAlignedAllocator_short_p_16_const_pointer address_btAlignedAllocator_short_p_16_const_reference(btAlignedAllocator_short_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_short_p_16_pointer address_btAlignedAllocator_short_p_16_reference(btAlignedAllocator_short_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_short_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_short_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_short_p_16_pointer ptr_0, btAlignedAllocator_short_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_short_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_short_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<unsigned char *, 16>" btAlignedAllocator_unsigned_char_p_16 {
  public function extern "address" btAlignedAllocator_unsigned_char_p_16_const_pointer address_btAlignedAllocator_unsigned_char_p_16_const_reference(btAlignedAllocator_unsigned_char_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_unsigned_char_p_16_pointer address_btAlignedAllocator_unsigned_char_p_16_reference(btAlignedAllocator_unsigned_char_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_unsigned_char_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_unsigned_char_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_unsigned_char_p_16_pointer ptr_0, btAlignedAllocator_unsigned_char_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_unsigned_char_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_unsigned_char_p_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<unsigned int, 16>" btAlignedAllocator_unsigned_int_16 {
  public function extern "address" btAlignedAllocator_unsigned_int_16_const_pointer address_btAlignedAllocator_unsigned_int_16_const_reference(btAlignedAllocator_unsigned_int_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_unsigned_int_16_pointer address_btAlignedAllocator_unsigned_int_16_reference(btAlignedAllocator_unsigned_int_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_unsigned_int_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_unsigned_int_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_unsigned_int_16_pointer ptr_0, btAlignedAllocator_unsigned_int_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_unsigned_int_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_unsigned_int_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<unsigned short, 16>" btAlignedAllocator_unsigned_short_16 {
  public function extern "address" btAlignedAllocator_unsigned_short_16_const_pointer address_btAlignedAllocator_unsigned_short_16_const_reference(btAlignedAllocator_unsigned_short_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_unsigned_short_16_pointer address_btAlignedAllocator_unsigned_short_16_reference(btAlignedAllocator_unsigned_short_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_unsigned_short_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_unsigned_short_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_unsigned_short_16_pointer ptr_0, btAlignedAllocator_unsigned_short_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_unsigned_short_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_unsigned_short_16_pointer ptr_0);
}
public pure struct extern "::btAlignedAllocator<void *, 16>" btAlignedAllocator_void_p_16 {
  public function extern "address" btAlignedAllocator_void_p_16_const_pointer address_btAlignedAllocator_void_p_16_const_reference(btAlignedAllocator_void_p_16_const_reference ref_0) const;
  public function extern "address" btAlignedAllocator_void_p_16_pointer address_btAlignedAllocator_void_p_16_reference(btAlignedAllocator_void_p_16_reference ref_0) const;
  public function extern "allocate" btAlignedAllocator_void_p_16_pointer allocate(size_type n_0, rptr{btAlignedAllocator_void_p_16_const_pointer} hint_1);
  public function extern "construct" void construct(btAlignedAllocator_void_p_16_pointer ptr_0, btAlignedAllocator_void_p_16_value_type const& value_1);
  public function extern "deallocate" void deallocate(btAlignedAllocator_void_p_16_pointer ptr_0);
  public function extern "destroy" void destroy(btAlignedAllocator_void_p_16_pointer ptr_0);
}
public metafunction btAlignedFreeFunc m::list{void, rptr{void}};
public pure struct extern "::btAlignedObjectArray<GrahamVector3>" btAlignedObjectArray_GrahamVector3 {
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "quickSortInternal" void quickSortInternal(btAngleCompareFunc const& CompareFunc_0, int lo_1, int hi_2);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btActionInterface *>" btAlignedObjectArray_btActionInterface_p {
  public function extern "at" rptr{btActionInterface} mutable& at(int n_0);
  public function extern "at" rptr{btActionInterface} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btActionInterface} mutable& expandNonInitializing();
  public function extern "expand" rptr{btActionInterface} mutable& expand_(rptr{btActionInterface} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btActionInterface} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btActionInterface} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btActionInterface} const& _Val_0);
  public function extern "remove" void remove(rptr{btActionInterface} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btActionInterface} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btAlignedObjectArray<int>>" btAlignedObjectArray_btAlignedObjectArray_int {
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btBroadphaseInterface *>" btAlignedObjectArray_btBroadphaseInterface_p {
  public function extern "at" rptr{btBroadphaseInterface} mutable& at(int n_0);
  public function extern "at" rptr{btBroadphaseInterface} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btBroadphaseInterface} mutable& expandNonInitializing();
  public function extern "expand" rptr{btBroadphaseInterface} mutable& expand_(rptr{btBroadphaseInterface} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btBroadphaseInterface} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btBroadphaseInterface} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btBroadphaseInterface} const& _Val_0);
  public function extern "remove" void remove(rptr{btBroadphaseInterface} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btBroadphaseInterface} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btBroadphasePair>" btAlignedObjectArray_btBroadphasePair {
  public function extern "at" btBroadphasePair mutable& at(int n_0);
  public function extern "at" btBroadphasePair const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btBroadphasePair mutable& expandNonInitializing();
  public function extern "expand" btBroadphasePair mutable& expand_(btBroadphasePair const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btBroadphasePair const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btBroadphasePair const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btBroadphasePair const& _Val_0);
  public function extern "quickSort" void quickSort(btBroadphasePairSortPredicate const& CompareFunc_0);
  public function extern "quickSortInternal" void quickSortInternal(btBroadphasePairSortPredicate const& CompareFunc_0, int lo_1, int hi_2);
  public function extern "remove" void remove(btBroadphasePair const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btBroadphasePair const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>" btAlignedObjectArray_btBvhSubtreeInfo {
  public function extern "at" btBvhSubtreeInfo mutable& at(int n_0);
  public function extern "at" btBvhSubtreeInfo const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btBvhSubtreeInfo mutable& expandNonInitializing();
  public function extern "expand" btBvhSubtreeInfo mutable& expand_(btBvhSubtreeInfo const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btBvhSubtreeInfo const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btBvhSubtreeInfo const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btBvhSubtreeInfo const& _Val_0);
  public function extern "remove" void remove(btBvhSubtreeInfo const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btBvhSubtreeInfo const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btChunk *>" btAlignedObjectArray_btChunk_p {
  public function extern "at" rptr{btChunk} mutable& at(int n_0);
  public function extern "at" rptr{btChunk} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btChunk} mutable& expandNonInitializing();
  public function extern "expand" rptr{btChunk} mutable& expand_(rptr{btChunk} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btChunk} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btChunk} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btChunk} const& _Val_0);
  public function extern "remove" void remove(rptr{btChunk} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btChunk} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCollisionAlgorithm *>" btAlignedObjectArray_btCollisionAlgorithm_p {
  public function extern "at" rptr{btCollisionAlgorithm} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionAlgorithm} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btCollisionAlgorithm} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionAlgorithm} mutable& expand_(rptr{btCollisionAlgorithm} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionAlgorithm} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionAlgorithm} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btCollisionAlgorithm} const& _Val_0);
  public function extern "remove" void remove(rptr{btCollisionAlgorithm} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionAlgorithm} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCollisionObjectDoubleData *>" btAlignedObjectArray_btCollisionObjectDoubleData_p {
  public function extern "at" rptr{btCollisionObjectDoubleData} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionObjectDoubleData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btCollisionObjectDoubleData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionObjectDoubleData} mutable& expand_(rptr{btCollisionObjectDoubleData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionObjectDoubleData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionObjectDoubleData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btCollisionObjectDoubleData} const& _Val_0);
  public function extern "remove" void remove(rptr{btCollisionObjectDoubleData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionObjectDoubleData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCollisionObjectFloatData *>" btAlignedObjectArray_btCollisionObjectFloatData_p {
  public function extern "at" rptr{btCollisionObjectFloatData} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionObjectFloatData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btCollisionObjectFloatData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionObjectFloatData} mutable& expand_(rptr{btCollisionObjectFloatData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionObjectFloatData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionObjectFloatData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btCollisionObjectFloatData} const& _Val_0);
  public function extern "remove" void remove(rptr{btCollisionObjectFloatData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionObjectFloatData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCollisionObject *>" btAlignedObjectArray_btCollisionObject_p {
  public function extern "at" rptr{btCollisionObject} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionObject} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionObject} mutable& expand_(rptr{btCollisionObject} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionObject} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionObject} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btCollisionObject} const& _Val_0);
  public function extern "remove" void remove(rptr{btCollisionObject} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionObject} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCollisionShapeData *>" btAlignedObjectArray_btCollisionShapeData_p {
  public function extern "at" rptr{btCollisionShapeData} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionShapeData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btCollisionShapeData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionShapeData} mutable& expand_(rptr{btCollisionShapeData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionShapeData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionShapeData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btCollisionShapeData} const& _Val_0);
  public function extern "remove" void remove(rptr{btCollisionShapeData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionShapeData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCollisionShape *>" btAlignedObjectArray_btCollisionShape_p {
  public function extern "at" rptr{btCollisionShape} mutable& at(int n_0);
  public function extern "at" rptr{btCollisionShape} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btCollisionShape} mutable& expandNonInitializing();
  public function extern "expand" rptr{btCollisionShape} mutable& expand_(rptr{btCollisionShape} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btCollisionShape} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btCollisionShape} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btCollisionShape} const& _Val_0);
  public function extern "remove" void remove(rptr{btCollisionShape} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btCollisionShape} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btCompoundShapeChild>" btAlignedObjectArray_btCompoundShapeChild {
  public function extern "at" btCompoundShapeChild mutable& at(int n_0);
  public function extern "at" btCompoundShapeChild const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btCompoundShapeChild mutable& expandNonInitializing();
  public function extern "expand" btCompoundShapeChild mutable& expand_(btCompoundShapeChild const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btCompoundShapeChild const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btCompoundShapeChild const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btCompoundShapeChild const& _Val_0);
  public function extern "remove" void remove(btCompoundShapeChild const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btCompoundShapeChild const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btConvexHullComputer::Edge>" btAlignedObjectArray_btConvexHullComputer_Edge {
  public function extern "at" btConvexHullComputer_Edge mutable& at(int n_0);
  public function extern "at" btConvexHullComputer_Edge const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btConvexHullComputer_Edge mutable& expandNonInitializing();
  public function extern "expand" btConvexHullComputer_Edge mutable& expand_(btConvexHullComputer_Edge const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btConvexHullComputer_Edge const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btConvexHullComputer_Edge const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btConvexHullComputer_Edge const& _Val_0);
  public function extern "remove" void remove(btConvexHullComputer_Edge const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btConvexHullComputer_Edge const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btDbvtProxy *>" "nodefault" btAlignedObjectArray_btDbvtProxy_p private {
}
public pure struct extern "::btAlignedObjectArray<btDbvt::sStkNN>" btAlignedObjectArray_btDbvt_sStkNN {
  public function extern "at" btDbvt_sStkNN mutable& at(int n_0);
  public function extern "at" btDbvt_sStkNN const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btDbvt_sStkNN mutable& expandNonInitializing();
  public function extern "expand" btDbvt_sStkNN mutable& expand_(btDbvt_sStkNN const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNN const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNN const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btDbvt_sStkNN const& _Val_0);
  public function extern "remove" void remove(btDbvt_sStkNN const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btDbvt_sStkNN const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btDbvt::sStkNP>" btAlignedObjectArray_btDbvt_sStkNP {
  public function extern "at" btDbvt_sStkNP mutable& at(int n_0);
  public function extern "at" btDbvt_sStkNP const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btDbvt_sStkNP mutable& expandNonInitializing();
  public function extern "expand" btDbvt_sStkNP mutable& expand_(btDbvt_sStkNP const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNP const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNP const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btDbvt_sStkNP const& _Val_0);
  public function extern "remove" void remove(btDbvt_sStkNP const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btDbvt_sStkNP const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>" btAlignedObjectArray_btDbvt_sStkNPS {
  public function extern "at" btDbvt_sStkNPS mutable& at(int n_0);
  public function extern "at" btDbvt_sStkNPS const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btDbvt_sStkNPS mutable& expandNonInitializing();
  public function extern "expand" btDbvt_sStkNPS mutable& expand_(btDbvt_sStkNPS const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btDbvt_sStkNPS const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btDbvt_sStkNPS const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btDbvt_sStkNPS const& _Val_0);
  public function extern "remove" void remove(btDbvt_sStkNPS const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btDbvt_sStkNPS const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btDynamicsWorldDoubleData *>" btAlignedObjectArray_btDynamicsWorldDoubleData_p {
  public function extern "at" rptr{btDynamicsWorldDoubleData} mutable& at(int n_0);
  public function extern "at" rptr{btDynamicsWorldDoubleData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btDynamicsWorldDoubleData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btDynamicsWorldDoubleData} mutable& expand_(rptr{btDynamicsWorldDoubleData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btDynamicsWorldDoubleData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btDynamicsWorldDoubleData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btDynamicsWorldDoubleData} const& _Val_0);
  public function extern "remove" void remove(rptr{btDynamicsWorldDoubleData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btDynamicsWorldDoubleData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btDynamicsWorldFloatData *>" btAlignedObjectArray_btDynamicsWorldFloatData_p {
  public function extern "at" rptr{btDynamicsWorldFloatData} mutable& at(int n_0);
  public function extern "at" rptr{btDynamicsWorldFloatData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btDynamicsWorldFloatData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btDynamicsWorldFloatData} mutable& expand_(rptr{btDynamicsWorldFloatData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btDynamicsWorldFloatData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btDynamicsWorldFloatData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btDynamicsWorldFloatData} const& _Val_0);
  public function extern "remove" void remove(rptr{btDynamicsWorldFloatData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btDynamicsWorldFloatData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btElement>" btAlignedObjectArray_btElement {
  public function extern "at" btElement mutable& at(int n_0);
  public function extern "at" btElement const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btElement mutable& expandNonInitializing();
  public function extern "expand" btElement mutable& expand_(btElement const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btElement const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btElement const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btElement const& _Val_0);
  public function extern "remove" void remove(btElement const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btElement const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btFace>" btAlignedObjectArray_btFace {
  public function extern "at" btFace mutable& at(int n_0);
  public function extern "at" btFace const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btFace mutable& expandNonInitializing();
  public function extern "expand" btFace mutable& expand_(btFace const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btFace const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btFace const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btFace const& _Val_0);
  public function extern "remove" void remove(btFace const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btFace const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btHashInt>" btAlignedObjectArray_btHashInt {
  public function extern "at" btHashInt mutable& at(int n_0);
  public function extern "at" btHashInt const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btHashInt mutable& expandNonInitializing();
  public function extern "expand" btHashInt mutable& expand_(btHashInt const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btHashInt const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btHashInt const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btHashInt const& _Val_0);
  public function extern "remove" void remove(btHashInt const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btHashInt const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btHashPtr>" btAlignedObjectArray_btHashPtr {
  public function extern "at" btHashPtr mutable& at(int n_0);
  public function extern "at" btHashPtr const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btHashPtr mutable& expandNonInitializing();
  public function extern "expand" btHashPtr mutable& expand_(btHashPtr const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btHashPtr const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btHashPtr const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btHashPtr const& _Val_0);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btHashPtr const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btHashString>" btAlignedObjectArray_btHashString {
  public function extern "at" btHashString mutable& at(int n_0);
  public function extern "at" btHashString const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btHashString mutable& expandNonInitializing();
  public function extern "expand" btHashString mutable& expand_(btHashString const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btHashString const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btHashString const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btHashString const& _Val_0);
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btHashString const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btIndexedMesh>" btAlignedObjectArray_btIndexedMesh {
  public function extern "at" btIndexedMesh mutable& at(int n_0);
  public function extern "at" btIndexedMesh const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btIndexedMesh mutable& expandNonInitializing();
  public function extern "expand" btIndexedMesh mutable& expand_(btIndexedMesh const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btIndexedMesh const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btIndexedMesh const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btIndexedMesh const& _Val_0);
  public function extern "remove" void remove(btIndexedMesh const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btIndexedMesh const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btMaterialProperties>" btAlignedObjectArray_btMaterialProperties {
  public function extern "at" btMaterialProperties mutable& at(int n_0);
  public function extern "at" btMaterialProperties const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btMaterialProperties mutable& expandNonInitializing();
  public function extern "expand" btMaterialProperties mutable& expand_(btMaterialProperties const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btMaterialProperties const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btMaterialProperties const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btMaterialProperties const& _Val_0);
  public function extern "remove" void remove(btMaterialProperties const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btMaterialProperties const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btMaterial *>" btAlignedObjectArray_btMaterial_p {
  public function extern "at" rptr{btMaterial} mutable& at(int n_0);
  public function extern "at" rptr{btMaterial} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btMaterial} mutable& expandNonInitializing();
  public function extern "expand" rptr{btMaterial} mutable& expand_(rptr{btMaterial} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMaterial} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMaterial} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btMaterial} const& _Val_0);
  public function extern "remove" void remove(rptr{btMaterial} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btMaterial} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy *>" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p {
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& at(int n_0);
  public function extern "at" rptr{btMultiSapBroadphase_btBridgeProxy} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expandNonInitializing();
  public function extern "expand" rptr{btMultiSapBroadphase_btBridgeProxy} mutable& expand_(rptr{btMultiSapBroadphase_btBridgeProxy} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btBridgeProxy} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btBridgeProxy} const& _Val_0);
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btBridgeProxy} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btMultiSapBroadphase_btBridgeProxy} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy *>" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p {
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& at(int n_0);
  public function extern "at" rptr{btMultiSapBroadphase_btMultiSapProxy} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expandNonInitializing();
  public function extern "expand" rptr{btMultiSapBroadphase_btMultiSapProxy} mutable& expand_(rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btMultiSapBroadphase_btMultiSapProxy} const& _Val_0);
  public function extern "remove" void remove(rptr{btMultiSapBroadphase_btMultiSapProxy} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btMultiSapBroadphase_btMultiSapProxy} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btOptimizedBvhNode>" btAlignedObjectArray_btOptimizedBvhNode {
  public function extern "at" btOptimizedBvhNode mutable& at(int n_0);
  public function extern "at" btOptimizedBvhNode const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btOptimizedBvhNode mutable& expandNonInitializing();
  public function extern "expand" btOptimizedBvhNode mutable& expand_(btOptimizedBvhNode const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btOptimizedBvhNode const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btOptimizedBvhNode const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btOptimizedBvhNode const& _Val_0);
  public function extern "remove" void remove(btOptimizedBvhNode const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btOptimizedBvhNode const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btOptimizedBvh *>" btAlignedObjectArray_btOptimizedBvh_p {
  public function extern "at" rptr{btOptimizedBvh} mutable& at(int n_0);
  public function extern "at" rptr{btOptimizedBvh} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btOptimizedBvh} mutable& expandNonInitializing();
  public function extern "expand" rptr{btOptimizedBvh} mutable& expand_(rptr{btOptimizedBvh} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btOptimizedBvh} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btOptimizedBvh} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btOptimizedBvh} const& _Val_0);
  public function extern "remove" void remove(rptr{btOptimizedBvh} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btOptimizedBvh} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btPersistentManifold *>" btAlignedObjectArray_btPersistentManifold_p {
  public function extern "at" rptr{btPersistentManifold} mutable& at(int n_0);
  public function extern "at" rptr{btPersistentManifold} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btPersistentManifold} mutable& expandNonInitializing();
  public function extern "expand" rptr{btPersistentManifold} mutable& expand_(rptr{btPersistentManifold} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btPersistentManifold} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btPersistentManifold} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btPersistentManifold} const& _Val_0);
  public function extern "remove" void remove(rptr{btPersistentManifold} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btPersistentManifold} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btPointerUid>" btAlignedObjectArray_btPointerUid {
  public function extern "at" btPointerUid mutable& at(int n_0);
  public function extern "at" btPointerUid const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btPointerUid mutable& expandNonInitializing();
  public function extern "expand" btPointerUid mutable& expand_(btPointerUid const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btPointerUid const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btPointerUid const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btPointerUid const& _Val_0);
  public function extern "remove" void remove(btPointerUid const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btPointerUid const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btQuantizedBvhDoubleData *>" btAlignedObjectArray_btQuantizedBvhDoubleData_p {
  public function extern "at" rptr{btQuantizedBvhDoubleData} mutable& at(int n_0);
  public function extern "at" rptr{btQuantizedBvhDoubleData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btQuantizedBvhDoubleData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btQuantizedBvhDoubleData} mutable& expand_(rptr{btQuantizedBvhDoubleData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btQuantizedBvhDoubleData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btQuantizedBvhDoubleData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btQuantizedBvhDoubleData} const& _Val_0);
  public function extern "remove" void remove(rptr{btQuantizedBvhDoubleData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btQuantizedBvhDoubleData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btQuantizedBvhFloatData *>" btAlignedObjectArray_btQuantizedBvhFloatData_p {
  public function extern "at" rptr{btQuantizedBvhFloatData} mutable& at(int n_0);
  public function extern "at" rptr{btQuantizedBvhFloatData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btQuantizedBvhFloatData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btQuantizedBvhFloatData} mutable& expand_(rptr{btQuantizedBvhFloatData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btQuantizedBvhFloatData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btQuantizedBvhFloatData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btQuantizedBvhFloatData} const& _Val_0);
  public function extern "remove" void remove(rptr{btQuantizedBvhFloatData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btQuantizedBvhFloatData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btQuantizedBvhNode>" btAlignedObjectArray_btQuantizedBvhNode {
  public function extern "at" btQuantizedBvhNode mutable& at(int n_0);
  public function extern "at" btQuantizedBvhNode const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btQuantizedBvhNode mutable& expandNonInitializing();
  public function extern "expand" btQuantizedBvhNode mutable& expand_(btQuantizedBvhNode const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btQuantizedBvhNode const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btQuantizedBvhNode const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btQuantizedBvhNode const& _Val_0);
  public function extern "remove" void remove(btQuantizedBvhNode const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btQuantizedBvhNode const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btRigidBodyDoubleData *>" btAlignedObjectArray_btRigidBodyDoubleData_p {
  public function extern "at" rptr{btRigidBodyDoubleData} mutable& at(int n_0);
  public function extern "at" rptr{btRigidBodyDoubleData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btRigidBodyDoubleData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btRigidBodyDoubleData} mutable& expand_(rptr{btRigidBodyDoubleData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btRigidBodyDoubleData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btRigidBodyDoubleData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btRigidBodyDoubleData} const& _Val_0);
  public function extern "remove" void remove(rptr{btRigidBodyDoubleData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btRigidBodyDoubleData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btRigidBodyFloatData *>" btAlignedObjectArray_btRigidBodyFloatData_p {
  public function extern "at" rptr{btRigidBodyFloatData} mutable& at(int n_0);
  public function extern "at" rptr{btRigidBodyFloatData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btRigidBodyFloatData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btRigidBodyFloatData} mutable& expand_(rptr{btRigidBodyFloatData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btRigidBodyFloatData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btRigidBodyFloatData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btRigidBodyFloatData} const& _Val_0);
  public function extern "remove" void remove(rptr{btRigidBodyFloatData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btRigidBodyFloatData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btRigidBody *>" btAlignedObjectArray_btRigidBody_p {
  public function extern "at" rptr{btRigidBody} mutable& at(int n_0);
  public function extern "at" rptr{btRigidBody} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btRigidBody} mutable& expandNonInitializing();
  public function extern "expand" rptr{btRigidBody} mutable& expand_(rptr{btRigidBody} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btRigidBody} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btRigidBody} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btRigidBody} const& _Val_0);
  public function extern "remove" void remove(rptr{btRigidBody} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btRigidBody} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btSimplePair>" btAlignedObjectArray_btSimplePair {
  public function extern "at" btSimplePair mutable& at(int n_0);
  public function extern "at" btSimplePair const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btSimplePair mutable& expandNonInitializing();
  public function extern "expand" btSimplePair mutable& expand_(btSimplePair const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btSimplePair const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btSimplePair const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btSimplePair const& _Val_0);
  public function extern "remove" void remove(btSimplePair const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btSimplePair const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btSoftBodyDoubleData *>" btAlignedObjectArray_btSoftBodyDoubleData_p {
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btSoftBodyFloatData *>" btAlignedObjectArray_btSoftBodyFloatData_p {
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btSolverBody>" btAlignedObjectArray_btSolverBody {
  public function extern "at" btSolverBody mutable& at(int n_0);
  public function extern "at" btSolverBody const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btSolverBody mutable& expandNonInitializing();
  public function extern "expand" btSolverBody mutable& expand_(btSolverBody const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btSolverBody const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btSolverBody const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btSolverBody const& _Val_0);
  public function extern "remove" void remove(btSolverBody const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btSolverBody const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btSolverConstraint>" btAlignedObjectArray_btSolverConstraint {
  public function extern "at" btSolverConstraint mutable& at(int n_0);
  public function extern "at" btSolverConstraint const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btSolverConstraint mutable& expandNonInitializing();
  public function extern "expand" btSolverConstraint mutable& expand_(btSolverConstraint const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btSolverConstraint const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btSolverConstraint const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btSolverConstraint const& _Val_0);
  public function extern "remove" void remove(btSolverConstraint const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btSolverConstraint const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btStridingMeshInterfaceData *>" btAlignedObjectArray_btStridingMeshInterfaceData_p {
  public function extern "at" rptr{btStridingMeshInterfaceData} mutable& at(int n_0);
  public function extern "at" rptr{btStridingMeshInterfaceData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btStridingMeshInterfaceData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btStridingMeshInterfaceData} mutable& expand_(rptr{btStridingMeshInterfaceData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btStridingMeshInterfaceData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btStridingMeshInterfaceData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btStridingMeshInterfaceData} const& _Val_0);
  public function extern "remove" void remove(rptr{btStridingMeshInterfaceData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btStridingMeshInterfaceData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTriangle>" btAlignedObjectArray_btTriangle {
  public function extern "at" btTriangle mutable& at(int n_0);
  public function extern "at" btTriangle const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btTriangle mutable& expandNonInitializing();
  public function extern "expand" btTriangle mutable& expand_(btTriangle const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btTriangle const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btTriangle const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btTriangle const& _Val_0);
  public function extern "remove" void remove(btTriangle const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btTriangle const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTriangleIndexVertexArray *>" btAlignedObjectArray_btTriangleIndexVertexArray_p {
  public function extern "at" rptr{btTriangleIndexVertexArray} mutable& at(int n_0);
  public function extern "at" rptr{btTriangleIndexVertexArray} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btTriangleIndexVertexArray} mutable& expandNonInitializing();
  public function extern "expand" rptr{btTriangleIndexVertexArray} mutable& expand_(rptr{btTriangleIndexVertexArray} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTriangleIndexVertexArray} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTriangleIndexVertexArray} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btTriangleIndexVertexArray} const& _Val_0);
  public function extern "remove" void remove(rptr{btTriangleIndexVertexArray} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btTriangleIndexVertexArray} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTriangleInfo>" btAlignedObjectArray_btTriangleInfo {
  public function extern "at" btTriangleInfo mutable& at(int n_0);
  public function extern "at" btTriangleInfo const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btTriangleInfo mutable& expandNonInitializing();
  public function extern "expand" btTriangleInfo mutable& expand_(btTriangleInfo const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btTriangleInfo const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btTriangleInfo const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btTriangleInfo const& _Val_0);
  public function extern "remove" void remove(btTriangleInfo const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btTriangleInfo const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTriangleInfoMap *>" btAlignedObjectArray_btTriangleInfoMap_p {
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraintData *>" btAlignedObjectArray_btTypedConstraintData_p {
  public function extern "at" rptr{btTypedConstraintData} mutable& at(int n_0);
  public function extern "at" rptr{btTypedConstraintData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btTypedConstraintData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btTypedConstraintData} mutable& expand_(rptr{btTypedConstraintData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraintData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraintData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btTypedConstraintData} const& _Val_0);
  public function extern "remove" void remove(rptr{btTypedConstraintData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btTypedConstraintData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraintDoubleData *>" btAlignedObjectArray_btTypedConstraintDoubleData_p {
  public function extern "at" rptr{btTypedConstraintDoubleData} mutable& at(int n_0);
  public function extern "at" rptr{btTypedConstraintDoubleData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btTypedConstraintDoubleData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btTypedConstraintDoubleData} mutable& expand_(rptr{btTypedConstraintDoubleData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraintDoubleData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraintDoubleData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btTypedConstraintDoubleData} const& _Val_0);
  public function extern "remove" void remove(rptr{btTypedConstraintDoubleData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btTypedConstraintDoubleData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraintFloatData *>" btAlignedObjectArray_btTypedConstraintFloatData_p {
  public function extern "at" rptr{btTypedConstraintFloatData} mutable& at(int n_0);
  public function extern "at" rptr{btTypedConstraintFloatData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btTypedConstraintFloatData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btTypedConstraintFloatData} mutable& expand_(rptr{btTypedConstraintFloatData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraintFloatData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraintFloatData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btTypedConstraintFloatData} const& _Val_0);
  public function extern "remove" void remove(rptr{btTypedConstraintFloatData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btTypedConstraintFloatData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1 {
  public function extern "at" btTypedConstraint_btConstraintInfo1 mutable& at(int n_0);
  public function extern "at" btTypedConstraint_btConstraintInfo1 const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btTypedConstraint_btConstraintInfo1 mutable& expandNonInitializing();
  public function extern "expand" btTypedConstraint_btConstraintInfo1 mutable& expand_(btTypedConstraint_btConstraintInfo1 const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btTypedConstraint_btConstraintInfo1 const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btTypedConstraint_btConstraintInfo1 const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btTypedConstraint_btConstraintInfo1 const& _Val_0);
  public function extern "remove" void remove(btTypedConstraint_btConstraintInfo1 const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btTypedConstraint_btConstraintInfo1 const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraint *>" btAlignedObjectArray_btTypedConstraint_p {
  public function extern "at" rptr{btTypedConstraint} mutable& at(int n_0);
  public function extern "at" rptr{btTypedConstraint} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btTypedConstraint} mutable& expandNonInitializing();
  public function extern "expand" rptr{btTypedConstraint} mutable& expand_(rptr{btTypedConstraint} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btTypedConstraint} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btTypedConstraint} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btTypedConstraint} const& _Val_0);
  public function extern "remove" void remove(rptr{btTypedConstraint} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btTypedConstraint} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btVector3>" btAlignedObjectArray_btVector3 {
  public function extern "at" btVector3 mutable& at(int n_0);
  public function extern "at" btVector3 const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btVector3 mutable& expandNonInitializing();
  public function extern "expand" btVector3 mutable& expand_(btVector3 const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btVector3 const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btVector3 const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btVector3 const& _Val_0);
  public function extern "remove" void remove(btVector3 const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btVector3 const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btVector3DoubleData *>" btAlignedObjectArray_btVector3DoubleData_p {
  public function extern "at" rptr{btVector3DoubleData} mutable& at(int n_0);
  public function extern "at" rptr{btVector3DoubleData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btVector3DoubleData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btVector3DoubleData} mutable& expand_(rptr{btVector3DoubleData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btVector3DoubleData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btVector3DoubleData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btVector3DoubleData} const& _Val_0);
  public function extern "remove" void remove(rptr{btVector3DoubleData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btVector3DoubleData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btVector3FloatData *>" btAlignedObjectArray_btVector3FloatData_p {
  public function extern "at" rptr{btVector3FloatData} mutable& at(int n_0);
  public function extern "at" rptr{btVector3FloatData} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{btVector3FloatData} mutable& expandNonInitializing();
  public function extern "expand" rptr{btVector3FloatData} mutable& expand_(rptr{btVector3FloatData} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{btVector3FloatData} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{btVector3FloatData} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{btVector3FloatData} const& _Val_0);
  public function extern "remove" void remove(rptr{btVector3FloatData} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{btVector3FloatData} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<btWheelInfo>" btAlignedObjectArray_btWheelInfo {
  public function extern "at" btWheelInfo mutable& at(int n_0);
  public function extern "at" btWheelInfo const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" btWheelInfo mutable& expandNonInitializing();
  public function extern "expand" btWheelInfo mutable& expand_(btWheelInfo const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(btWheelInfo const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(btWheelInfo const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(btWheelInfo const& _Val_0);
  public function extern "remove" void remove(btWheelInfo const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, btWheelInfo const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<char *>" btAlignedObjectArray_char_p {
  public function extern "at" rptr{char} mutable& at(int n_0);
  public function extern "at" rptr{char} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{char} mutable& expandNonInitializing();
  public function extern "expand" rptr{char} mutable& expand_(rptr{char} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{char} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{char} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{char} const& _Val_0);
  public function extern "remove" void remove(rptr{char} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{char} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<const btCollisionObject *>" btAlignedObjectArray_const_btCollisionObject_p {
  public function extern "at" crptr{btCollisionObject} mutable& at(int n_0);
  public function extern "at" crptr{btCollisionObject} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" crptr{btCollisionObject} mutable& expandNonInitializing();
  public function extern "expand" crptr{btCollisionObject} mutable& expand_(crptr{btCollisionObject} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btCollisionObject} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{btCollisionObject} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(crptr{btCollisionObject} const& _Val_0);
  public function extern "remove" void remove(crptr{btCollisionObject} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, crptr{btCollisionObject} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<const btDbvtNode *>" btAlignedObjectArray_const_btDbvtNode_p {
  public function extern "at" crptr{btDbvtNode} mutable& at(int n_0);
  public function extern "at" crptr{btDbvtNode} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" crptr{btDbvtNode} mutable& expandNonInitializing();
  public function extern "expand" crptr{btDbvtNode} mutable& expand_(crptr{btDbvtNode} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(crptr{btDbvtNode} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{btDbvtNode} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(crptr{btDbvtNode} const& _Val_0);
  public function extern "remove" void remove(crptr{btDbvtNode} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, crptr{btDbvtNode} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<const char *>" btAlignedObjectArray_const_char_p {
  public function extern "at" crptr{char} mutable& at(int n_0);
  public function extern "at" crptr{char} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" crptr{char} mutable& expandNonInitializing();
  public function extern "expand" crptr{char} mutable& expand_(crptr{char} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(crptr{char} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(crptr{char} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(crptr{char} const& _Val_0);
  public function extern "remove" void remove(crptr{char} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, crptr{char} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<double>" btAlignedObjectArray_double {
  public function extern "at" double mutable& at(int n_0);
  public function extern "at" double const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" double mutable& expandNonInitializing();
  public function extern "expand" double mutable& expand_(double const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(double const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(double const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(double const& _Val_0);
  public function extern "remove" void remove(double const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, double const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<float>" btAlignedObjectArray_float {
  public function extern "at" float mutable& at(int n_0);
  public function extern "at" float const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" float mutable& expandNonInitializing();
  public function extern "expand" float mutable& expand_(float const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(float const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(float const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(float const& _Val_0);
  public function extern "remove" void remove(float const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, float const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<int>" btAlignedObjectArray_int {
  public function extern "at" int mutable& at(int n_0);
  public function extern "at" int const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" int mutable& expandNonInitializing();
  public function extern "expand" int mutable& expand_(int const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(int const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(int const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(int const& _Val_0);
  public function extern "remove" void remove(int const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, int const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<int *>" btAlignedObjectArray_int_p {
  public function extern "at" rptr{int} mutable& at(int n_0);
  public function extern "at" rptr{int} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{int} mutable& expandNonInitializing();
  public function extern "expand" rptr{int} mutable& expand_(rptr{int} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{int} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{int} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{int} const& _Val_0);
  public function extern "remove" void remove(rptr{int} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{int} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<short>" btAlignedObjectArray_short {
  public function extern "at" short mutable& at(int n_0);
  public function extern "at" short const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" short mutable& expandNonInitializing();
  public function extern "expand" short mutable& expand_(short const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(short const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(short const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(short const& _Val_0);
  public function extern "remove" void remove(short const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, short const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<short *>" btAlignedObjectArray_short_p {
  public function extern "at" rptr{short} mutable& at(int n_0);
  public function extern "at" rptr{short} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{short} mutable& expandNonInitializing();
  public function extern "expand" rptr{short} mutable& expand_(rptr{short} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{short} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{short} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{short} const& _Val_0);
  public function extern "remove" void remove(rptr{short} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{short} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<unsigned char *>" btAlignedObjectArray_unsigned_char_p {
  public function extern "at" rptr{uchar} mutable& at(int n_0);
  public function extern "at" rptr{uchar} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{uchar} mutable& expandNonInitializing();
  public function extern "expand" rptr{uchar} mutable& expand_(rptr{uchar} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{uchar} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{uchar} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{uchar} const& _Val_0);
  public function extern "remove" void remove(rptr{uchar} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{uchar} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<unsigned int>" btAlignedObjectArray_unsigned_int {
  public function extern "at" uint mutable& at(int n_0);
  public function extern "at" uint const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" uint mutable& expandNonInitializing();
  public function extern "expand" uint mutable& expand_(uint const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(uint const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(uint const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(uint const& _Val_0);
  public function extern "remove" void remove(uint const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, uint const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<unsigned short>" btAlignedObjectArray_unsigned_short {
  public function extern "at" ushort mutable& at(int n_0);
  public function extern "at" ushort const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" ushort mutable& expandNonInitializing();
  public function extern "expand" ushort mutable& expand_(ushort const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(ushort const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(ushort const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(ushort const& _Val_0);
  public function extern "remove" void remove(ushort const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, ushort const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public pure struct extern "::btAlignedObjectArray<void *>" btAlignedObjectArray_void_p {
  public function extern "at" rptr{void} mutable& at(int n_0);
  public function extern "at" rptr{void} const& cat(int n_0) const;
  public function extern "capacity" int capacity() const;
  public function extern "clear" void clear();
  public function extern "expandNonInitializing" rptr{void} mutable& expandNonInitializing();
  public function extern "expand" rptr{void} mutable& expand_(rptr{void} const& fillValue_0);
  public function extern "findBinarySearch" int findBinarySearch(rptr{void} const& key_0) const;
  public function extern "findLinearSearch" int findLinearSearch(rptr{void} const& key_0) const;
  public function extern "initializeFromBuffer" void initializeFromBuffer(rptr{void} buffer_0, int size_1, int capacity_2);
  public function extern "pop_back" void pop_back();
  public function extern "push_back" void push_back(rptr{void} const& _Val_0);
  public function extern "remove" void remove(rptr{void} const& key_0);
  public function extern "reserve" void reserve(int _Count_0);
  public function extern "resize" void resize(int newsize_0, rptr{void} const& fillData_1);
  public function extern "resizeNoInitialize" void resizeNoInitialize(int newsize_0);
  public function extern "size" int size() const;
  public function extern "swap" void swap(int index0_0, int index1_1);
}
public metafunction btAllocFunc m::list{rptr{void}, size_t};
public pure struct extern "::btAngleCompareFunc" "nodefault" btAngleCompareFunc(btVector3 const& anchor_0)  {
  public btVector3 m_anchor;
}
public pure struct extern "::btAngularLimit" btAngularLimit {
  public function extern "fit" void fit(btScalar mutable& angle_0) const;
  public function extern "getBiasFactor" btScalar getBiasFactor() const;
  public function extern "getCorrection" btScalar getCorrection() const;
  public function extern "getError" btScalar getError() const;
  public function extern "getHalfRange" btScalar getHalfRange() const;
  public function extern "getHigh" btScalar getHigh() const;
  public function extern "getLow" btScalar getLow() const;
  public function extern "getRelaxationFactor" btScalar getRelaxationFactor() const;
  public function extern "getSign" btScalar getSign() const;
  public function extern "getSoftness" btScalar getSoftness() const;
  public function extern "isLimit" bool isLimit() const;
  public function extern "set" void set(btScalar low_0, btScalar high_1, btScalar _softness_2, btScalar _biasFactor_3, btScalar _relaxationFactor_4);
  public function extern "test" void test(btScalar const angle_0);
}
public pure struct extern "::btAxisSweep3Internal<unsigned int>" "nodefault" btAxisSweep3Internal_unsigned_int(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, uint handleMask_2, uint handleSentinel_3, uint maxHandles_4, rptr{btOverlappingPairCache} pairCache_5, bool disableRaycastAccelerator_6)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "addHandle" uint addHandle(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} pOwner_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{btDispatcher} dispatcher_5, rptr{void} multiSapProxy_6);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_int_Handle} getHandle(uint index_0) const;
  public function extern "getNumHandles" uint getNumHandles() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "printStats" void printStats();
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback_0);
  public function extern "quantize" void quantize(rptr{uint} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "removeHandle" void removeHandle(uint handle_0, rptr{btDispatcher} dispatcher_1);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback_0);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "updateHandle" void updateHandle(uint handle_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
}
public pure struct extern "::btAxisSweep3Internal<unsigned short>" "nodefault" btAxisSweep3Internal_unsigned_short(btVector3 const& worldAabbMin_0, btVector3 const& worldAabbMax_1, ushort handleMask_2, ushort handleSentinel_3, ushort maxHandles_4, rptr{btOverlappingPairCache} pairCache_5, bool disableRaycastAccelerator_6)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "addHandle" ushort addHandle(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} pOwner_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{btDispatcher} dispatcher_5, rptr{void} multiSapProxy_6);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getHandle" rptr{btAxisSweep3Internal_unsigned_short_Handle} getHandle(ushort index_0) const;
  public function extern "getNumHandles" ushort getNumHandles() const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getOverlappingPairUserCallback" crptr{btOverlappingPairCallback} getOverlappingPairUserCallback() const;
  public function extern "printStats" void printStats();
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} callback_0);
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "removeHandle" void removeHandle(ushort handle_0, rptr{btDispatcher} dispatcher_1);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "setOverlappingPairUserCallback" void setOverlappingPairUserCallback(rptr{btOverlappingPairCallback} pairCallback_0);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "unQuantize" void unQuantize(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "updateHandle" void updateHandle(ushort handle_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
}
public pure struct extern "::btBU_Simplex1to4" "nonmovable" btBU_Simplex1to4 {
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape, btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "addVertex" void addVertex(btVector3 const& pt_0);
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getIndex" int getIndex(int i_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "reset" void reset();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btBlock" btBlock {
  public rptr{btBlock} previous;
  public rptr{uchar} address;
}
public pure struct extern "::btBox2dBox2dCollisionAlgorithm" "nodefault" btBox2dBox2dCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btBox2dShape" "nodefault" btBox2dShape(btVector3 const& boxHalfExtents_0)  {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getCentroid" btVector3 const& getCentroid() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNormals" crptr{btVector3} getNormals() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPlaneEquation" void getPlaneEquation(btVector4 mutable& plane_0, int i_1) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getVertexCount" int getVertexCount() const;
  public function extern "getVertices" crptr{btVector3} getVertices() const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btBoxBoxCollisionAlgorithm" "nodefault" btBoxBoxCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btBoxBoxDetector" "nodefault" btBoxBoxDetector(crptr{btBoxShape} box1_0, crptr{btBoxShape} box2_1)  {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface};
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2, bool swapResults_3);
  public crptr{btBoxShape} m_box1;
  public crptr{btBoxShape} m_box2;
}
public pure struct extern "::btBoxShape" "nodefault" btBoxShape(btVector3 const& boxHalfExtents_0)  {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPlaneEquation" void getPlaneEquation(btVector4 mutable& plane_0, int i_1) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btMultiSapBroadphase::btBridgeProxy" "nodefault" btMultiSapBroadphase_btBridgeProxy private {
}
public pure struct extern "::btBroadphaseAabbCallback" "nonmovable" btBroadphaseAabbCallback {
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy_0);
}
public pure struct extern "::btBroadphaseInterface" "nonmovable" btBroadphaseInterface {
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "printStats" void printStats();
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
}
public pure struct extern "::btBroadphasePair" btBroadphasePair {
  public rptr{btBroadphaseProxy} m_pProxy0;
  public rptr{btBroadphaseProxy} m_pProxy1;
  public rptr{btCollisionAlgorithm} m_algorithm;
  public int m_curThreadId;
}
public pure struct extern "::btBroadphasePairSortPredicate" btBroadphasePairSortPredicate {
}
public pure struct extern "::btBroadphaseProxy" btBroadphaseProxy {
  public function extern "getUid" int getUid() const;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
}
public pure struct extern "::btBroadphaseRayCallback" btBroadphaseRayCallback {
  public metafunction __base__ {btBroadphaseAabbCallback};
  public function extern "process" bool process(crptr{btBroadphaseProxy} proxy_0);
  public btVector3 m_rayDirectionInverse;
  public rawarray{uint, 3} m_signs;
  public btScalar m_lambda_max;
}
public pure struct extern "::btBulletSerializedArrays" btBulletSerializedArrays {
}
public pure struct extern "::btBvhSubtreeInfo" btBvhSubtreeInfo {
  public function extern "setAabbFromQuantizeNode" void setAabbFromQuantizeNode(btQuantizedBvhNode const& quantizedNode_0);
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_rootNodeIndex;
  public int m_subtreeSize;
  public rawarray{int, 3} m_padding;
}
public pure struct extern "::btBvhSubtreeInfoData" btBvhSubtreeInfoData {
  public int m_rootNodeIndex;
  public int m_subtreeSize;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
}
public pure struct extern "::btBvhTriangleMeshShape" "nodefault" btBvhTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2)  {
  public metafunction __base__ {btTriangleMeshShape, btConcaveShape, btCollisionShape};
  public function extern "buildOptimizedBvh" void buildOptimizedBvh();
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getOptimizedBvh" rptr{btOptimizedBvh} getOptimizedBvh();
  public function extern "getOwnsBvh" bool getOwnsBvh() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "partialRefitTree" void partialRefitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "performConvexcast" void performConvexcast(rptr{btTriangleCallback} callback_0, btVector3 const& boxSource_1, btVector3 const& boxTarget_2, btVector3 const& boxMin_3, btVector3 const& boxMax_4);
  public function extern "performRaycast" void performRaycast(rptr{btTriangleCallback} callback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "refitTree" void refitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleBvh" void serializeSingleBvh(rptr{btSerializer} serializer_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "serializeSingleTriangleInfoMap" void serializeSingleTriangleInfoMap(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setOptimizedBvh" void setOptimizedBvh(rptr{btOptimizedBvh} bvh_0, btVector3 const& localScaling_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "usesQuantizedAabbCompression" bool usesQuantizedAabbCompression() const;
}
public pure struct extern "::btCapsuleShape" "nodefault" btCapsuleShape(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "deSerializeFloat" void deSerializeFloat(rptr{btCapsuleShapeData} dataBuffer_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btCapsuleShapeData" btCapsuleShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public int m_upAxis;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btCapsuleShapeX" "nodefault" btCapsuleShapeX(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btCapsuleShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "deSerializeFloat" void deSerializeFloat(rptr{btCapsuleShapeData} dataBuffer_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btCapsuleShapeZ" "nodefault" btCapsuleShapeZ(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btCapsuleShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "deSerializeFloat" void deSerializeFloat(rptr{btCapsuleShapeData} dataBuffer_0);
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHalfHeight" btScalar getHalfHeight() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btCharIndexTripletData" btCharIndexTripletData {
  public rawarray{uchar, 3} m_values;
  public char m_pad;
}
public pure struct extern "::btCharacterControllerInterface" "nonmovable" btCharacterControllerInterface {
  public metafunction __base__ {btActionInterface};
  public function extern "canJump" bool canJump() const;
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "jump" void jump();
  public function extern "onGround" bool onGround() const;
  public function extern "playerStep" void playerStep(rptr{btCollisionWorld} collisionWorld_0, btScalar dt_1);
  public function extern "preStep" void preStep(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "reset" void reset(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "setUpInterpolate" void setUpInterpolate(bool value_0);
  public function extern "setVelocityForTimeInterval" void setVelocityForTimeInterval(btVector3 const& velocity_0, btScalar timeInterval_1);
  public function extern "setWalkDirection" void setWalkDirection(btVector3 const& walkDirection_0);
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTimeStep_1);
  public function extern "warp" void warp(btVector3 const& origin_0);
}
public pure struct extern "::btChunk" btChunk {
  public int m_chunkCode;
  public int m_length;
  public rptr{void} m_oldPtr;
  public int m_dna_nr;
  public int m_number;
}
public pure struct extern "::btClock" btClock {
  public function extern "getTimeMicroseconds" ulong getTimeMicroseconds();
  public function extern "getTimeMilliseconds" ulong getTimeMilliseconds();
  public function extern "getTimeSeconds" btScalar getTimeSeconds();
  public function extern "reset" void reset();
}
public pure struct extern "::btClockData" "nodefault" btClockData private {
}
public pure struct extern "::btCollisionAlgorithm" "nonmovable" btCollisionAlgorithm {
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btCollisionAlgorithmConstructionInfo" btCollisionAlgorithmConstructionInfo {
  public rptr{btDispatcher} m_dispatcher1;
  public rptr{btPersistentManifold} m_manifold;
}
public pure struct extern "::btCollisionAlgorithmCreateFunc" "nonmovable" btCollisionAlgorithmCreateFunc {
  public function extern "CreateCollisionAlgorithm" rptr{btCollisionAlgorithm} CreateCollisionAlgorithm(btCollisionAlgorithmConstructionInfo mutable& _0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
  public bool m_swapped;
}
public pure struct extern "::btCollisionConfiguration" "nonmovable" btCollisionConfiguration {
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0_0, int proxyType1_1);
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
}
public pure struct extern "::btCollisionDispatcher" "nodefault" btCollisionDispatcher(rptr{btCollisionConfiguration} collisionConfiguration_0)  {
  public metafunction __base__ {btDispatcher};
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size_0);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache_0, btDispatcherInfo const& dispatchInfo_1, rptr{btDispatcher} dispatcher_2);
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, rptr{btPersistentManifold} sharedManifold_2);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr_0);
  public function extern "getCollisionConfiguration" rptr{btCollisionConfiguration} getCollisionConfiguration();
  public function extern "getCollisionConfiguration" crptr{btCollisionConfiguration} cgetCollisionConfiguration() const;
  public function extern "getDispatcherFlags" int getDispatcherFlags() const;
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} cgetInternalManifoldPool() const;
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index_0);
  public function extern "getManifoldByIndexInternal" crptr{btPersistentManifold} cgetManifoldByIndexInternal(int index_0) const;
  public function extern "getNearCallback" btNearCallback getNearCallback() const;
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0_0, crptr{btCollisionObject} b1_1);
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "registerCollisionCreateFunc" void registerCollisionCreateFunc(int proxyType0_0, int proxyType1_1, rptr{btCollisionAlgorithmCreateFunc} createFunc_2);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "setCollisionConfiguration" void setCollisionConfiguration(rptr{btCollisionConfiguration} config_0);
  public function extern "setDispatcherFlags" void setDispatcherFlags(int flags_0);
  public function extern "setNearCallback" void setNearCallback(btNearCallback nearCallback_0);
}
public pure struct extern "::btCollisionObject" "nonmovable" btCollisionObject {
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co_0) const;
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "isActive" bool isActive() const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "setIgnoreCollisionCheck" void setIgnoreCollisionCheck(crptr{btCollisionObject} co_0, bool ignoreCollisionCheck_1);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
}
public pure struct extern "::btCollisionObjectDoubleData" btCollisionObjectDoubleData {
  public rptr{void} m_broadphaseHandle;
  public rptr{void} m_collisionShape;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public rptr{char} m_name;
  public btTransformDoubleData m_worldTransform;
  public btTransformDoubleData m_interpolationWorldTransform;
  public btVector3DoubleData m_interpolationLinearVelocity;
  public btVector3DoubleData m_interpolationAngularVelocity;
  public btVector3DoubleData m_anisotropicFriction;
  public double m_contactProcessingThreshold;
  public double m_deactivationTime;
  public double m_friction;
  public double m_rollingFriction;
  public double m_restitution;
  public double m_hitFraction;
  public double m_ccdSweptSphereRadius;
  public double m_ccdMotionThreshold;
  public int m_hasAnisotropicFriction;
  public int m_collisionFlags;
  public int m_islandTag1;
  public int m_companionId;
  public int m_activationState1;
  public int m_internalType;
  public int m_checkCollideWith;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btCollisionObjectFloatData" btCollisionObjectFloatData {
  public rptr{void} m_broadphaseHandle;
  public rptr{void} m_collisionShape;
  public rptr{btCollisionShapeData} m_rootCollisionShape;
  public rptr{char} m_name;
  public btTransformFloatData m_worldTransform;
  public btTransformFloatData m_interpolationWorldTransform;
  public btVector3FloatData m_interpolationLinearVelocity;
  public btVector3FloatData m_interpolationAngularVelocity;
  public btVector3FloatData m_anisotropicFriction;
  public float m_contactProcessingThreshold;
  public float m_deactivationTime;
  public float m_friction;
  public float m_rollingFriction;
  public float m_restitution;
  public float m_hitFraction;
  public float m_ccdSweptSphereRadius;
  public float m_ccdMotionThreshold;
  public int m_hasAnisotropicFriction;
  public int m_collisionFlags;
  public int m_islandTag1;
  public int m_companionId;
  public int m_activationState1;
  public int m_internalType;
  public int m_checkCollideWith;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btCollisionObjectWrapper" "nodefault" btCollisionObjectWrapper(crptr{btCollisionObjectWrapper} parent_0, crptr{btCollisionShape} shape_1, crptr{btCollisionObject} collisionObject_2, btTransform const& worldTransform_3, int partId_4, int index_5)  {
  public function extern "getCollisionObject" crptr{btCollisionObject} getCollisionObject() const;
  public function extern "getCollisionShape" crptr{btCollisionShape} getCollisionShape() const;
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public crptr{btCollisionObjectWrapper} m_parent;
  public crptr{btCollisionShape} m_shape;
  public crptr{btCollisionObject} m_collisionObject;
  public int m_partId;
  public int m_index;
}
public pure struct extern "::btCollisionResult" "nodefault" btCollisionResult private {
}
public pure struct extern "::btCollisionShape" "nonmovable" btCollisionShape {
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btCollisionShapeData" btCollisionShapeData {
  public rptr{char} m_name;
  public int m_shapeType;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btCollisionWorld" "nodefault" btCollisionWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphasePairCache_1, rptr{btCollisionConfiguration} collisionConfiguration_2)  {
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "updateAabbs" void updateAabbs();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
}
public pure struct extern "::btCollisionWorldImporter" "nodefault" btCollisionWorldImporter(rptr{btCollisionWorld} world_0)  {
  public function extern "convertAllObjects" bool convertAllObjects(rptr{btBulletSerializedArrays} arrays_0);
  public function extern "createBoxShape" rptr{btCollisionShape} createBoxShape(btVector3 const& halfExtents_0);
  public function extern "createBvhTriangleMeshShape" rptr{btBvhTriangleMeshShape} createBvhTriangleMeshShape(rptr{btStridingMeshInterface} trimesh_0, rptr{btOptimizedBvh} bvh_1);
  public function extern "createCapsuleShapeX" rptr{btCollisionShape} createCapsuleShapeX(btScalar radius_0, btScalar height_1);
  public function extern "createCapsuleShapeY" rptr{btCollisionShape} createCapsuleShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createCapsuleShapeZ" rptr{btCollisionShape} createCapsuleShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createCollisionObject" rptr{btCollisionObject} createCollisionObject(btTransform const& startTransform_0, rptr{btCollisionShape} shape_1, crptr{char} bodyName_2);
  public function extern "createCompoundShape" rptr{btCompoundShape} createCompoundShape();
  public function extern "createConeShapeX" rptr{btCollisionShape} createConeShapeX(btScalar radius_0, btScalar height_1);
  public function extern "createConeShapeY" rptr{btCollisionShape} createConeShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createConeShapeZ" rptr{btCollisionShape} createConeShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createConvexHullShape" rptr{btConvexHullShape} createConvexHullShape();
  public function extern "createConvexTriangleMeshShape" rptr{btCollisionShape} createConvexTriangleMeshShape(rptr{btStridingMeshInterface} trimesh_0);
  public function extern "createCylinderShapeX" rptr{btCollisionShape} createCylinderShapeX(btScalar radius_0, btScalar height_1);
  public function extern "createCylinderShapeY" rptr{btCollisionShape} createCylinderShapeY(btScalar radius_0, btScalar height_1);
  public function extern "createCylinderShapeZ" rptr{btCollisionShape} createCylinderShapeZ(btScalar radius_0, btScalar height_1);
  public function extern "createMeshInterface" rptr{btTriangleIndexVertexArray} createMeshInterface(btStridingMeshInterfaceData mutable& meshData_0);
  public function extern "createMultiSphereShape" rptr{btMultiSphereShape} createMultiSphereShape(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2);
  public function extern "createOptimizedBvh" rptr{btOptimizedBvh} createOptimizedBvh();
  public function extern "createPlaneShape" rptr{btCollisionShape} createPlaneShape(btVector3 const& planeNormal_0, btScalar planeConstant_1);
  public function extern "createScaledTrangleMeshShape" rptr{btScaledBvhTriangleMeshShape} createScaledTrangleMeshShape(rptr{btBvhTriangleMeshShape} meshShape_0, btVector3 const& localScalingbtBvhTriangleMeshShape_1);
  public function extern "createSphereShape" rptr{btCollisionShape} createSphereShape(btScalar radius_0);
  public function extern "createStridingMeshInterfaceData" rptr{btStridingMeshInterfaceData} createStridingMeshInterfaceData(rptr{btStridingMeshInterfaceData} interfaceData_0);
  public function extern "createTriangleMeshContainer" rptr{btTriangleIndexVertexArray} createTriangleMeshContainer();
  public function extern "deleteAllData" void deleteAllData();
  public function extern "getBvhByIndex" rptr{btOptimizedBvh} getBvhByIndex(int index_0) const;
  public function extern "getCollisionObjectByName" rptr{btCollisionObject} getCollisionObjectByName(crptr{char} name_0);
  public function extern "getCollisionShapeByIndex" rptr{btCollisionShape} getCollisionShapeByIndex(int index_0);
  public function extern "getCollisionShapeByName" rptr{btCollisionShape} getCollisionShapeByName(crptr{char} name_0);
  public function extern "getNameForPointer" crptr{char} getNameForPointer(crptr{void} ptr_0) const;
  public function extern "getNumBvhs" int getNumBvhs() const;
  public function extern "getNumCollisionShapes" int getNumCollisionShapes() const;
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getNumRigidBodies" int getNumRigidBodies() const;
  public function extern "getNumTriangleInfoMaps" int getNumTriangleInfoMaps() const;
  public function extern "getRigidBodyByIndex" rptr{btCollisionObject} getRigidBodyByIndex(int index_0) const;
  public function extern "getVerboseMode" int getVerboseMode() const;
  public function extern "setVerboseMode" void setVerboseMode(int verboseMode_0);
}
public pure struct extern "::btCompoundCollisionAlgorithm" "nodefault" btCompoundCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getChildAlgorithm" rptr{btCollisionAlgorithm} getChildAlgorithm(int n_0) const;
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btCompoundCompoundCollisionAlgorithm" "nodefault" btCompoundCompoundCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btCompoundCollisionAlgorithm, btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getChildAlgorithm" rptr{btCollisionAlgorithm} getChildAlgorithm(int n_0) const;
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btCompoundShape" "nodefault" btCompoundShape(bool enableDynamicAabbTree_0)  {
  public metafunction __base__ {btCollisionShape};
  public function extern "addChildShape" void addChildShape(btTransform const& localTransform_0, rptr{btCollisionShape} shape_1);
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(rptr{btScalar} masses_0, btTransform mutable& principal_1, btVector3 mutable& inertia_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "createAabbTreeFromChildren" void createAabbTreeFromChildren();
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getChildList" rptr{btCompoundShapeChild} getChildList();
  public function extern "getChildShape" rptr{btCollisionShape} getChildShape(int index_0);
  public function extern "getChildShape" crptr{btCollisionShape} cgetChildShape(int index_0) const;
  public function extern "getChildTransform" btTransform mutable& getChildTransform(int index_0);
  public function extern "getChildTransform" btTransform const& cgetChildTransform(int index_0) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getDynamicAabbTree" rptr{btDbvt} getDynamicAabbTree();
  public function extern "getDynamicAabbTree" crptr{btDbvt} cgetDynamicAabbTree() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumChildShapes" int getNumChildShapes() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpdateRevision" int getUpdateRevision() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "recalculateLocalAabb" void recalculateLocalAabb();
  public function extern "removeChildShape" void removeChildShape(rptr{btCollisionShape} shape_0);
  public function extern "removeChildShapeByIndex" void removeChildShapeByIndex(int childShapeindex_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "updateChildTransform" void updateChildTransform(int childIndex_0, btTransform const& newChildTransform_1, bool shouldRecalculateLocalAabb_2);
}
public pure struct extern "::btCompoundShapeChild" btCompoundShapeChild {
  public btTransform m_transform;
  public rptr{btCollisionShape} m_childShape;
  public int m_childShapeType;
  public btScalar m_childMargin;
  public rptr{btDbvtNode} m_node;
}
public pure struct extern "::btCompoundShapeChildData" btCompoundShapeChildData {
  public btTransformFloatData m_transform;
  public rptr{btCollisionShapeData} m_childShape;
  public int m_childShapeType;
  public float m_childMargin;
}
public pure struct extern "::btCompoundShapeData" btCompoundShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public rptr{btCompoundShapeChildData} m_childShapePtr;
  public int m_numChildShapes;
  public float m_collisionMargin;
}
public pure struct extern "::btConcaveShape" "nonmovable" btConcaveShape {
  public metafunction __base__ {btCollisionShape};
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConeShape" "nodefault" btConeShape(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex_0);
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConeShapeData" btConeShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public int m_upIndex;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btConeShapeX" "nodefault" btConeShapeX(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConeShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex_0);
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConeShapeZ" "nodefault" btConeShapeZ(btScalar radius_0, btScalar height_1)  {
  public metafunction __base__ {btConeShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getConeUpIndex" int getConeUpIndex() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHeight" btScalar getHeight() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setConeUpIndex" void setConeUpIndex(int upIndex_0);
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConeTwistConstraint" "nodefault" btConeTwistConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "GetPointForAngle" btVector3 GetPointForAngle(btScalar fAngleInRadians_0, btScalar fLength_1) const;
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calcAngleInfo" void calcAngleInfo();
  public function extern "calcAngleInfo2" void calcAngleInfo2(btTransform const& transA_0, btTransform const& transB_1, btMatrix3x3 const& invInertiaWorldA_2, btMatrix3x3 const& invInertiaWorldB_3);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "enableMotor" void enableMotor(bool b_0);
  public function extern "getAFrame" btTransform const& getAFrame();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBFrame" btTransform const& getBFrame();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFixThresh" btScalar getFixThresh();
  public function extern "getFrameOffsetA" btTransform const& getFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform const& getFrameOffsetB() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btMatrix3x3 const& invInertiaWorldA_3, btMatrix3x3 const& invInertiaWorldB_4);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getSolveSwingLimit" int getSolveSwingLimit();
  public function extern "getSolveTwistLimit" int getSolveTwistLimit();
  public function extern "getSwingSpan1" btScalar getSwingSpan1();
  public function extern "getSwingSpan2" btScalar getSwingSpan2();
  public function extern "getTwistAngle" btScalar getTwistAngle();
  public function extern "getTwistLimitSign" btScalar getTwistLimitSign();
  public function extern "getTwistSpan" btScalar getTwistSpan();
  public function extern "getUid" int getUid() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "isPastSwingLimit" bool isPastSwingLimit();
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDamping" void setDamping(btScalar damping_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setFixThresh" void setFixThresh(btScalar fixThresh_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLimit" void setLimit2(int limitIndex_0, btScalar limitValue_1);
  public function extern "setLimit" void setLimit6(btScalar _swingSpan1_0, btScalar _swingSpan2_1, btScalar _twistSpan_2, btScalar _softness_3, btScalar _biasFactor_4, btScalar _relaxationFactor_5);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse_0);
  public function extern "setMaxMotorImpulseNormalized" void setMaxMotorImpulseNormalized(btScalar maxMotorImpulse_0);
  public function extern "setMotorTarget" void setMotorTarget(btQuaternion const& q_0);
  public function extern "setMotorTargetInConstraintSpace" void setMotorTargetInConstraintSpace(btQuaternion const& q_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public int m_objectType;
}
public pure struct extern "::btConeTwistConstraintData" btConeTwistConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public float m_swingSpan1;
  public float m_swingSpan2;
  public float m_twistSpan;
  public float m_limitSoftness;
  public float m_biasFactor;
  public float m_relaxationFactor;
  public float m_damping;
  public rawarray{char, 4} m_pad;
}
public pure struct extern "::btConeTwistConstraintDoubleData" btConeTwistConstraintDoubleData {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public double m_swingSpan1;
  public double m_swingSpan2;
  public double m_twistSpan;
  public double m_limitSoftness;
  public double m_biasFactor;
  public double m_relaxationFactor;
  public double m_damping;
}
public pure tsvaluetype struct extern "::btConeTwistFlags" "extenum" btConeTwistFlags { }
public extern "BT_CONETWIST_FLAGS_LIN_CFM" btConeTwistFlags btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_CFM;
public extern "BT_CONETWIST_FLAGS_LIN_ERP" btConeTwistFlags btConeTwistFlags_BT_CONETWIST_FLAGS_LIN_ERP;
public extern "BT_CONETWIST_FLAGS_ANG_CFM" btConeTwistFlags btConeTwistFlags_BT_CONETWIST_FLAGS_ANG_CFM;
public pure struct extern "::btTypedConstraint::btConstraintInfo1" btTypedConstraint_btConstraintInfo1 {
  public int m_numConstraintRows;
  public int nub;
}
public pure struct extern "::btTypedConstraint::btConstraintInfo2" btTypedConstraint_btConstraintInfo2 {
  public btScalar fps;
  public btScalar erp;
  public rptr{btScalar} m_J1linearAxis;
  public rptr{btScalar} m_J1angularAxis;
  public rptr{btScalar} m_J2linearAxis;
  public rptr{btScalar} m_J2angularAxis;
  public int rowskip;
  public rptr{btScalar} m_constraintError;
  public rptr{btScalar} cfm;
  public rptr{btScalar} m_lowerLimit;
  public rptr{btScalar} m_upperLimit;
  public rptr{int} findex;
  public int m_numIterations;
  public btScalar m_damping;
}
public pure tsvaluetype struct extern "::btConstraintParams" "extenum" btConstraintParams { }
public extern "BT_CONSTRAINT_ERP" btConstraintParams btConstraintParams_BT_CONSTRAINT_ERP;
public extern "BT_CONSTRAINT_STOP_ERP" btConstraintParams btConstraintParams_BT_CONSTRAINT_STOP_ERP;
public extern "BT_CONSTRAINT_CFM" btConstraintParams btConstraintParams_BT_CONSTRAINT_CFM;
public extern "BT_CONSTRAINT_STOP_CFM" btConstraintParams btConstraintParams_BT_CONSTRAINT_STOP_CFM;
public pure struct extern "::btConstraintRow" btConstraintRow {
  public rawarray{btScalar, 3} m_normal;
  public btScalar m_rhs;
  public btScalar m_jacDiagInv;
  public btScalar m_lowerLimit;
  public btScalar m_upperLimit;
  public btScalar m_accumImpulse;
}
public pure struct extern "::btConstraintSetting" btConstraintSetting {
  public btScalar m_tau;
  public btScalar m_damping;
  public btScalar m_impulseClamp;
}
public pure struct extern "::btConstraintSolver" "nonmovable" btConstraintSolver {
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1);
  public function extern "getSolverType" btConstraintSolverType getSolverType() const;
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "reset" void reset();
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifold_2, int numManifolds_3, rptr{rptr{btTypedConstraint}} constraints_4, int numConstraints_5, btContactSolverInfo const& info_6, rptr{btIDebugDraw} debugDrawer_7, rptr{btDispatcher} dispatcher_8);
}
public pure tsvaluetype struct extern "::btConstraintSolverType" "extenum" btConstraintSolverType { }
public extern "BT_SEQUENTIAL_IMPULSE_SOLVER" btConstraintSolverType btConstraintSolverType_BT_SEQUENTIAL_IMPULSE_SOLVER;
public extern "BT_MLCP_SOLVER" btConstraintSolverType btConstraintSolverType_BT_MLCP_SOLVER;
public extern "BT_NNCG_SOLVER" btConstraintSolverType btConstraintSolverType_BT_NNCG_SOLVER;
public pure struct extern "::btContactConstraint" "nodefault" btContactConstraint(rptr{btPersistentManifold} contactManifold_0, btRigidBody mutable& rbA_1, btRigidBody mutable& rbB_2)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getContactManifold" rptr{btPersistentManifold} getContactManifold();
  public function extern "getContactManifold" crptr{btPersistentManifold} cgetContactManifold() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getUid" int getUid() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setContactManifold" void setContactManifold(rptr{btPersistentManifold} contactManifold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public int m_objectType;
}
public pure tsvaluetype struct extern "::btContactManifoldTypes" "extenum" btContactManifoldTypes { }
public extern "MIN_CONTACT_MANIFOLD_TYPE" btContactManifoldTypes btContactManifoldTypes_MIN_CONTACT_MANIFOLD_TYPE;
public extern "BT_PERSISTENT_MANIFOLD_TYPE" btContactManifoldTypes btContactManifoldTypes_BT_PERSISTENT_MANIFOLD_TYPE;
public pure struct extern "::btContactSolverInfo" btContactSolverInfo {
  public metafunction __base__ {btContactSolverInfoData};
  public btScalar m_tau;
  public btScalar m_damping;
  public btScalar m_friction;
  public btScalar m_timeStep;
  public btScalar m_restitution;
  public int m_numIterations;
  public btScalar m_maxErrorReduction;
  public btScalar m_sor;
  public btScalar m_erp;
  public btScalar m_erp2;
  public btScalar m_globalCfm;
  public int m_splitImpulse;
  public btScalar m_splitImpulsePenetrationThreshold;
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_linearSlop;
  public btScalar m_warmstartingFactor;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public btScalar m_maxGyroscopicForce;
  public btScalar m_singleAxisRollingFrictionThreshold;
}
public pure struct extern "::btContactSolverInfoData" btContactSolverInfoData {
  public btScalar m_tau;
  public btScalar m_damping;
  public btScalar m_friction;
  public btScalar m_timeStep;
  public btScalar m_restitution;
  public int m_numIterations;
  public btScalar m_maxErrorReduction;
  public btScalar m_sor;
  public btScalar m_erp;
  public btScalar m_erp2;
  public btScalar m_globalCfm;
  public int m_splitImpulse;
  public btScalar m_splitImpulsePenetrationThreshold;
  public btScalar m_splitImpulseTurnErp;
  public btScalar m_linearSlop;
  public btScalar m_warmstartingFactor;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public btScalar m_maxGyroscopicForce;
  public btScalar m_singleAxisRollingFrictionThreshold;
}
public pure struct extern "::btContactSolverInfoDoubleData" btContactSolverInfoDoubleData {
  public double m_tau;
  public double m_damping;
  public double m_friction;
  public double m_timeStep;
  public double m_restitution;
  public double m_maxErrorReduction;
  public double m_sor;
  public double m_erp;
  public double m_erp2;
  public double m_globalCfm;
  public double m_splitImpulsePenetrationThreshold;
  public double m_splitImpulseTurnErp;
  public double m_linearSlop;
  public double m_warmstartingFactor;
  public double m_maxGyroscopicForce;
  public double m_singleAxisRollingFrictionThreshold;
  public int m_numIterations;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public int m_splitImpulse;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btContactSolverInfoFloatData" btContactSolverInfoFloatData {
  public float m_tau;
  public float m_damping;
  public float m_friction;
  public float m_timeStep;
  public float m_restitution;
  public float m_maxErrorReduction;
  public float m_sor;
  public float m_erp;
  public float m_erp2;
  public float m_globalCfm;
  public float m_splitImpulsePenetrationThreshold;
  public float m_splitImpulseTurnErp;
  public float m_linearSlop;
  public float m_warmstartingFactor;
  public float m_maxGyroscopicForce;
  public float m_singleAxisRollingFrictionThreshold;
  public int m_numIterations;
  public int m_solverMode;
  public int m_restingContactRestitutionThreshold;
  public int m_minimumSolverBatchSize;
  public int m_splitImpulse;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btContinuousConvexCollision" "nodefault" btContinuousConvexCollision(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3)  {
  public metafunction __base__ {btConvexCast};
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public pure struct extern "::btConvex2dConvex2dAlgorithm" "nodefault" btConvex2dConvex2dAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, rptr{btVoronoiSimplexSolver} simplexSolver_4, rptr{btConvexPenetrationDepthSolver} pdSolver_5, int numPerturbationIterations_6, int minimumPointsPerturbationThreshold_7)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getManifold" crptr{btPersistentManifold} getManifold();
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "setLowLevelOfDetail" void setLowLevelOfDetail(bool useLowLevel_0);
}
public pure struct extern "::btConvex2dShape" "nodefault" btConvex2dShape(rptr{btConvexShape} convexChildShape_0)  {
  public metafunction __base__ {btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getChildShape" rptr{btConvexShape} getChildShape();
  public function extern "getChildShape" crptr{btConvexShape} cgetChildShape() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConvexCast" "nonmovable" btConvexCast {
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public pure struct extern "::btConvexConcaveCollisionAlgorithm" "nodefault" btConvexConcaveCollisionAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "clearCache" void clearCache();
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btConvexHullComputer" btConvexHullComputer {
  public function extern "compute" btScalar compute_double_cp_int_int_btScalar_btScalar(crptr{double} coords_0, int stride_1, int count_2, btScalar shrink_3, btScalar shrinkClamp_4);
  public function extern "compute" btScalar compute_float_cp_int_int_btScalar_btScalar(crptr{float} coords_0, int stride_1, int count_2, btScalar shrink_3, btScalar shrinkClamp_4);
}
public pure struct extern "::btConvexHullShape" "nodefault" btConvexHullShape(crptr{btScalar} points_0, int numPoints_1, int stride_2)  {
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape, btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "addPoint" void addPoint(btVector3 const& point_0, bool recalculateLocalAabb_1);
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPoints" int getNumPoints() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPoints" crptr{btVector3} getPoints() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getScaledPoint" btVector3 getScaledPoint(int i_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUnscaledPoints" rptr{btVector3} getUnscaledPoints();
  public function extern "getUnscaledPoints" crptr{btVector3} cgetUnscaledPoints() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project4(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "project" void project6(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& minProj_2, btScalar mutable& maxProj_3, btVector3 mutable& witnesPtMin_4, btVector3 mutable& witnesPtMax_5) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConvexHullShapeData" btConvexHullShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rptr{btVector3FloatData} m_unscaledPointsFloatPtr;
  public rptr{btVector3DoubleData} m_unscaledPointsDoublePtr;
  public int m_numUnscaledPoints;
  public rawarray{char, 4} m_padding3;
}
public pure struct extern "::btConvexInternalAabbCachingShape" "nodefault" btConvexInternalAabbCachingShape private {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConvexInternalShape" "nodefault" btConvexInternalShape private {
  public metafunction __base__ {btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConvexInternalShapeData" btConvexInternalShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public btVector3FloatData m_localScaling;
  public btVector3FloatData m_implicitShapeDimensions;
  public float m_collisionMargin;
  public int m_padding;
}
public pure struct extern "::btConvexPenetrationDepthSolver" "nonmovable" btConvexPenetrationDepthSolver {
  public function extern "calcPenDepth" bool calcPenDepth(btVoronoiSimplexSolver mutable& simplexSolver_0, crptr{btConvexShape} convexA_1, crptr{btConvexShape} convexB_2, btTransform const& transA_3, btTransform const& transB_4, btVector3 mutable& v_5, btVector3 mutable& pa_6, btVector3 mutable& pb_7, rptr{btIDebugDraw} debugDraw_8);
}
public pure struct extern "::btConvexPlaneCollisionAlgorithm" "nodefault" btConvexPlaneCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4, int numPerturbationIterations_5, int minimumPointsPerturbationThreshold_6)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "collideSingleContact" void collideSingleContact(btQuaternion const& perturbeRot_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, btDispatcherInfo const& dispatchInfo_3, rptr{btManifoldResult} resultOut_4);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btConvexPointCloudShape" "nonmovable" btConvexPointCloudShape {
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape, btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPoints" int getNumPoints() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getScaledPoint" btVector3 getScaledPoint(int index_0) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUnscaledPoints" rptr{btVector3} getUnscaledPoints();
  public function extern "getUnscaledPoints" crptr{btVector3} cgetUnscaledPoints() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setPoints" void setPoints(rptr{btVector3} points_0, int numPoints_1, bool computeAabb_2, btVector3 const& localScaling_3);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConvexPolyhedron" btConvexPolyhedron {
  public function extern "initialize" void initialize();
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& minProj_2, btScalar mutable& maxProj_3, btVector3 mutable& witnesPtMin_4, btVector3 mutable& witnesPtMax_5) const;
  public function extern "testContainment" bool testContainment() const;
  public btVector3 m_localCenter;
  public btVector3 m_extents;
  public btScalar m_radius;
  public btVector3 mC;
  public btVector3 mE;
}
public pure struct extern "::btConvexSeparatingDistanceUtil" "nodefault" btConvexSeparatingDistanceUtil(btScalar boundingRadiusA_0, btScalar boundingRadiusB_1)  {
  public function extern "getConservativeSeparatingDistance" btScalar getConservativeSeparatingDistance();
  public function extern "initSeparatingDistance" void initSeparatingDistance(btVector3 const& separatingVector_0, btScalar separatingDistance_1, btTransform const& transA_2, btTransform const& transB_3);
  public function extern "updateSeparatingDistance" void updateSeparatingDistance(btTransform const& transA_0, btTransform const& transB_1);
}
public pure struct extern "::btConvexShape" "nonmovable" btConvexShape {
  public metafunction __base__ {btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btConvexTriangleCallback" "nodefault" btConvexTriangleCallback(rptr{btDispatcher} dispatcher_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "clearCache" void clearCache();
  public function extern "clearWrapperData" void clearWrapperData();
  public function extern "getAabbMax" btVector3 const& getAabbMax() const;
  public function extern "getAabbMin" btVector3 const& getAabbMin() const;
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public function extern "setTimeStepAndCounters" void setTimeStepAndCounters(btScalar collisionMarginTriangle_0, btDispatcherInfo const& dispatchInfo_1, crptr{btCollisionObjectWrapper} convexBodyWrap_2, crptr{btCollisionObjectWrapper} triBodyWrap_3, rptr{btManifoldResult} resultOut_4);
  public int m_triangleCount;
  public rptr{btPersistentManifold} m_manifoldPtr;
}
public pure struct extern "::btConvexTriangleMeshShape" "nodefault" btConvexTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface_0, bool calcAabb_1)  {
  public metafunction __base__ {btPolyhedralConvexAabbCachingShape, btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculatePrincipalAxisTransform" void calculatePrincipalAxisTransform(btTransform mutable& principal_0, btVector3 mutable& inertia_1, btScalar mutable& volume_2) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure tsvaluetype struct extern "::btCpuFeatureUtility::btCpuFeature" "extenum" btCpuFeatureUtility_btCpuFeature { }
public extern "CPU_FEATURE_FMA3" btCpuFeatureUtility_btCpuFeature btCpuFeatureUtility_btCpuFeature_CPU_FEATURE_FMA3;
public extern "CPU_FEATURE_SSE4_1" btCpuFeatureUtility_btCpuFeature btCpuFeatureUtility_btCpuFeature_CPU_FEATURE_SSE4_1;
public extern "CPU_FEATURE_NEON_HPFP" btCpuFeatureUtility_btCpuFeature btCpuFeatureUtility_btCpuFeature_CPU_FEATURE_NEON_HPFP;
public pure struct extern "::btCpuFeatureUtility" btCpuFeatureUtility {
}
public pure struct extern "::btCylinderShape" "nodefault" btCylinderShape(btVector3 const& halfExtents_0)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btCylinderShapeData" btCylinderShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public int m_upAxis;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btCylinderShapeX" "nodefault" btCylinderShapeX(btVector3 const& halfExtents_0)  {
  public metafunction __base__ {btCylinderShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btCylinderShapeZ" "nodefault" btCylinderShapeZ(btVector3 const& halfExtents_0)  {
  public metafunction __base__ {btCylinderShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getHalfExtentsWithMargin" btVector3 getHalfExtentsWithMargin() const;
  public function extern "getHalfExtentsWithoutMargin" btVector3 const& getHalfExtentsWithoutMargin() const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btDbvt" "nonmovable" btDbvt {
  public function extern "clear" void clear();
  public function extern "clone" void clone(btDbvt mutable& dest_0, rptr{btDbvt_IClone} iclone_1) const;
  public function extern "collideTT" void collideTT(crptr{btDbvtNode} root0_0, crptr{btDbvtNode} root1_1, btDbvt_ICollide mutable& policy_2);
  public function extern "collideTTpersistentStack" void collideTTpersistentStack(crptr{btDbvtNode} root0_0, crptr{btDbvtNode} root1_1, btDbvt_ICollide mutable& policy_2);
  public function extern "collideTV" void collideTV(crptr{btDbvtNode} root_0, btDbvtVolume const& volume_1, btDbvt_ICollide mutable& policy_2) const;
  public function extern "empty" bool empty() const;
  public function extern "insert" rptr{btDbvtNode} insert(btDbvtVolume const& box_0, rptr{void} data_1);
  public function extern "optimizeBottomUp" void optimizeBottomUp();
  public function extern "optimizeIncremental" void optimizeIncremental(int passes_0);
  public function extern "optimizeTopDown" void optimizeTopDown(int bu_treshold_0);
  public function extern "rayTestInternal" void rayTestInternal(crptr{btDbvtNode} root_0, btVector3 const& rayFrom_1, btVector3 const& rayTo_2, btVector3 const& rayDirectionInverse_3, rptr{uint} signs_4, btScalar lambda_max_5, btVector3 const& aabbMin_6, btVector3 const& aabbMax_7, btDbvt_ICollide mutable& policy_8) const;
  public function extern "remove" void remove(rptr{btDbvtNode} leaf_0);
  public function extern "update" void update_btDbvtNode_p_btDbvtVolume(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1);
  public function extern "update" void update_btDbvtNode_p_int(rptr{btDbvtNode} leaf_0, int lookahead_1);
  public function extern "update" bool update_btDbvtNode_p_btDbvtVolume_btScalar(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1, btScalar margin_2);
  public function extern "update" bool update_btDbvtNode_p_btDbvtVolume_btVector3(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1, btVector3 const& velocity_2);
  public function extern "update" bool update4(rptr{btDbvtNode} leaf_0, btDbvtVolume mutable& volume_1, btVector3 const& velocity_2, btScalar margin_3);
  public function extern "write" void write(rptr{btDbvt_IWriter} iwriter_0) const;
  public rptr{btDbvtNode} m_root;
  public rptr{btDbvtNode} m_free;
  public int m_lkhd;
  public int m_leaves;
  public uint m_opath;
}
public pure struct extern "::btDbvtAabbMm" btDbvtAabbMm {
  public function extern "Center" btVector3 Center() const;
  public function extern "Classify" int Classify(btVector3 const& n_0, btScalar o_1, int s_2) const;
  public function extern "Contain" bool Contain(btDbvtAabbMm const& a_0) const;
  public function extern "Expand" void Expand(btVector3 const& e_0);
  public function extern "Extents" btVector3 Extents() const;
  public function extern "Lengths" btVector3 Lengths() const;
  public function extern "Maxs" btVector3 const& Maxs() const;
  public function extern "Mins" btVector3 const& Mins() const;
  public function extern "ProjectMinimum" btScalar ProjectMinimum(btVector3 const& v_0, uint signs_1) const;
  public function extern "SignedExpand" void SignedExpand(btVector3 const& e_0);
  public function extern "tMaxs" btVector3 mutable& tMaxs();
  public function extern "tMins" btVector3 mutable& tMins();
}
public pure struct extern "::btDbvtBroadphase" "nodefault" btDbvtBroadphase(rptr{btOverlappingPairCache} paircache_0)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "collide" void collide(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "getVelocityPrediction" btScalar getVelocityPrediction() const;
  public function extern "optimize" void optimize();
  public function extern "performDeferredRemoval" void performDeferredRemoval(rptr{btDispatcher} dispatcher_0);
  public function extern "printStats" void printStats();
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "setAabbForceUpdate" void setAabbForceUpdate(rptr{btBroadphaseProxy} absproxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} _3);
  public function extern "setVelocityPrediction" void setVelocityPrediction(btScalar prediction_0);
  public rawarray{btDbvt, 2} m_sets;
  public rawarray{rptr{btDbvtProxy}, 3} m_stageRoots;
  public rptr{btOverlappingPairCache} m_paircache;
  public btScalar m_prediction;
  public int m_stageCurrent;
  public int m_fupdates;
  public int m_dupdates;
  public int m_cupdates;
  public int m_newpairs;
  public int m_fixedleft;
  public uint m_updates_call;
  public uint m_updates_done;
  public btScalar m_updates_ratio;
  public int m_pid;
  public int m_cid;
  public int m_gid;
  public bool m_releasepaircache;
  public bool m_deferedcollide;
  public bool m_needcleanup;
}
public pure struct extern "::btDbvtNode" btDbvtNode {
  public function extern "isinternal" bool isinternal() const;
  public function extern "isleaf" bool isleaf() const;
  public btDbvtVolume volume;
  public rptr{btDbvtNode} parent;
}
public pure struct extern "::btDbvtProxy" "nodefault" btDbvtProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} userPtr_2, short collisionFilterGroup_3, short collisionFilterMask_4)  {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public rptr{btDbvtNode} leaf;
  public rawarray{rptr{btDbvtProxy}, 2} links;
  public int stage;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
}
public metafunction btDbvtVolume btDbvtAabbMm;
public pure struct extern "::btDefaultCollisionConfiguration" "nodefault" btDefaultCollisionConfiguration(btDefaultCollisionConstructionInfo const& constructionInfo_0)  {
  public metafunction __base__ {btCollisionConfiguration};
  public function extern "getCollisionAlgorithmCreateFunc" rptr{btCollisionAlgorithmCreateFunc} getCollisionAlgorithmCreateFunc(int proxyType0_0, int proxyType1_1);
  public function extern "getCollisionAlgorithmPool" rptr{btPoolAllocator} getCollisionAlgorithmPool();
  public function extern "getPersistentManifoldPool" rptr{btPoolAllocator} getPersistentManifoldPool();
  public function extern "getSimplexSolver" rptr{btVoronoiSimplexSolver} getSimplexSolver(int thread_id_0);
  public function extern "setConvexConvexMultipointIterations" void setConvexConvexMultipointIterations(int numPerturbationIterations_0, int minimumPointsPerturbationThreshold_1);
  public function extern "setPlaneConvexMultipointIterations" void setPlaneConvexMultipointIterations(int numPerturbationIterations_0, int minimumPointsPerturbationThreshold_1);
}
public pure struct extern "::btDefaultCollisionConstructionInfo" btDefaultCollisionConstructionInfo {
  public rptr{btPoolAllocator} m_persistentManifoldPool;
  public rptr{btPoolAllocator} m_collisionAlgorithmPool;
  public int m_defaultMaxPersistentManifoldPoolSize;
  public int m_defaultMaxCollisionAlgorithmPoolSize;
  public int m_customCollisionAlgorithmMaxElementSize;
  public int m_useEpaPenetrationAlgorithm;
}
public pure struct extern "::btDefaultMotionState" "nodefault" btDefaultMotionState(btTransform const& startTrans_0, btTransform const& centerOfMassOffset_1)  {
  public metafunction __base__ {btMotionState};
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& worldTrans_0) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public btTransform m_graphicsWorldTrans;
  public btTransform m_centerOfMassOffset;
  public btTransform m_startWorldTrans;
  public rptr{void} m_userPointer;
}
public pure struct extern "::btDefaultSerializer" "nodefault" btDefaultSerializer(int totalSize_0)  {
  public metafunction __base__ {btSerializer};
  public function extern "allocate" rptr{btChunk} allocate(size_t size_0, int numElements_1);
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk_0, crptr{char} structType_1, int chunkCode_2, rptr{void} oldPtr_3);
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr_0) const;
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr_0);
  public function extern "finishSerialization" void finishSerialization();
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "getChunk" crptr{btChunk} getChunk(int chunkIndex_0) const;
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "getNumChunks" int getNumChunks() const;
  public function extern "getSerializationFlags" int getSerializationFlags() const;
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr_0);
  public function extern "internalAlloc" rptr{uchar} internalAlloc(size_t size_0);
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr_0, crptr{char} name_1);
  public function extern "serializeName" void serializeName(crptr{char} ptr_0);
  public function extern "setSerializationFlags" void setSerializationFlags(int flags_0);
  public function extern "startSerialization" void startSerialization();
  public function extern "writeHeader" void writeHeader(rptr{uchar} buffer_0) const;
}
public pure struct extern "::btDefaultVehicleRaycaster" "nodefault" btDefaultVehicleRaycaster(rptr{btDynamicsWorld} world_0)  {
  public metafunction __base__ {btVehicleRaycaster};
  public function extern "castRay" rptr{void} castRay(btVector3 const& from_0, btVector3 const& to_1, btVehicleRaycaster_btVehicleRaycasterResult mutable& result_2);
}
public pure struct extern "::btDiscreteCollisionDetectorInterface" "nonmovable" btDiscreteCollisionDetectorInterface {
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2, bool swapResults_3);
}
public pure struct extern "::btDiscreteDynamicsWorld" "nodefault" btDiscreteDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3)  {
  public metafunction __base__ {btDynamicsWorld, btCollisionWorld};
  public function extern "addAction" void addAction(rptr{btActionInterface} action_0);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "applyGravity" void applyGravity();
  public function extern "clearForces" void clearForces();
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "debugDrawConstraint" void debugDrawConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getApplySpeculativeContactRestitution" bool getApplySpeculativeContactRestitution() const;
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getCollisionWorld" rptr{btCollisionWorld} getCollisionWorld();
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "getLatencyMotionStateInterpolation" bool getLatencyMotionStateInterpolation() const;
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getSimulationIslandManager" rptr{btSimulationIslandManager} getSimulationIslandManager();
  public function extern "getSimulationIslandManager" crptr{btSimulationIslandManager} cgetSimulationIslandManager() const;
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "getSynchronizeAllMotionStates" bool getSynchronizeAllMotionStates() const;
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action_0);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "setApplySpeculativeContactRestitution" void setApplySpeculativeContactRestitution(bool enable_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "setLatencyMotionStateInterpolation" void setLatencyMotionStateInterpolation(bool latencyInterpolation_0);
  public function extern "setNumTasks" void setNumTasks(int numTasks_0);
  public function extern "setSynchronizeAllMotionStates" void setSynchronizeAllMotionStates(bool synchronizeAll_0);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "synchronizeSingleMotionState" void synchronizeSingleMotionState(rptr{btRigidBody} body_0);
  public function extern "updateAabbs" void updateAabbs();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
  public function extern "updateVehicles" void updateVehicles(btScalar timeStep_0);
}
public pure struct extern "::btDispatcher" "nonmovable" btDispatcher {
  public function extern "allocateCollisionAlgorithm" rptr{void} allocateCollisionAlgorithm(int size_0);
  public function extern "clearManifold" void clearManifold(rptr{btPersistentManifold} manifold_0);
  public function extern "dispatchAllCollisionPairs" void dispatchAllCollisionPairs(rptr{btOverlappingPairCache} pairCache_0, btDispatcherInfo const& dispatchInfo_1, rptr{btDispatcher} dispatcher_2);
  public function extern "findAlgorithm" rptr{btCollisionAlgorithm} findAlgorithm(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, rptr{btPersistentManifold} sharedManifold_2);
  public function extern "freeCollisionAlgorithm" void freeCollisionAlgorithm(rptr{void} ptr_0);
  public function extern "getInternalManifoldPointer" rptr{rptr{btPersistentManifold}} getInternalManifoldPointer();
  public function extern "getInternalManifoldPool" rptr{btPoolAllocator} getInternalManifoldPool();
  public function extern "getInternalManifoldPool" crptr{btPoolAllocator} cgetInternalManifoldPool() const;
  public function extern "getManifoldByIndexInternal" rptr{btPersistentManifold} getManifoldByIndexInternal(int index_0);
  public function extern "getNewManifold" rptr{btPersistentManifold} getNewManifold(crptr{btCollisionObject} b0_0, crptr{btCollisionObject} b1_1);
  public function extern "getNumManifolds" int getNumManifolds() const;
  public function extern "needsCollision" bool needsCollision(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "needsResponse" bool needsResponse(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "releaseManifold" void releaseManifold(rptr{btPersistentManifold} manifold_0);
}
public pure struct extern "::btDispatcherInfo" btDispatcherInfo {
  public btScalar m_timeStep;
  public int m_stepCount;
  public int m_dispatchFunc;
  public btScalar m_timeOfImpact;
  public bool m_useContinuous;
  public rptr{btIDebugDraw} m_debugDraw;
  public bool m_enableSatConvex;
  public bool m_enableSPU;
  public bool m_useEpa;
  public btScalar m_allowedCcdPenetration;
  public bool m_useConvexConservativeDistanceUtil;
  public btScalar m_convexConservativeDistanceThreshold;
  public int m_curThread;
}
public pure struct extern "::btDynamicsWorld" "nodefault" btDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphase_1, rptr{btCollisionConfiguration} collisionConfiguration_2)  {
  public metafunction __base__ {btCollisionWorld};
  public function extern "addAction" void addAction(rptr{btActionInterface} action_0);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "clearForces" void clearForces();
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action_0);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
}
public pure struct extern "::btDynamicsWorldDoubleData" btDynamicsWorldDoubleData {
  public btContactSolverInfoDoubleData m_solverInfo;
  public btVector3DoubleData m_gravity;
}
public pure struct extern "::btDynamicsWorldFloatData" btDynamicsWorldFloatData {
  public btContactSolverInfoFloatData m_solverInfo;
  public btVector3FloatData m_gravity;
}
public pure tsvaluetype struct extern "::btDynamicsWorldType" "extenum" btDynamicsWorldType { }
public extern "BT_SIMPLE_DYNAMICS_WORLD" btDynamicsWorldType btDynamicsWorldType_BT_SIMPLE_DYNAMICS_WORLD;
public extern "BT_DISCRETE_DYNAMICS_WORLD" btDynamicsWorldType btDynamicsWorldType_BT_DISCRETE_DYNAMICS_WORLD;
public extern "BT_CONTINUOUS_DYNAMICS_WORLD" btDynamicsWorldType btDynamicsWorldType_BT_CONTINUOUS_DYNAMICS_WORLD;
public extern "BT_SOFT_RIGID_DYNAMICS_WORLD" btDynamicsWorldType btDynamicsWorldType_BT_SOFT_RIGID_DYNAMICS_WORLD;
public extern "BT_GPU_DYNAMICS_WORLD" btDynamicsWorldType btDynamicsWorldType_BT_GPU_DYNAMICS_WORLD;
public pure struct extern "::btElement" btElement {
  public int m_id;
  public int m_sz;
}
public pure struct extern "::btEmptyAlgorithm" "nodefault" btEmptyAlgorithm(btCollisionAlgorithmConstructionInfo const& ci_0)  {
  public metafunction __base__ {btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btEmptyShape" "nonmovable" btEmptyShape {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btFace" btFace {
  public rawarray{btScalar, 4} m_plane;
}
public pure struct extern "::btSimpleBroadphase::btFillingEntry" "nodefault" btSimpleBroadphase_btFillingEntry private {
}
public metafunction btFreeFunc m::list{void, rptr{void}};
public pure struct extern "::btGEN_Link" btGEN_Link {
  public function extern "getNext" rptr{btGEN_Link} getNext() const;
  public function extern "getPrev" rptr{btGEN_Link} getPrev() const;
  public function extern "insertAfter" void insertAfter(rptr{btGEN_Link} link_0);
  public function extern "insertBefore" void insertBefore(rptr{btGEN_Link} link_0);
  public function extern "isHead" bool isHead() const;
  public function extern "isTail" bool isTail() const;
  public function extern "remove" void remove();
}
public pure struct extern "::btGEN_List" btGEN_List {
  public function extern "addHead" void addHead(rptr{btGEN_Link} link_0);
  public function extern "addTail" void addTail(rptr{btGEN_Link} link_0);
  public function extern "getHead" rptr{btGEN_Link} getHead() const;
  public function extern "getTail" rptr{btGEN_Link} getTail() const;
}
public pure struct extern "::btGImpactMeshShape" "nodefault" btGImpactMeshShape private {
}
public pure struct extern "::btGearConstraint" "nodefault" btGearConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& axisInA_2, btVector3 const& axisInB_3, btScalar ratio_4)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getAxisA" btVector3 const& getAxisA() const;
  public function extern "getAxisB" btVector3 const& getAxisB() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRatio" btScalar getRatio() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getUid" int getUid() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAxisA" void setAxisA(btVector3 mutable& axisA_0);
  public function extern "setAxisB" void setAxisB(btVector3 mutable& axisB_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setRatio" void setRatio(btScalar ratio_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public int m_objectType;
}
public pure struct extern "::btGearConstraintDoubleData" btGearConstraintDoubleData {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btVector3DoubleData m_axisInA;
  public btVector3DoubleData m_axisInB;
  public double m_ratio;
}
public pure struct extern "::btGearConstraintFloatData" btGearConstraintFloatData {
  public btTypedConstraintFloatData m_typeConstraintData;
  public btVector3FloatData m_axisInA;
  public btVector3FloatData m_axisInB;
  public float m_ratio;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btGeneric6DofConstraint" "nodefault" btGeneric6DofConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getUid" int getUid() const;
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public bool m_useSolveConstraintObsolete;
  public int m_objectType;
}
public pure struct extern "::btGeneric6DofConstraintData" btGeneric6DofConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public btVector3FloatData m_linearUpperLimit;
  public btVector3FloatData m_linearLowerLimit;
  public btVector3FloatData m_angularUpperLimit;
  public btVector3FloatData m_angularLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
}
public pure struct extern "::btGeneric6DofConstraintDoubleData2" btGeneric6DofConstraintDoubleData2 {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public btVector3DoubleData m_linearUpperLimit;
  public btVector3DoubleData m_linearLowerLimit;
  public btVector3DoubleData m_angularUpperLimit;
  public btVector3DoubleData m_angularLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
}
public pure struct extern "::btGeneric6DofSpring2ConstraintData" btGeneric6DofSpring2ConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public btVector3FloatData m_linearUpperLimit;
  public btVector3FloatData m_linearLowerLimit;
  public btVector3FloatData m_linearBounce;
  public btVector3FloatData m_linearStopERP;
  public btVector3FloatData m_linearStopCFM;
  public btVector3FloatData m_linearMotorERP;
  public btVector3FloatData m_linearMotorCFM;
  public btVector3FloatData m_linearTargetVelocity;
  public btVector3FloatData m_linearMaxMotorForce;
  public btVector3FloatData m_linearServoTarget;
  public btVector3FloatData m_linearSpringStiffness;
  public btVector3FloatData m_linearSpringDamping;
  public btVector3FloatData m_linearEquilibriumPoint;
  public rawarray{char, 4} m_linearEnableMotor;
  public rawarray{char, 4} m_linearServoMotor;
  public rawarray{char, 4} m_linearEnableSpring;
  public rawarray{char, 4} m_linearSpringStiffnessLimited;
  public rawarray{char, 4} m_linearSpringDampingLimited;
  public rawarray{char, 4} m_padding1;
  public btVector3FloatData m_angularUpperLimit;
  public btVector3FloatData m_angularLowerLimit;
  public btVector3FloatData m_angularBounce;
  public btVector3FloatData m_angularStopERP;
  public btVector3FloatData m_angularStopCFM;
  public btVector3FloatData m_angularMotorERP;
  public btVector3FloatData m_angularMotorCFM;
  public btVector3FloatData m_angularTargetVelocity;
  public btVector3FloatData m_angularMaxMotorForce;
  public btVector3FloatData m_angularServoTarget;
  public btVector3FloatData m_angularSpringStiffness;
  public btVector3FloatData m_angularSpringDamping;
  public btVector3FloatData m_angularEquilibriumPoint;
  public rawarray{char, 4} m_angularEnableMotor;
  public rawarray{char, 4} m_angularServoMotor;
  public rawarray{char, 4} m_angularEnableSpring;
  public rawarray{char, 4} m_angularSpringStiffnessLimited;
  public rawarray{char, 4} m_angularSpringDampingLimited;
  public int m_rotateOrder;
}
public pure struct extern "::btGeneric6DofSpring2ConstraintDoubleData2" btGeneric6DofSpring2ConstraintDoubleData2 {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public btVector3DoubleData m_linearUpperLimit;
  public btVector3DoubleData m_linearLowerLimit;
  public btVector3DoubleData m_linearBounce;
  public btVector3DoubleData m_linearStopERP;
  public btVector3DoubleData m_linearStopCFM;
  public btVector3DoubleData m_linearMotorERP;
  public btVector3DoubleData m_linearMotorCFM;
  public btVector3DoubleData m_linearTargetVelocity;
  public btVector3DoubleData m_linearMaxMotorForce;
  public btVector3DoubleData m_linearServoTarget;
  public btVector3DoubleData m_linearSpringStiffness;
  public btVector3DoubleData m_linearSpringDamping;
  public btVector3DoubleData m_linearEquilibriumPoint;
  public rawarray{char, 4} m_linearEnableMotor;
  public rawarray{char, 4} m_linearServoMotor;
  public rawarray{char, 4} m_linearEnableSpring;
  public rawarray{char, 4} m_linearSpringStiffnessLimited;
  public rawarray{char, 4} m_linearSpringDampingLimited;
  public rawarray{char, 4} m_padding1;
  public btVector3DoubleData m_angularUpperLimit;
  public btVector3DoubleData m_angularLowerLimit;
  public btVector3DoubleData m_angularBounce;
  public btVector3DoubleData m_angularStopERP;
  public btVector3DoubleData m_angularStopCFM;
  public btVector3DoubleData m_angularMotorERP;
  public btVector3DoubleData m_angularMotorCFM;
  public btVector3DoubleData m_angularTargetVelocity;
  public btVector3DoubleData m_angularMaxMotorForce;
  public btVector3DoubleData m_angularServoTarget;
  public btVector3DoubleData m_angularSpringStiffness;
  public btVector3DoubleData m_angularSpringDamping;
  public btVector3DoubleData m_angularEquilibriumPoint;
  public rawarray{char, 4} m_angularEnableMotor;
  public rawarray{char, 4} m_angularServoMotor;
  public rawarray{char, 4} m_angularEnableSpring;
  public rawarray{char, 4} m_angularSpringStiffnessLimited;
  public rawarray{char, 4} m_angularSpringDampingLimited;
  public int m_rotateOrder;
}
public pure struct extern "::btGeneric6DofSpringConstraint" "nodefault" btGeneric6DofSpringConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4)  {
  public metafunction __base__ {btGeneric6DofConstraint, btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "enableSpring" void enableSpring(int index_0, bool onOff_1);
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getUid" int getUid() const;
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDamping" void setDamping(int index_0, btScalar damping_1);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint0();
  public function extern "setEquilibriumPoint" void setEquilibriumPoint1(int index_0);
  public function extern "setEquilibriumPoint" void setEquilibriumPoint2(int index_0, btScalar val_1);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setStiffness" void setStiffness(int index_0, btScalar stiffness_1);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public bool m_useSolveConstraintObsolete;
  public int m_objectType;
}
public pure struct extern "::btGeneric6DofSpringConstraintData" btGeneric6DofSpringConstraintData {
  public btGeneric6DofConstraintData m_6dofData;
  public rawarray{int, 6} m_springEnabled;
  public rawarray{float, 6} m_equilibriumPoint;
  public rawarray{float, 6} m_springStiffness;
  public rawarray{float, 6} m_springDamping;
}
public pure struct extern "::btGeneric6DofSpringConstraintDoubleData2" btGeneric6DofSpringConstraintDoubleData2 {
  public btGeneric6DofConstraintDoubleData2 m_6dofData;
  public rawarray{int, 6} m_springEnabled;
  public rawarray{double, 6} m_equilibriumPoint;
  public rawarray{double, 6} m_springStiffness;
  public rawarray{double, 6} m_springDamping;
}
public pure struct extern "::btGeometryUtil" btGeometryUtil {
}
public pure struct extern "::btGhostObject" "nonmovable" btGhostObject {
  public metafunction __base__ {btCollisionObject};
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "addOverlappingObjectInternal" void addOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btBroadphaseProxy} thisProxy_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co_0) const;
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& convexFromWorld_1, btTransform const& convexToWorld_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getNumOverlappingObjects" int getNumOverlappingObjects() const;
  public function extern "getOverlappingObject" rptr{btCollisionObject} getOverlappingObject(int index_0);
  public function extern "getOverlappingObject" crptr{btCollisionObject} cgetOverlappingObject(int index_0) const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "isActive" bool isActive() const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "removeOverlappingObjectInternal" void removeOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btDispatcher} dispatcher_1, rptr{btBroadphaseProxy} thisProxy_2);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "setIgnoreCollisionCheck" void setIgnoreCollisionCheck(crptr{btCollisionObject} co_0, bool ignoreCollisionCheck_1);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
}
public pure struct extern "::btGhostPairCallback" "nonmovable" btGhostPairCallback {
  public metafunction __base__ {btOverlappingPairCallback};
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
}
public pure struct extern "::btGjkCollisionDescription" btGjkCollisionDescription {
  public btVector3 m_firstDir;
  public int m_maxGjkIterations;
  public btScalar m_maximumDistanceSquared;
  public btScalar m_gjkRelError2;
}
public pure struct extern "::btGjkConvexCast" "nodefault" btGjkConvexCast(crptr{btConvexShape} convexA_0, crptr{btConvexShape} convexB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2)  {
  public metafunction __base__ {btConvexCast};
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public pure struct extern "::btGjkEpaPenetrationDepthSolver" "nonmovable" btGjkEpaPenetrationDepthSolver {
  public metafunction __base__ {btConvexPenetrationDepthSolver};
  public function extern "calcPenDepth" bool calcPenDepth(btVoronoiSimplexSolver mutable& simplexSolver_0, crptr{btConvexShape} convexA_1, crptr{btConvexShape} convexB_2, btTransform const& transA_3, btTransform const& transB_4, btVector3 mutable& v_5, btVector3 mutable& pa_6, btVector3 mutable& pb_7, rptr{btIDebugDraw} debugDraw_8);
}
public pure struct extern "::btGjkEpaSolver2" btGjkEpaSolver2 {
}
public pure struct extern "::btGjkEpaSolver3" btGjkEpaSolver3 {
}
public pure struct extern "::btGjkPairDetector" "nodefault" btGjkPairDetector(crptr{btConvexShape} objectA_0, crptr{btConvexShape} objectB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3)  {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface};
  public function extern "getCachedSeparatingAxis" btVector3 const& getCachedSeparatingAxis() const;
  public function extern "getCachedSeparatingDistance" btScalar getCachedSeparatingDistance() const;
  public function extern "getClosestPoints" void getClosestPoints(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2, bool swapResults_3);
  public function extern "getClosestPointsNonVirtual" void getClosestPointsNonVirtual(btDiscreteCollisionDetectorInterface_ClosestPointInput const& input_0, btDiscreteCollisionDetectorInterface_Result mutable& output_1, rptr{btIDebugDraw} debugDraw_2);
  public function extern "setCachedSeperatingAxis" void setCachedSeperatingAxis(btVector3 const& seperatingAxis_0);
  public function extern "setIgnoreMargin" void setIgnoreMargin(bool ignoreMargin_0);
  public function extern "setMinkowskiA" void setMinkowskiA(crptr{btConvexShape} minkA_0);
  public function extern "setMinkowskiB" void setMinkowskiB(crptr{btConvexShape} minkB_0);
  public function extern "setPenetrationDepthSolver" void setPenetrationDepthSolver(rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_0);
  public int m_lastUsedMethod;
  public int m_curIter;
  public int m_degenerateSimplex;
  public int m_catchDegeneracies;
  public int m_fixContactNormalDirection;
}
public pure struct extern "::btHashInt" "nodefault" btHashInt(int uid_0)  {
  public function extern "equals" bool equals(btHashInt const& other_0) const;
  public function extern "getHash" uint getHash() const;
  public function extern "getUid1" int getUid1() const;
  public function extern "setUid1" void setUid1(int uid_0);
}
public pure struct extern "::btHashMap<btHashInt, btTriangleInfo>" btHashMap_btHashInt_btTriangleInfo {
  public function extern "clear" void clear();
  public function extern "find" rptr{btTriangleInfo} find(btHashInt const& key_0);
  public function extern "find" crptr{btTriangleInfo} cfind(btHashInt const& key_0) const;
  public function extern "findIndex" int findIndex(btHashInt const& key_0) const;
  public function extern "getAtIndex" rptr{btTriangleInfo} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{btTriangleInfo} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashInt const& key_0, btTriangleInfo const& value_1);
  public function extern "remove" void remove(btHashInt const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashInt, int>" btHashMap_btHashInt_int {
  public function extern "clear" void clear();
  public function extern "find" rptr{int} find(btHashInt const& key_0);
  public function extern "find" crptr{int} cfind(btHashInt const& key_0) const;
  public function extern "findIndex" int findIndex(btHashInt const& key_0) const;
  public function extern "getAtIndex" rptr{int} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{int} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashInt const& key_0, int const& value_1);
  public function extern "remove" void remove(btHashInt const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, btCollisionObject *>" btHashMap_btHashPtr_btCollisionObject_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{btCollisionObject}} find(btHashPtr const& key_0);
  public function extern "find" crptr{rptr{btCollisionObject}} cfind(btHashPtr const& key_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{btCollisionObject}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btCollisionObject}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btCollisionObject} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, btCollisionShape *>" btHashMap_btHashPtr_btCollisionShape_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{btCollisionShape}} find(btHashPtr const& key_0);
  public function extern "find" crptr{rptr{btCollisionShape}} cfind(btHashPtr const& key_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{btCollisionShape}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btCollisionShape}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btCollisionShape} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, btOptimizedBvh *>" btHashMap_btHashPtr_btOptimizedBvh_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{btOptimizedBvh}} find(btHashPtr const& key_0);
  public function extern "find" crptr{rptr{btOptimizedBvh}} cfind(btHashPtr const& key_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{btOptimizedBvh}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btOptimizedBvh}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{btOptimizedBvh} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, btPointerUid>" btHashMap_btHashPtr_btPointerUid {
  public function extern "clear" void clear();
  public function extern "find" rptr{btPointerUid} find(btHashPtr const& key_0);
  public function extern "find" crptr{btPointerUid} cfind(btHashPtr const& key_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{btPointerUid} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{btPointerUid} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashPtr const& key_0, btPointerUid const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, btTriangleInfoMap *>" btHashMap_btHashPtr_btTriangleInfoMap_p {
  public function extern "clear" void clear();
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, const char *>" btHashMap_btHashPtr_const_char_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{crptr{char}} find(btHashPtr const& key_0);
  public function extern "find" crptr{crptr{char}} cfind(btHashPtr const& key_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{crptr{char}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{crptr{char}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashPtr const& key_0, crptr{char} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashPtr, void *>" btHashMap_btHashPtr_void_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{void}} find(btHashPtr const& key_0);
  public function extern "find" crptr{rptr{void}} cfind(btHashPtr const& key_0) const;
  public function extern "findIndex" int findIndex(btHashPtr const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{void}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{void}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashPtr const& key_0, rptr{void} const& value_1);
  public function extern "remove" void remove(btHashPtr const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashString, btCollisionObject *>" btHashMap_btHashString_btCollisionObject_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{btCollisionObject}} find(btHashString const& key_0);
  public function extern "find" crptr{rptr{btCollisionObject}} cfind(btHashString const& key_0) const;
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{btCollisionObject}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btCollisionObject}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashString const& key_0, rptr{btCollisionObject} const& value_1);
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashString, btCollisionShape *>" btHashMap_btHashString_btCollisionShape_p {
  public function extern "clear" void clear();
  public function extern "find" rptr{rptr{btCollisionShape}} find(btHashString const& key_0);
  public function extern "find" crptr{rptr{btCollisionShape}} cfind(btHashString const& key_0) const;
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "getAtIndex" rptr{rptr{btCollisionShape}} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{rptr{btCollisionShape}} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashString const& key_0, rptr{btCollisionShape} const& value_1);
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashMap<btHashString, int>" btHashMap_btHashString_int {
  public function extern "clear" void clear();
  public function extern "find" rptr{int} find(btHashString const& key_0);
  public function extern "find" crptr{int} cfind(btHashString const& key_0) const;
  public function extern "findIndex" int findIndex(btHashString const& key_0) const;
  public function extern "getAtIndex" rptr{int} getAtIndex(int index_0);
  public function extern "getAtIndex" crptr{int} cgetAtIndex(int index_0) const;
  public function extern "insert" void insert(btHashString const& key_0, int const& value_1);
  public function extern "remove" void remove(btHashString const& key_0);
  public function extern "size" int size() const;
}
public pure struct extern "::btHashPtr" "nodefault" btHashPtr(crptr{void} ptr_0)  {
  public function extern "equals" bool equals(btHashPtr const& other_0) const;
  public function extern "getHash" uint getHash() const;
  public function extern "getPointer" crptr{void} getPointer() const;
}
public pure struct extern "::btHashString" "nodefault" btHashString(crptr{char} name_0)  {
  public function extern "equals" bool equals(btHashString const& other_0) const;
  public function extern "getHash" uint getHash() const;
  public function extern "portableStringCompare" int portableStringCompare(crptr{char} src_0, crptr{char} dst_1) const;
  public crptr{char} m_string;
  public uint m_hash;
}
public pure struct extern "::btHashedOverlappingPairCache" "nonmovable" btHashedOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCache, btOverlappingPairCallback};
  public function extern "GetCount" int GetCount() const;
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1) const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
}
public pure struct extern "::btHashedSimplePairCache" "nonmovable" btHashedSimplePairCache {
  public function extern "GetCount" int GetCount() const;
  public function extern "addOverlappingPair" rptr{btSimplePair} addOverlappingPair(int indexA_0, int indexB_1);
  public function extern "findPair" rptr{btSimplePair} findPair(int indexA_0, int indexB_1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btSimplePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btSimplePair} cgetOverlappingPairArrayPtr() const;
  public function extern "removeAllPairs" void removeAllPairs();
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(int indexA_0, int indexB_1);
}
public pure struct extern "::btHeightfieldTerrainShape" "nodefault" btHeightfieldTerrainShape(int heightStickWidth_0, int heightStickLength_1, crptr{void} heightfieldData_2, btScalar heightScale_3, btScalar minHeight_4, btScalar maxHeight_5, int upAxis_6, PHY_ScalarType heightDataType_7, bool flipQuadEdges_8)  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUseDiamondSubdivision" void setUseDiamondSubdivision(bool useDiamondSubdivision_0);
  public function extern "setUseZigzagSubdivision" void setUseZigzagSubdivision(bool useZigzagSubdivision_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btHingeAccumulatedAngleConstraint" "nodefault" btHingeAccumulatedAngleConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3, btVector3 const& axisInA_4, btVector3 const& axisInB_5, bool useReferenceFrameA_6)  {
  public metafunction __base__ {btHingeConstraint, btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableAngularMotor" void enableAngularMotor(bool enableMotor_0, btScalar targetVelocity_1, btScalar maxMotorImpulse_2);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "enableMotor" void enableMotor(bool enableMotor_0);
  public function extern "getAFrame" btTransform mutable& getAFrame();
  public function extern "getAFrame" btTransform const& cgetAFrame() const;
  public function extern "getAccumulatedHingeAngle" btScalar getAccumulatedHingeAngle();
  public function extern "getAngularOnly" bool getAngularOnly();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBFrame" btTransform mutable& getBFrame();
  public function extern "getBFrame" btTransform const& cgetBFrame() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getEnableAngularMotor" bool getEnableAngularMotor();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getHingeAngle" btScalar getHingeAngle0();
  public function extern "getHingeAngle" btScalar getHingeAngle2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2Internal" void getInfo2Internal(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getInfo2InternalUsingFrameOffset" void getInfo2InternalUsingFrameOffset(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLimitSign" btScalar getLimitSign();
  public function extern "getLowerLimit" btScalar getLowerLimit() const;
  public function extern "getMaxMotorImpulse" btScalar getMaxMotorImpulse();
  public function extern "getMotorTargetVelosity" btScalar getMotorTargetVelosity();
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getSolveLimit" int getSolveLimit();
  public function extern "getUid" int getUid() const;
  public function extern "getUpperLimit" btScalar getUpperLimit() const;
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "hasLimit" bool hasLimit() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAccumulatedHingeAngle" void setAccumulatedHingeAngle(btScalar accAngle_0);
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly_0);
  public function extern "setAxis" void setAxis(btVector3 mutable& axisInA_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLimit" void setLimit(btScalar low_0, btScalar high_1, btScalar _softness_2, btScalar _biasFactor_3, btScalar _relaxationFactor_4);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse_0);
  public function extern "setMotorTarget" void setMotorTarget_btQuaternion_btScalar(btQuaternion const& qAinB_0, btScalar dt_1);
  public function extern "setMotorTarget" void setMotorTarget_btScalar_btScalar(btScalar targetAngle_0, btScalar dt_1);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "testLimit" void testLimit(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public int m_objectType;
}
public pure struct extern "::btHingeConstraint" "nodefault" btHingeConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3, btVector3 const& axisInA_4, btVector3 const& axisInB_5, bool useReferenceFrameA_6)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableAngularMotor" void enableAngularMotor(bool enableMotor_0, btScalar targetVelocity_1, btScalar maxMotorImpulse_2);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "enableMotor" void enableMotor(bool enableMotor_0);
  public function extern "getAFrame" btTransform mutable& getAFrame();
  public function extern "getAFrame" btTransform const& cgetAFrame() const;
  public function extern "getAngularOnly" bool getAngularOnly();
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBFrame" btTransform mutable& getBFrame();
  public function extern "getBFrame" btTransform const& cgetBFrame() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getEnableAngularMotor" bool getEnableAngularMotor();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getHingeAngle" btScalar getHingeAngle0();
  public function extern "getHingeAngle" btScalar getHingeAngle2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2Internal" void getInfo2Internal(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getInfo2InternalUsingFrameOffset" void getInfo2InternalUsingFrameOffset(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& angVelA_3, btVector3 const& angVelB_4);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLimitSign" btScalar getLimitSign();
  public function extern "getLowerLimit" btScalar getLowerLimit() const;
  public function extern "getMaxMotorImpulse" btScalar getMaxMotorImpulse();
  public function extern "getMotorTargetVelosity" btScalar getMotorTargetVelosity();
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getSolveLimit" int getSolveLimit();
  public function extern "getUid" int getUid() const;
  public function extern "getUpperLimit" btScalar getUpperLimit() const;
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "hasLimit" bool hasLimit() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAngularOnly" void setAngularOnly(bool angularOnly_0);
  public function extern "setAxis" void setAxis(btVector3 mutable& axisInA_0);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLimit" void setLimit(btScalar low_0, btScalar high_1, btScalar _softness_2, btScalar _biasFactor_3, btScalar _relaxationFactor_4);
  public function extern "setMaxMotorImpulse" void setMaxMotorImpulse(btScalar maxMotorImpulse_0);
  public function extern "setMotorTarget" void setMotorTarget_btQuaternion_btScalar(btQuaternion const& qAinB_0, btScalar dt_1);
  public function extern "setMotorTarget" void setMotorTarget_btScalar_btScalar(btScalar targetAngle_0, btScalar dt_1);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "testLimit" void testLimit(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public int m_objectType;
}
public pure struct extern "::btHingeConstraintDoubleData" btHingeConstraintDoubleData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public int m_useReferenceFrameA;
  public int m_angularOnly;
  public int m_enableAngularMotor;
  public float m_motorTargetVelocity;
  public float m_maxMotorImpulse;
  public float m_lowerLimit;
  public float m_upperLimit;
  public float m_limitSoftness;
  public float m_biasFactor;
  public float m_relaxationFactor;
}
public pure struct extern "::btHingeConstraintDoubleData2" btHingeConstraintDoubleData2 {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public int m_useReferenceFrameA;
  public int m_angularOnly;
  public int m_enableAngularMotor;
  public double m_motorTargetVelocity;
  public double m_maxMotorImpulse;
  public double m_lowerLimit;
  public double m_upperLimit;
  public double m_limitSoftness;
  public double m_biasFactor;
  public double m_relaxationFactor;
  public rawarray{char, 4} m_padding1;
}
public pure struct extern "::btHingeConstraintFloatData" btHingeConstraintFloatData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public int m_useReferenceFrameA;
  public int m_angularOnly;
  public int m_enableAngularMotor;
  public float m_motorTargetVelocity;
  public float m_maxMotorImpulse;
  public float m_lowerLimit;
  public float m_upperLimit;
  public float m_limitSoftness;
  public float m_biasFactor;
  public float m_relaxationFactor;
}
public pure tsvaluetype struct extern "::btHingeFlags" "extenum" btHingeFlags { }
public extern "BT_HINGE_FLAGS_CFM_STOP" btHingeFlags btHingeFlags_BT_HINGE_FLAGS_CFM_STOP;
public extern "BT_HINGE_FLAGS_ERP_STOP" btHingeFlags btHingeFlags_BT_HINGE_FLAGS_ERP_STOP;
public extern "BT_HINGE_FLAGS_CFM_NORM" btHingeFlags btHingeFlags_BT_HINGE_FLAGS_CFM_NORM;
public extern "BT_HINGE_FLAGS_ERP_NORM" btHingeFlags btHingeFlags_BT_HINGE_FLAGS_ERP_NORM;
public pure struct extern "::btIDebugDraw" "nonmovable" btIDebugDraw {
  public function extern "draw3dText" void draw3dText(btVector3 const& location_0, crptr{char} textString_1);
  public function extern "drawAabb" void drawAabb(btVector3 const& from_0, btVector3 const& to_1, btVector3 const& color_2);
  public function extern "drawArc" void drawArc(btVector3 const& center_0, btVector3 const& normal_1, btVector3 const& axis_2, btScalar radiusA_3, btScalar radiusB_4, btScalar minAngle_5, btScalar maxAngle_6, btVector3 const& color_7, bool drawSect_8, btScalar stepDegrees_9);
  public function extern "drawBox" void drawBox3(btVector3 const& bbMin_0, btVector3 const& bbMax_1, btVector3 const& color_2);
  public function extern "drawBox" void drawBox4(btVector3 const& bbMin_0, btVector3 const& bbMax_1, btTransform const& trans_2, btVector3 const& color_3);
  public function extern "drawCapsule" void drawCapsule(btScalar radius_0, btScalar halfHeight_1, int upAxis_2, btTransform const& transform_3, btVector3 const& color_4);
  public function extern "drawCone" void drawCone(btScalar radius_0, btScalar height_1, int upAxis_2, btTransform const& transform_3, btVector3 const& color_4);
  public function extern "drawContactPoint" void drawContactPoint(btVector3 const& PointOnB_0, btVector3 const& normalOnB_1, btScalar distance_2, int lifeTime_3, btVector3 const& color_4);
  public function extern "drawCylinder" void drawCylinder(btScalar radius_0, btScalar halfHeight_1, int upAxis_2, btTransform const& transform_3, btVector3 const& color_4);
  public function extern "drawLine" void drawLine3(btVector3 const& from_0, btVector3 const& to_1, btVector3 const& color_2);
  public function extern "drawLine" void drawLine4(btVector3 const& from_0, btVector3 const& to_1, btVector3 const& fromColor_2, btVector3 const& toColor_3);
  public function extern "drawPlane" void drawPlane(btVector3 const& planeNormal_0, btScalar planeConst_1, btTransform const& transform_2, btVector3 const& color_3);
  public function extern "drawSphere" void drawSphere_btScalar_btTransform_btVector3(btScalar radius_0, btTransform const& transform_1, btVector3 const& color_2);
  public function extern "drawSphere" void drawSphere_btVector3_btScalar_btVector3(btVector3 const& p_0, btScalar radius_1, btVector3 const& color_2);
  public function extern "drawSpherePatch" void drawSpherePatch(btVector3 const& center_0, btVector3 const& up_1, btVector3 const& axis_2, btScalar radius_3, btScalar minTh_4, btScalar maxTh_5, btScalar minPs_6, btScalar maxPs_7, btVector3 const& color_8, btScalar stepDegrees_9, bool drawCenter_10);
  public function extern "drawTransform" void drawTransform(btTransform const& transform_0, btScalar orthoLen_1);
  public function extern "drawTriangle" void drawTriangle5(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2, btVector3 const& color_3, btScalar _4);
  public function extern "drawTriangle" void drawTriangle8(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2, btVector3 const& _3, btVector3 const& _4, btVector3 const& _5, btVector3 const& color_6, btScalar alpha_7);
  public function extern "flushLines" void flushLines();
  public function extern "getDebugMode" int getDebugMode() const;
  public function extern "reportErrorWarning" void reportErrorWarning(crptr{char} warningString_0);
  public function extern "setDebugMode" void setDebugMode(int debugMode_0);
}
public pure struct extern "::btIndexedMesh" btIndexedMesh {
  public int m_numTriangles;
  public crptr{uchar} m_triangleIndexBase;
  public int m_triangleIndexStride;
  public int m_numVertices;
  public crptr{uchar} m_vertexBase;
  public int m_vertexStride;
  public PHY_ScalarType m_indexType;
  public PHY_ScalarType m_vertexType;
}
public pure struct extern "::btInfMaskConverter" "nodefault" btInfMaskConverter(int mask_0)  {
}
public pure struct extern "::btIntIndexData" btIntIndexData {
  public int m_value;
}
public pure struct extern "::btIntSortPredicate" btIntSortPredicate {
}
public pure tsvaluetype struct extern "::btInternalEdgeAdjustFlags" "extenum" btInternalEdgeAdjustFlags { }
public extern "BT_TRIANGLE_CONVEX_BACKFACE_MODE" btInternalEdgeAdjustFlags btInternalEdgeAdjustFlags_BT_TRIANGLE_CONVEX_BACKFACE_MODE;
public extern "BT_TRIANGLE_CONCAVE_DOUBLE_SIDED" btInternalEdgeAdjustFlags btInternalEdgeAdjustFlags_BT_TRIANGLE_CONCAVE_DOUBLE_SIDED;
public extern "BT_TRIANGLE_CONVEX_DOUBLE_SIDED" btInternalEdgeAdjustFlags btInternalEdgeAdjustFlags_BT_TRIANGLE_CONVEX_DOUBLE_SIDED;
public metafunction btInternalTickCallback rptr{m::list{void, rptr{btDynamicsWorld}, btScalar}};
public pure struct extern "::btInternalTriangleIndexCallback" "nonmovable" btInternalTriangleIndexCallback {
  public function extern "internalProcessTriangleIndex" void internalProcessTriangleIndex(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
}
public pure struct extern "::btJacobianEntry" btJacobianEntry {
  public function extern "getDiagonal" btScalar getDiagonal() const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal2(btJacobianEntry const& jacB_0, btScalar const massInvA_1) const;
  public function extern "getNonDiagonal" btScalar getNonDiagonal3(btJacobianEntry const& jacB_0, btScalar const massInvA_1, btScalar const massInvB_2) const;
  public function extern "getRelativeVelocity" btScalar getRelativeVelocity(btVector3 const& linvelA_0, btVector3 const& angvelA_1, btVector3 const& linvelB_2, btVector3 const& angvelB_3);
  public btVector3 m_linearJointAxis;
  public btVector3 m_aJ;
  public btVector3 m_bJ;
  public btVector3 m_0MinvJt;
  public btVector3 m_1MinvJt;
  public btScalar m_Adiag;
}
public pure struct extern "::btJointFeedback" btJointFeedback {
  public btVector3 m_appliedForceBodyA;
  public btVector3 m_appliedTorqueBodyA;
  public btVector3 m_appliedForceBodyB;
  public btVector3 m_appliedTorqueBodyB;
}
public pure struct extern "::btKinematicCharacterController" "nodefault" btKinematicCharacterController(rptr{btPairCachingGhostObject} ghostObject_0, rptr{btConvexShape} convexShape_1, btScalar stepHeight_2, int upAxis_3)  {
  public metafunction __base__ {btCharacterControllerInterface, btActionInterface};
  public function extern "canJump" bool canJump() const;
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "getGhostObject" rptr{btPairCachingGhostObject} getGhostObject();
  public function extern "getGravity" btScalar getGravity() const;
  public function extern "getMaxSlope" btScalar getMaxSlope() const;
  public function extern "jump" void jump();
  public function extern "onGround" bool onGround() const;
  public function extern "playerStep" void playerStep(rptr{btCollisionWorld} collisionWorld_0, btScalar dt_1);
  public function extern "preStep" void preStep(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "reset" void reset(rptr{btCollisionWorld} collisionWorld_0);
  public function extern "setFallSpeed" void setFallSpeed(btScalar fallSpeed_0);
  public function extern "setGravity" void setGravity(btScalar gravity_0);
  public function extern "setJumpSpeed" void setJumpSpeed(btScalar jumpSpeed_0);
  public function extern "setMaxJumpHeight" void setMaxJumpHeight(btScalar maxJumpHeight_0);
  public function extern "setMaxSlope" void setMaxSlope(btScalar slopeRadians_0);
  public function extern "setUpAxis" void setUpAxis(int axis_0);
  public function extern "setUpInterpolate" void setUpInterpolate(bool value_0);
  public function extern "setUseGhostSweepTest" void setUseGhostSweepTest(bool useGhostObjectSweepTest_0);
  public function extern "setVelocityForTimeInterval" void setVelocityForTimeInterval(btVector3 const& velocity_0, btScalar timeInterval_1);
  public function extern "setWalkDirection" void setWalkDirection(btVector3 const& walkDirection_0);
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTimeStep_1);
  public function extern "warp" void warp(btVector3 const& origin_0);
}
public pure struct extern "::btManifoldPoint" btManifoldPoint {
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getDistance" btScalar getDistance() const;
  public function extern "getLifeTime" int getLifeTime() const;
  public function extern "getPositionWorldOnA" btVector3 const& getPositionWorldOnA() const;
  public function extern "getPositionWorldOnB" btVector3 const& getPositionWorldOnB() const;
  public function extern "setDistance" void setDistance(btScalar dist_0);
  public btVector3 m_localPointA;
  public btVector3 m_localPointB;
  public btVector3 m_positionWorldOnB;
  public btVector3 m_positionWorldOnA;
  public btVector3 m_normalWorldOnB;
  public btScalar m_distance1;
  public btScalar m_combinedFriction;
  public btScalar m_combinedRollingFriction;
  public btScalar m_combinedRestitution;
  public int m_partId0;
  public int m_partId1;
  public int m_index0;
  public int m_index1;
  public rptr{void} m_userPersistentData;
  public bool m_lateralFrictionInitialized;
  public btScalar m_appliedImpulse;
  public btScalar m_appliedImpulseLateral1;
  public btScalar m_appliedImpulseLateral2;
  public btScalar m_contactMotion1;
  public btScalar m_contactMotion2;
  public btScalar m_contactCFM1;
  public btScalar m_contactCFM2;
  public int m_lifeTime;
  public btVector3 m_lateralFrictionDir1;
  public btVector3 m_lateralFrictionDir2;
}
public pure struct extern "::btManifoldResult" "nonmovable" btManifoldResult {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public function extern "getBody0Internal" crptr{btCollisionObject} getBody0Internal() const;
  public function extern "getBody0Wrap" crptr{btCollisionObjectWrapper} getBody0Wrap() const;
  public function extern "getBody1Internal" crptr{btCollisionObject} getBody1Internal() const;
  public function extern "getBody1Wrap" crptr{btCollisionObjectWrapper} getBody1Wrap() const;
  public function extern "getPersistentManifold" rptr{btPersistentManifold} getPersistentManifold();
  public function extern "getPersistentManifold" crptr{btPersistentManifold} cgetPersistentManifold() const;
  public function extern "refreshContactPoints" void refreshContactPoints();
  public function extern "setBody0Wrap" void setBody0Wrap(crptr{btCollisionObjectWrapper} obj0Wrap_0);
  public function extern "setBody1Wrap" void setBody1Wrap(crptr{btCollisionObjectWrapper} obj1Wrap_0);
  public function extern "setPersistentManifold" void setPersistentManifold(rptr{btPersistentManifold} manifoldPtr_0);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
}
public pure struct extern "::btMaterial" btMaterial {
  public btScalar m_friction;
  public btScalar m_restitution;
  public rawarray{int, 2} pad;
}
public pure struct extern "::btMaterialProperties" btMaterialProperties {
  public int m_numMaterials;
  public crptr{uchar} m_materialBase;
  public int m_materialStride;
  public PHY_ScalarType m_materialType;
  public int m_numTriangles;
  public crptr{uchar} m_triangleMaterialsBase;
  public int m_triangleMaterialStride;
  public PHY_ScalarType m_triangleType;
}
public pure tsvaluetype struct extern "::btMatrix3x3" btMatrix3x3 {
  public function extern "absolute" btMatrix3x3 absolute() const;
  public function extern "adjoint" btMatrix3x3 adjoint() const;
  public function extern "cofac" btScalar cofac(int r1_0, int c1_1, int r2_2, int c2_3) const;
  public function extern "deSerialize" void deSerialize(btMatrix3x3FloatData const& dataIn_0);
  public function extern "deSerializeDouble" void deSerializeDouble(btMatrix3x3DoubleData const& dataIn_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btMatrix3x3FloatData const& dataIn_0);
  public function extern "determinant" btScalar determinant() const;
  public function extern "diagonalize" void diagonalize(btMatrix3x3 mutable& rot_0, btScalar threshold_1, int maxSteps_2);
  public function extern "getColumn" btVector3 getColumn(int i_0) const;
  public function extern "getEulerYPR" void getEulerYPR(btScalar mutable& yaw_0, btScalar mutable& pitch_1, btScalar mutable& roll_2) const;
  public function extern "getEulerZYX" void getEulerZYX(btScalar mutable& yaw_0, btScalar mutable& pitch_1, btScalar mutable& roll_2, uint solution_number_3) const;
  public function extern "getOpenGLSubMatrix" void getOpenGLSubMatrix(rptr{btScalar} m_0) const;
  public function extern "getRotation" void getRotation(btQuaternion mutable& q_0) const;
  public function extern "getRow" btVector3 const& getRow(int i_0) const;
  public function extern "inverse" btMatrix3x3 inverse() const;
  public function extern "scaled" btMatrix3x3 scaled(btVector3 const& s_0) const;
  public function extern "serialize" void serialize(btMatrix3x3FloatData mutable& dataOut_0) const;
  public function extern "serializeFloat" void serializeFloat(btMatrix3x3FloatData mutable& dataOut_0) const;
  public function extern "setEulerYPR" void setEulerYPR(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
  public function extern "setEulerZYX" void setEulerZYX(btScalar eulerX_0, btScalar eulerY_1, btScalar eulerZ_2);
  public function extern "setFromOpenGLSubMatrix" void setFromOpenGLSubMatrix(crptr{btScalar} m_0);
  public function extern "setIdentity" void setIdentity();
  public function extern "setRotation" void setRotation(btQuaternion const& q_0);
  public function extern "setValue" void setValue(btScalar const& xx_0, btScalar const& xy_1, btScalar const& xz_2, btScalar const& yx_3, btScalar const& yy_4, btScalar const& yz_5, btScalar const& zx_6, btScalar const& zy_7, btScalar const& zz_8);
  public function extern "solve33" btVector3 solve33(btVector3 const& b_0) const;
  public function extern "tdotx" btScalar tdotx(btVector3 const& v_0) const;
  public function extern "tdoty" btScalar tdoty(btVector3 const& v_0) const;
  public function extern "tdotz" btScalar tdotz(btVector3 const& v_0) const;
  public function extern "timesTranspose" btMatrix3x3 timesTranspose(btMatrix3x3 const& m_0) const;
  public function extern "transpose" btMatrix3x3 transpose() const;
  public function extern "transposeTimes" btMatrix3x3 transposeTimes(btMatrix3x3 const& m_0) const;
}
public pure struct extern "::btMatrix3x3DoubleData" btMatrix3x3DoubleData {
  public rawarray{btVector3DoubleData, 3} m_el;
}
public pure struct extern "::btMatrix3x3FloatData" btMatrix3x3FloatData {
  public rawarray{btVector3FloatData, 3} m_el;
}
public pure struct extern "::btMatrixX<double>" btMatrixX_double {
  public function extern "addElem" void addElem(int row_0, int col_1, double val_2);
  public function extern "cols" int cols() const;
  public function extern "copyLowerToUpperTriangle" void copyLowerToUpperTriangle();
  public function extern "getBufferPointer" crptr{double} getBufferPointer() const;
  public function extern "getBufferPointerWritable" rptr{double} getBufferPointerWritable();
  public function extern "mulElem" void mulElem(int row_0, int col_1, double val_2);
  public function extern "multiply2_p8r" void multiply2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "multiplyAdd2_p8r" void multiplyAdd2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "printMatrix" void printMatrix(crptr{char} msg_0);
  public function extern "resize" void resize(int rows_0, int cols_1);
  public function extern "rowComputeNonZeroElements" void rowComputeNonZeroElements() const;
  public function extern "rows" int rows() const;
  public function extern "setElem" void setElem(int row_0, int col_1, double val_2);
  public function extern "setIdentity" void setIdentity();
  public function extern "setSubMatrix" void setSubMatrix_int_int_int_int_double(int rowstart_0, int colstart_1, int rowend_2, int colend_3, double const value_4);
  public function extern "setZero" void setZero();
  public int m_rows;
  public int m_cols;
  public int m_operations;
  public int m_resizeOperations;
  public int m_setElemOperations;
}
public pure struct extern "::btMatrixX<float>" btMatrixX_float {
  public function extern "addElem" void addElem(int row_0, int col_1, float val_2);
  public function extern "cols" int cols() const;
  public function extern "copyLowerToUpperTriangle" void copyLowerToUpperTriangle();
  public function extern "getBufferPointer" crptr{float} getBufferPointer() const;
  public function extern "getBufferPointerWritable" rptr{float} getBufferPointerWritable();
  public function extern "mulElem" void mulElem(int row_0, int col_1, float val_2);
  public function extern "multiply2_p8r" void multiply2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "multiplyAdd2_p8r" void multiplyAdd2_p8r(crptr{btScalar} B_0, crptr{btScalar} C_1, int numRows_2, int numRowsOther_3, int row_4, int col_5);
  public function extern "printMatrix" void printMatrix(crptr{char} msg_0);
  public function extern "resize" void resize(int rows_0, int cols_1);
  public function extern "rowComputeNonZeroElements" void rowComputeNonZeroElements() const;
  public function extern "rows" int rows() const;
  public function extern "setElem" void setElem(int row_0, int col_1, float val_2);
  public function extern "setIdentity" void setIdentity();
  public function extern "setSubMatrix" void setSubMatrix_int_int_int_int_float(int rowstart_0, int colstart_1, int rowend_2, int colend_3, float const value_4);
  public function extern "setZero" void setZero();
  public int m_rows;
  public int m_cols;
  public int m_operations;
  public int m_resizeOperations;
  public int m_setElemOperations;
}
public pure struct extern "::btMeshPartData" btMeshPartData {
  public rptr{btVector3FloatData} m_vertices3f;
  public rptr{btVector3DoubleData} m_vertices3d;
  public rptr{btIntIndexData} m_indices32;
  public rptr{btShortIntIndexTripletData} m_3indices16;
  public rptr{btCharIndexTripletData} m_3indices8;
  public rptr{btShortIntIndexData} m_indices16;
  public int m_numTriangles;
  public int m_numVertices;
}
public pure struct extern "::btMinkowskiPenetrationDepthSolver" "nonmovable" btMinkowskiPenetrationDepthSolver {
  public metafunction __base__ {btConvexPenetrationDepthSolver};
  public function extern "calcPenDepth" bool calcPenDepth(btVoronoiSimplexSolver mutable& simplexSolver_0, crptr{btConvexShape} convexA_1, crptr{btConvexShape} convexB_2, btTransform const& transA_3, btTransform const& transB_4, btVector3 mutable& v_5, btVector3 mutable& pa_6, btVector3 mutable& pb_7, rptr{btIDebugDraw} debugDraw_8);
}
public pure struct extern "::btMinkowskiSumShape" "nodefault" btMinkowskiSumShape(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "GetTransformB" btTransform const& GetTransformB() const;
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeA" crptr{btConvexShape} getShapeA() const;
  public function extern "getShapeB" crptr{btConvexShape} getShapeB() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getTransformA" btTransform const& getTransformA() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setTransformA" void setTransformA(btTransform const& transA_0);
  public function extern "setTransformB" void setTransformB(btTransform const& transB_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btMotionState" "nonmovable" btMotionState {
  public function extern "getWorldTransform" void getWorldTransform(btTransform mutable& worldTrans_0) const;
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
}
public pure struct extern "::btMprCollisionDescription" btMprCollisionDescription {
  public btVector3 m_firstDir;
  public int m_maxGjkIterations;
  public btScalar m_maximumDistanceSquared;
  public btScalar m_gjkRelError2;
}
public pure struct extern "::btMprDistanceInfo" btMprDistanceInfo {
  public btVector3 m_pointOnA;
  public btVector3 m_pointOnB;
  public btVector3 m_normalBtoA;
  public btScalar m_distance;
}
public pure struct extern "::btMultiSapBroadphase" "nodefault" btMultiSapBroadphase(int maxProxies_0, rptr{btOverlappingPairCache} pairCache_1)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "addToChildBroadphase" void addToChildBroadphase(rptr{btMultiSapBroadphase_btMultiSapProxy} parentMultiSapProxy_0, rptr{btBroadphaseProxy} childProxy_1, rptr{btBroadphaseInterface} childBroadphase_2);
  public function extern "buildTree" void buildTree(btVector3 const& bvhAabbMin_0, btVector3 const& bvhAabbMax_1);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "printStats" void printStats();
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
}
public pure struct extern "::btMultiSapBroadphase::btMultiSapProxy" "nodefault" btMultiSapBroadphase_btMultiSapProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5)  {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "getUid" int getUid() const;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
  public int m_shapeType;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
}
public pure struct extern "::btMultiSphereShape" "nodefault" btMultiSphereShape(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2)  {
  public metafunction __base__ {btConvexInternalAabbCachingShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getSphereCount" int getSphereCount() const;
  public function extern "getSpherePosition" btVector3 const& getSpherePosition(int index_0) const;
  public function extern "getSphereRadius" btScalar getSphereRadius(int index_0) const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btMultiSphereShapeData" btMultiSphereShapeData {
  public btConvexInternalShapeData m_convexInternalShapeData;
  public rptr{btPositionAndRadius} m_localPositionArrayPtr;
  public int m_localPositionArraySize;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btMultimaterialTriangleMeshShape" "nodefault" btMultimaterialTriangleMeshShape(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2)  {
  public metafunction __base__ {btBvhTriangleMeshShape, btTriangleMeshShape, btConcaveShape, btCollisionShape};
  public function extern "buildOptimizedBvh" void buildOptimizedBvh();
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMaterialProperties" crptr{btMaterial} getMaterialProperties(int partID_0, int triIndex_1);
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getOptimizedBvh" rptr{btOptimizedBvh} getOptimizedBvh();
  public function extern "getOwnsBvh" bool getOwnsBvh() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "partialRefitTree" void partialRefitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "performConvexcast" void performConvexcast(rptr{btTriangleCallback} callback_0, btVector3 const& boxSource_1, btVector3 const& boxTarget_2, btVector3 const& boxMin_3, btVector3 const& boxMax_4);
  public function extern "performRaycast" void performRaycast(rptr{btTriangleCallback} callback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2);
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "refitTree" void refitTree(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleBvh" void serializeSingleBvh(rptr{btSerializer} serializer_0) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "serializeSingleTriangleInfoMap" void serializeSingleTriangleInfoMap(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setOptimizedBvh" void setOptimizedBvh(rptr{btOptimizedBvh} bvh_0, btVector3 const& localScaling_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public function extern "usesQuantizedAabbCompression" bool usesQuantizedAabbCompression() const;
}
public pure struct extern "::btNNCGConstraintSolver" "nonmovable" btNNCGConstraintSolver {
  public metafunction __base__ {btSequentialImpulseConstraintSolver, btConstraintSolver};
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1);
  public function extern "btRand2" ulong btRand2();
  public function extern "btRandInt2" int btRandInt2(int n_0);
  public function extern "getActiveConstraintRowSolverGeneric" btSingleConstraintRowSolver getActiveConstraintRowSolverGeneric();
  public function extern "getActiveConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getActiveConstraintRowSolverLowerLimit();
  public function extern "getRandSeed" ulong getRandSeed() const;
  public function extern "getSSE2ConstraintRowSolverGeneric" btSingleConstraintRowSolver getSSE2ConstraintRowSolverGeneric();
  public function extern "getSSE2ConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getSSE2ConstraintRowSolverLowerLimit();
  public function extern "getSSE4_1ConstraintRowSolverGeneric" btSingleConstraintRowSolver getSSE4_1ConstraintRowSolverGeneric();
  public function extern "getSSE4_1ConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getSSE4_1ConstraintRowSolverLowerLimit();
  public function extern "getScalarConstraintRowSolverGeneric" btSingleConstraintRowSolver getScalarConstraintRowSolverGeneric();
  public function extern "getScalarConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getScalarConstraintRowSolverLowerLimit();
  public function extern "getSolverType" btConstraintSolverType getSolverType() const;
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "reset" void reset();
  public function extern "setConstraintRowSolverGeneric" void setConstraintRowSolverGeneric(btSingleConstraintRowSolver rowSolver_0);
  public function extern "setConstraintRowSolverLowerLimit" void setConstraintRowSolverLowerLimit(btSingleConstraintRowSolver rowSolver_0);
  public function extern "setRandSeed" void setRandSeed(ulong seed_0);
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifold_2, int numManifolds_3, rptr{rptr{btTypedConstraint}} constraints_4, int numConstraints_5, btContactSolverInfo const& info_6, rptr{btIDebugDraw} debugDrawer_7, rptr{btDispatcher} dispatcher_8);
  public bool m_onlyForNoneContact;
}
public metafunction btNearCallback rptr{m::list{void, rawref{btBroadphasePair}, rawref{btCollisionDispatcher}, crawref{btDispatcherInfo}, int}};
public pure struct extern "::btNodeOverlapCallback" "nonmovable" btNodeOverlapCallback {
  public function extern "processNode" void processNode(int subPart_0, int triangleIndex_1);
}
public pure struct extern "::btNullPairCache" "nonmovable" btNullPairCache {
  public metafunction __base__ {btOverlappingPairCache, btOverlappingPairCallback};
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
}
public pure struct extern "::btOptimizedBvh" "nonmovable" btOptimizedBvh {
  public metafunction __base__ {btQuantizedBvh};
  public function extern "build" void build(rptr{btStridingMeshInterface} triangles_0, bool useQuantizedAabbCompression_1, btVector3 const& bvhAabbMin_2, btVector3 const& bvhAabbMax_3);
  public function extern "buildInternal" void buildInternal();
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData_0);
  public function extern "isQuantized" bool isQuantized();
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out_0, btVector3 const& point2_1, int isMax_2) const;
  public function extern "refit" void refit(rptr{btStridingMeshInterface} triangles_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2);
  public function extern "refitPartial" void refitPartial(rptr{btStridingMeshInterface} triangles_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2);
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4) const;
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2) const;
  public function extern "serialize" crptr{char} serialize2(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serialize" bool serialize3(rptr{void} o_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2) const;
  public function extern "serializeInPlace" bool serializeInPlace(rptr{void} o_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2) const;
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin_0, btVector3 const& bvhAabbMax_1, btScalar quantizationMargin_2);
  public function extern "setTraversalMode" void setTraversalMode(btQuantizedBvh_btTraversalMode traversalMode_0);
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn_0) const;
  public function extern "updateBvhNodes" void updateBvhNodes(rptr{btStridingMeshInterface} meshInterface_0, int firstNode_1, int endNode_2, int index_3);
}
public pure struct extern "::btOptimizedBvhNode" btOptimizedBvhNode {
  public btVector3 m_aabbMinOrg;
  public btVector3 m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 20} m_padding;
}
public pure struct extern "::btOptimizedBvhNodeDoubleData" btOptimizedBvhNodeDoubleData {
  public btVector3DoubleData m_aabbMinOrg;
  public btVector3DoubleData m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 4} m_pad;
}
public pure struct extern "::btOptimizedBvhNodeFloatData" btOptimizedBvhNodeFloatData {
  public btVector3FloatData m_aabbMinOrg;
  public btVector3FloatData m_aabbMaxOrg;
  public int m_escapeIndex;
  public int m_subPart;
  public int m_triangleIndex;
  public rawarray{char, 4} m_pad;
}
public pure struct extern "::btOverlapCallback" "nonmovable" btOverlapCallback {
  public function extern "processOverlap" bool processOverlap(btBroadphasePair mutable& pair_0);
}
public pure struct extern "::btOverlapFilterCallback" "nonmovable" btOverlapFilterCallback {
  public function extern "needBroadphaseCollision" bool needBroadphaseCollision(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1) const;
}
public pure struct extern "::btOverlappingPairCache" "nonmovable" btOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCallback};
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
}
public pure struct extern "::btOverlappingPairCallback" "nonmovable" btOverlappingPairCallback {
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
}
public pure struct extern "::btPairCachingGhostObject" "nonmovable" btPairCachingGhostObject {
  public metafunction __base__ {btGhostObject, btCollisionObject};
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "addOverlappingObjectInternal" void addOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btBroadphaseProxy} thisProxy_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co_0) const;
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& convexFromWorld_1, btTransform const& convexToWorld_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getNumOverlappingObjects" int getNumOverlappingObjects() const;
  public function extern "getOverlappingObject" rptr{btCollisionObject} getOverlappingObject(int index_0);
  public function extern "getOverlappingObject" crptr{btCollisionObject} cgetOverlappingObject(int index_0) const;
  public function extern "getOverlappingPairCache" rptr{btHashedOverlappingPairCache} getOverlappingPairCache();
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "isActive" bool isActive() const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "removeOverlappingObjectInternal" void removeOverlappingObjectInternal(rptr{btBroadphaseProxy} otherProxy_0, rptr{btDispatcher} dispatcher_1, rptr{btBroadphaseProxy} thisProxy_2);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "setIgnoreCollisionCheck" void setIgnoreCollisionCheck(crptr{btCollisionObject} co_0, bool ignoreCollisionCheck_1);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
}
public pure struct extern "::btPersistentManifold" btPersistentManifold {
  public metafunction __base__ {btTypedObject};
  public function extern "addManifoldPoint" int addManifoldPoint(btManifoldPoint const& newPoint_0, bool isPredictive_1);
  public function extern "clearManifold" void clearManifold();
  public function extern "clearUserCache" void clearUserCache(btManifoldPoint mutable& pt_0);
  public function extern "getBody0" crptr{btCollisionObject} getBody0() const;
  public function extern "getBody1" crptr{btCollisionObject} getBody1() const;
  public function extern "getCacheEntry" int getCacheEntry(btManifoldPoint const& newPoint_0) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold() const;
  public function extern "getContactPoint" btManifoldPoint mutable& getContactPoint(int index_0);
  public function extern "getContactPoint" btManifoldPoint const& cgetContactPoint(int index_0) const;
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getNumContacts" int getNumContacts() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "refreshContactPoints" void refreshContactPoints(btTransform const& trA_0, btTransform const& trB_1);
  public function extern "removeContactPoint" void removeContactPoint(int index_0);
  public function extern "replaceContactPoint" void replaceContactPoint(btManifoldPoint const& newPoint_0, int insertIndex_1);
  public function extern "setBodies" void setBodies(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
  public function extern "setContactBreakingThreshold" void setContactBreakingThreshold(btScalar contactBreakingThreshold_0);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setNumContacts" void setNumContacts(int cachedPoints_0);
  public function extern "validContactDistance" bool validContactDistance(btManifoldPoint const& pt_0) const;
  public int m_companionIdA;
  public int m_companionIdB;
  public int m_index1a;
  public int m_objectType;
}
public pure struct extern "::btPoint2PointConstraint" "nodefault" btPoint2PointConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& body0_trans_1, btTransform const& body1_trans_2);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getPivotInA" btVector3 const& getPivotInA() const;
  public function extern "getPivotInB" btVector3 const& getPivotInB() const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getUid" int getUid() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setPivotA" void setPivotA(btVector3 const& pivotA_0);
  public function extern "setPivotB" void setPivotB(btVector3 const& pivotB_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public bool m_useSolveConstraintObsolete;
  public btConstraintSetting m_setting;
  public int m_objectType;
}
public pure struct extern "::btPoint2PointConstraintDoubleData" btPoint2PointConstraintDoubleData {
  public btTypedConstraintData m_typeConstraintData;
  public btVector3DoubleData m_pivotInA;
  public btVector3DoubleData m_pivotInB;
}
public pure struct extern "::btPoint2PointConstraintDoubleData2" btPoint2PointConstraintDoubleData2 {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btVector3DoubleData m_pivotInA;
  public btVector3DoubleData m_pivotInB;
}
public pure struct extern "::btPoint2PointConstraintFloatData" btPoint2PointConstraintFloatData {
  public btTypedConstraintData m_typeConstraintData;
  public btVector3FloatData m_pivotInA;
  public btVector3FloatData m_pivotInB;
}
public pure tsvaluetype struct extern "::btPoint2PointFlags" "extenum" btPoint2PointFlags { }
public extern "BT_P2P_FLAGS_ERP" btPoint2PointFlags btPoint2PointFlags_BT_P2P_FLAGS_ERP;
public extern "BT_P2P_FLAGS_CFM" btPoint2PointFlags btPoint2PointFlags_BT_P2P_FLAGS_CFM;
public pure struct extern "::btPointCollector" "nonmovable" btPointCollector {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
  public btVector3 m_normalOnBInWorld;
  public btVector3 m_pointInWorld;
  public btScalar m_distance;
  public bool m_hasResult;
}
public pure struct extern "::btPointerUid" btPointerUid {
}
public pure struct extern "::btPolarDecomposition" "nodefault" btPolarDecomposition(btScalar tolerance_0, uint maxIterations_1)  {
  public function extern "decompose" uint decompose(btMatrix3x3 const& a_0, btMatrix3x3 mutable& u_1, btMatrix3x3 mutable& h_2) const;
  public function extern "maxIterations" uint maxIterations() const;
}
public pure struct extern "::btPolyhedralContactClipping" btPolyhedralContactClipping {
}
public pure struct extern "::btPolyhedralConvexAabbCachingShape" "nonmovable" btPolyhedralConvexAabbCachingShape {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNonvirtualAabb" void getNonvirtualAabb(btTransform const& trans_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2, btScalar margin_3) const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btPolyhedralConvexShape" "nonmovable" btPolyhedralConvexShape {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btPoolAllocator" "nodefault" btPoolAllocator(int elemSize_0, int maxElements_1)  {
  public function extern "allocate" rptr{void} allocate(int size_0);
  public function extern "freeMemory" void freeMemory(rptr{void} ptr_0);
  public function extern "getElementSize" int getElementSize() const;
  public function extern "getFreeCount" int getFreeCount() const;
  public function extern "getMaxCount" int getMaxCount() const;
  public function extern "getPoolAddress" rptr{uchar} getPoolAddress();
  public function extern "getPoolAddress" crptr{uchar} cgetPoolAddress() const;
  public function extern "getUsedCount" int getUsedCount() const;
  public function extern "validPtr" bool validPtr(rptr{void} ptr_0);
}
public pure struct extern "::btPositionAndRadius" btPositionAndRadius {
  public btVector3FloatData m_pos;
  public float m_radius;
}
public pure struct extern "::btQuadWord" btQuadWord {
  public function extern "getX" btScalar const& getX() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "setMax" void setMax(btQuadWord const& other_0);
  public function extern "setMin" void setMin(btQuadWord const& other_0);
  public function extern "setValue" void setValue3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "setValue" void setValue4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "w" btScalar const& w() const;
  public function extern "x" btScalar const& x() const;
  public function extern "y" btScalar const& y() const;
  public function extern "z" btScalar const& z() const;
}
public pure struct extern "::btQuantizedBvh" "nonmovable" btQuantizedBvh {
  public function extern "buildInternal" void buildInternal();
  public function extern "calculateSerializeBufferSize" uint calculateSerializeBufferSize() const;
  public function extern "calculateSerializeBufferSizeNew" int calculateSerializeBufferSizeNew() const;
  public function extern "deSerializeDouble" void deSerializeDouble(btQuantizedBvhDoubleData mutable& quantizedBvhDoubleData_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btQuantizedBvhFloatData mutable& quantizedBvhFloatData_0);
  public function extern "isQuantized" bool isQuantized();
  public function extern "quantize" void quantize(rptr{ushort} out_0, btVector3 const& point_1, int isMax_2) const;
  public function extern "quantizeWithClamp" void quantizeWithClamp(rptr{ushort} out_0, btVector3 const& point2_1, int isMax_2) const;
  public function extern "reportAabbOverlappingNodex" void reportAabbOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "reportBoxCastOverlappingNodex" void reportBoxCastOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4) const;
  public function extern "reportRayOverlappingNodex" void reportRayOverlappingNodex(rptr{btNodeOverlapCallback} nodeCallback_0, btVector3 const& raySource_1, btVector3 const& rayTarget_2) const;
  public function extern "serialize" crptr{char} serialize2(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serialize" bool serialize3(rptr{void} o_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2) const;
  public function extern "setQuantizationValues" void setQuantizationValues(btVector3 const& bvhAabbMin_0, btVector3 const& bvhAabbMax_1, btScalar quantizationMargin_2);
  public function extern "setTraversalMode" void setTraversalMode(btQuantizedBvh_btTraversalMode traversalMode_0);
  public function extern "unQuantize" btVector3 unQuantize(crptr{ushort} vecIn_0) const;
}
public pure struct extern "::btQuantizedBvhDoubleData" btQuantizedBvhDoubleData {
  public btVector3DoubleData m_bvhAabbMin;
  public btVector3DoubleData m_bvhAabbMax;
  public btVector3DoubleData m_bvhQuantization;
  public int m_curNodeIndex;
  public int m_useQuantization;
  public int m_numContiguousLeafNodes;
  public int m_numQuantizedContiguousNodes;
  public rptr{btOptimizedBvhNodeDoubleData} m_contiguousNodesPtr;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public int m_traversalMode;
  public int m_numSubtreeHeaders;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
}
public pure struct extern "::btQuantizedBvhFloatData" btQuantizedBvhFloatData {
  public btVector3FloatData m_bvhAabbMin;
  public btVector3FloatData m_bvhAabbMax;
  public btVector3FloatData m_bvhQuantization;
  public int m_curNodeIndex;
  public int m_useQuantization;
  public int m_numContiguousLeafNodes;
  public int m_numQuantizedContiguousNodes;
  public rptr{btOptimizedBvhNodeFloatData} m_contiguousNodesPtr;
  public rptr{btQuantizedBvhNodeData} m_quantizedContiguousNodesPtr;
  public rptr{btBvhSubtreeInfoData} m_subTreeInfoPtr;
  public int m_traversalMode;
  public int m_numSubtreeHeaders;
}
public pure struct extern "::btQuantizedBvhNode" btQuantizedBvhNode {
  public function extern "getEscapeIndex" int getEscapeIndex() const;
  public function extern "getPartId" int getPartId() const;
  public function extern "getTriangleIndex" int getTriangleIndex() const;
  public function extern "isLeafNode" bool isLeafNode() const;
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_escapeIndexOrTriangleIndex;
}
public pure struct extern "::btQuantizedBvhNodeData" btQuantizedBvhNodeData {
  public rawarray{ushort, 3} m_quantizedAabbMin;
  public rawarray{ushort, 3} m_quantizedAabbMax;
  public int m_escapeIndexOrTriangleIndex;
}
public pure struct extern "::btQuaternion" btQuaternion {
  public metafunction __base__ {btQuadWord};
  public function extern "angle" btScalar angle(btQuaternion const& q_0) const;
  public function extern "angleShortestPath" btScalar angleShortestPath(btQuaternion const& q_0) const;
  public function extern "dot" btScalar dot(btQuaternion const& q_0) const;
  public function extern "farthest" btQuaternion farthest(btQuaternion const& qd_0) const;
  public function extern "getAngle" btScalar getAngle() const;
  public function extern "getAngleShortestPath" btScalar getAngleShortestPath() const;
  public function extern "getAxis" btVector3 getAxis() const;
  public function extern "getW" btScalar const& getW() const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "inverse" btQuaternion inverse() const;
  public function extern "length" btScalar length() const;
  public function extern "length2" btScalar length2() const;
  public function extern "nearest" btQuaternion nearest(btQuaternion const& qd_0) const;
  public function extern "normalize" btQuaternion mutable& normalize();
  public function extern "normalized" btQuaternion normalized() const;
  public function extern "setEuler" void setEuler(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
  public function extern "setEulerZYX" void setEulerZYX(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
  public function extern "setMax" void setMax(btQuadWord const& other_0);
  public function extern "setMin" void setMin(btQuadWord const& other_0);
  public function extern "setRotation" void setRotation(btVector3 const& axis_0, btScalar const& _angle_1);
  public function extern "setValue" void setValue3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "setValue" void setValue4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "slerp" btQuaternion slerp(btQuaternion const& q_0, btScalar const& t_1) const;
  public function extern "w" btScalar const& w() const;
  public function extern "x" btScalar const& x() const;
  public function extern "y" btScalar const& y() const;
  public function extern "z" btScalar const& z() const;
}
public pure struct extern "::btRaycastVehicle" "nodefault" btRaycastVehicle(btRaycastVehicle_btVehicleTuning const& tuning_0, rptr{btRigidBody} chassis_1, rptr{btVehicleRaycaster} raycaster_2)  {
  public metafunction __base__ {btActionInterface};
  public function extern "addWheel" btWheelInfo mutable& addWheel(btVector3 const& connectionPointCS0_0, btVector3 const& wheelDirectionCS0_1, btVector3 const& wheelAxleCS_2, btScalar suspensionRestLength_3, btScalar wheelRadius_4, btRaycastVehicle_btVehicleTuning const& tuning_5, bool isFrontWheel_6);
  public function extern "applyEngineForce" void applyEngineForce(btScalar force_0, int wheel_1);
  public function extern "debugDraw" void debugDraw(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "getChassisWorldTransform" btTransform const& getChassisWorldTransform() const;
  public function extern "getCurrentSpeedKmHour" btScalar getCurrentSpeedKmHour() const;
  public function extern "getForwardAxis" int getForwardAxis() const;
  public function extern "getForwardVector" btVector3 getForwardVector() const;
  public function extern "getNumWheels" int getNumWheels() const;
  public function extern "getRightAxis" int getRightAxis() const;
  public function extern "getRigidBody" rptr{btRigidBody} getRigidBody();
  public function extern "getRigidBody" crptr{btRigidBody} cgetRigidBody() const;
  public function extern "getSteeringValue" btScalar getSteeringValue(int wheel_0) const;
  public function extern "getUpAxis" int getUpAxis() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "getWheelInfo" btWheelInfo mutable& getWheelInfo(int index_0);
  public function extern "getWheelInfo" btWheelInfo const& cgetWheelInfo(int index_0) const;
  public function extern "getWheelTransformWS" btTransform const& getWheelTransformWS(int wheelIndex_0) const;
  public function extern "rayCast" btScalar rayCast(btWheelInfo mutable& wheel_0);
  public function extern "resetSuspension" void resetSuspension();
  public function extern "setBrake" void setBrake(btScalar brake_0, int wheelIndex_1);
  public function extern "setCoordinateSystem" void setCoordinateSystem(int rightIndex_0, int upIndex_1, int forwardIndex_2);
  public function extern "setPitchControl" void setPitchControl(btScalar pitch_0);
  public function extern "setSteeringValue" void setSteeringValue(btScalar steering_0, int wheel_1);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "updateAction" void updateAction(rptr{btCollisionWorld} collisionWorld_0, btScalar deltaTimeStep_1);
  public function extern "updateFriction" void updateFriction(btScalar timeStep_0);
  public function extern "updateSuspension" void updateSuspension(btScalar deltaTime_0);
  public function extern "updateVehicle" void updateVehicle(btScalar step_0);
  public function extern "updateWheelTransform" void updateWheelTransform(int wheelIndex_0, bool interpolatedTransform_1);
  public function extern "updateWheelTransformsWS" void updateWheelTransformsWS(btWheelInfo mutable& wheel_0, bool interpolatedTransform_1);
}
public pure struct extern "::btRigidBody" "nodefault" btRigidBody(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo_0)  {
  public metafunction __base__ {btCollisionObject};
  public function extern "activate" void activate(bool forceActivation_0) const;
  public function extern "addConstraintRef" void addConstraintRef(rptr{btTypedConstraint} c_0);
  public function extern "applyCentralForce" void applyCentralForce(btVector3 const& force_0);
  public function extern "applyCentralImpulse" void applyCentralImpulse(btVector3 const& impulse_0);
  public function extern "applyDamping" void applyDamping(btScalar timeStep_0);
  public function extern "applyForce" void applyForce(btVector3 const& force_0, btVector3 const& rel_pos_1);
  public function extern "applyGravity" void applyGravity();
  public function extern "applyImpulse" void applyImpulse(btVector3 const& impulse_0, btVector3 const& rel_pos_1);
  public function extern "applyTorque" void applyTorque(btVector3 const& torque_0);
  public function extern "applyTorqueImpulse" void applyTorqueImpulse(btVector3 const& torque_0);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "checkCollideWith" bool checkCollideWith(crptr{btCollisionObject} co_0) const;
  public function extern "checkCollideWithOverride" bool checkCollideWithOverride(crptr{btCollisionObject} co_0) const;
  public function extern "clearForces" void clearForces();
  public function extern "computeAngularImpulseDenominator" btScalar computeAngularImpulseDenominator(btVector3 const& axis_0) const;
  public function extern "computeGyroscopicForceExplicit" btVector3 computeGyroscopicForceExplicit(btScalar maxGyroscopicForce_0) const;
  public function extern "computeGyroscopicImpulseImplicit_Body" btVector3 computeGyroscopicImpulseImplicit_Body(btScalar step_0) const;
  public function extern "computeGyroscopicImpulseImplicit_World" btVector3 computeGyroscopicImpulseImplicit_World(btScalar dt_0) const;
  public function extern "computeImpulseDenominator" btScalar computeImpulseDenominator(btVector3 const& pos_0, btVector3 const& normal_1) const;
  public function extern "forceActivationState" void forceActivationState(int newState_0) const;
  public function extern "getAabb" void getAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getActivationState" int getActivationState() const;
  public function extern "getAngularDamping" btScalar getAngularDamping() const;
  public function extern "getAngularFactor" btVector3 const& getAngularFactor() const;
  public function extern "getAngularSleepingThreshold" btScalar getAngularSleepingThreshold() const;
  public function extern "getAngularVelocity" btVector3 const& getAngularVelocity() const;
  public function extern "getAnisotropicFriction" btVector3 const& getAnisotropicFriction() const;
  public function extern "getBroadphaseHandle" rptr{btBroadphaseProxy} getBroadphaseHandle();
  public function extern "getBroadphaseHandle" crptr{btBroadphaseProxy} cgetBroadphaseHandle() const;
  public function extern "getBroadphaseProxy" rptr{btBroadphaseProxy} getBroadphaseProxy();
  public function extern "getBroadphaseProxy" crptr{btBroadphaseProxy} cgetBroadphaseProxy() const;
  public function extern "getCcdMotionThreshold" btScalar getCcdMotionThreshold() const;
  public function extern "getCcdSquareMotionThreshold" btScalar getCcdSquareMotionThreshold() const;
  public function extern "getCcdSweptSphereRadius" btScalar getCcdSweptSphereRadius() const;
  public function extern "getCenterOfMassPosition" btVector3 const& getCenterOfMassPosition() const;
  public function extern "getCenterOfMassTransform" btTransform const& getCenterOfMassTransform() const;
  public function extern "getCollisionFlags" int getCollisionFlags() const;
  public function extern "getCollisionShape" rptr{btCollisionShape} getCollisionShape();
  public function extern "getCollisionShape" crptr{btCollisionShape} cgetCollisionShape() const;
  public function extern "getCompanionId" int getCompanionId() const;
  public function extern "getConstraintRef" rptr{btTypedConstraint} getConstraintRef(int index_0);
  public function extern "getContactProcessingThreshold" btScalar getContactProcessingThreshold() const;
  public function extern "getDeactivationTime" btScalar getDeactivationTime() const;
  public function extern "getFlags" int getFlags() const;
  public function extern "getFriction" btScalar getFriction() const;
  public function extern "getGravity" btVector3 const& getGravity() const;
  public function extern "getHitFraction" btScalar getHitFraction() const;
  public function extern "getInternalType" int getInternalType() const;
  public function extern "getInterpolationAngularVelocity" btVector3 const& getInterpolationAngularVelocity() const;
  public function extern "getInterpolationLinearVelocity" btVector3 const& getInterpolationLinearVelocity() const;
  public function extern "getInterpolationWorldTransform" btTransform mutable& getInterpolationWorldTransform();
  public function extern "getInterpolationWorldTransform" btTransform const& cgetInterpolationWorldTransform() const;
  public function extern "getInvInertiaDiagLocal" btVector3 const& getInvInertiaDiagLocal() const;
  public function extern "getInvInertiaTensorWorld" btMatrix3x3 const& getInvInertiaTensorWorld() const;
  public function extern "getInvMass" btScalar getInvMass() const;
  public function extern "getIslandTag" int getIslandTag() const;
  public function extern "getLinearDamping" btScalar getLinearDamping() const;
  public function extern "getLinearFactor" btVector3 const& getLinearFactor() const;
  public function extern "getLinearSleepingThreshold" btScalar getLinearSleepingThreshold() const;
  public function extern "getLinearVelocity" btVector3 const& getLinearVelocity() const;
  public function extern "getLocalInertia" btVector3 getLocalInertia() const;
  public function extern "getMotionState" rptr{btMotionState} getMotionState();
  public function extern "getMotionState" crptr{btMotionState} cgetMotionState() const;
  public function extern "getNumConstraintRefs" int getNumConstraintRefs() const;
  public function extern "getOrientation" btQuaternion getOrientation() const;
  public function extern "getRestitution" btScalar getRestitution() const;
  public function extern "getRollingFriction" btScalar getRollingFriction() const;
  public function extern "getTotalForce" btVector3 const& getTotalForce() const;
  public function extern "getTotalTorque" btVector3 const& getTotalTorque() const;
  public function extern "getUpdateRevisionInternal" int getUpdateRevisionInternal() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVelocityInLocalPoint" btVector3 getVelocityInLocalPoint(btVector3 const& rel_pos_0) const;
  public function extern "getWorldTransform" btTransform mutable& getWorldTransform();
  public function extern "getWorldTransform" btTransform const& cgetWorldTransform() const;
  public function extern "hasAnisotropicFriction" bool hasAnisotropicFriction(int frictionMode_0) const;
  public function extern "hasContactResponse" bool hasContactResponse() const;
  public function extern "integrateVelocities" void integrateVelocities(btScalar step_0);
  public function extern "internalGetExtensionPointer" rptr{void} internalGetExtensionPointer() const;
  public function extern "internalSetExtensionPointer" void internalSetExtensionPointer(rptr{void} pointer_0);
  public function extern "isActive" bool isActive() const;
  public function extern "isInWorld" bool isInWorld() const;
  public function extern "isKinematicObject" bool isKinematicObject() const;
  public function extern "isStaticObject" bool isStaticObject() const;
  public function extern "isStaticOrKinematicObject" bool isStaticOrKinematicObject() const;
  public function extern "mergesSimulationIslands" bool mergesSimulationIslands() const;
  public function extern "predictIntegratedTransform" void predictIntegratedTransform(btScalar step_0, btTransform mutable& predictedTransform_1);
  public function extern "proceedToTransform" void proceedToTransform(btTransform const& newTrans_0);
  public function extern "removeConstraintRef" void removeConstraintRef(rptr{btTypedConstraint} c_0);
  public function extern "saveKinematicState" void saveKinematicState(btScalar step_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleObject" void serializeSingleObject(rptr{btSerializer} serializer_0) const;
  public function extern "setActivationState" void setActivationState(int newState_0) const;
  public function extern "setAngularFactor" void setAngularFactor_btScalar(btScalar angFac_0);
  public function extern "setAngularFactor" void setAngularFactor_btVector3(btVector3 const& angFac_0);
  public function extern "setAngularVelocity" void setAngularVelocity(btVector3 const& ang_vel_0);
  public function extern "setAnisotropicFriction" void setAnisotropicFriction(btVector3 const& anisotropicFriction_0, int frictionMode_1);
  public function extern "setBroadphaseHandle" void setBroadphaseHandle(rptr{btBroadphaseProxy} handle_0);
  public function extern "setCcdMotionThreshold" void setCcdMotionThreshold(btScalar ccdMotionThreshold_0);
  public function extern "setCcdSweptSphereRadius" void setCcdSweptSphereRadius(btScalar radius_0);
  public function extern "setCenterOfMassTransform" void setCenterOfMassTransform(btTransform const& xform_0);
  public function extern "setCollisionFlags" void setCollisionFlags(int flags_0);
  public function extern "setCollisionShape" void setCollisionShape(rptr{btCollisionShape} collisionShape_0);
  public function extern "setCompanionId" void setCompanionId(int id_0);
  public function extern "setContactProcessingThreshold" void setContactProcessingThreshold(btScalar contactProcessingThreshold_0);
  public function extern "setDamping" void setDamping(btScalar lin_damping_0, btScalar ang_damping_1);
  public function extern "setDeactivationTime" void setDeactivationTime(btScalar time_0);
  public function extern "setFlags" void setFlags(int flags_0);
  public function extern "setFriction" void setFriction(btScalar frict_0);
  public function extern "setGravity" void setGravity(btVector3 const& acceleration_0);
  public function extern "setHitFraction" void setHitFraction(btScalar hitFraction_0);
  public function extern "setIgnoreCollisionCheck" void setIgnoreCollisionCheck(crptr{btCollisionObject} co_0, bool ignoreCollisionCheck_1);
  public function extern "setInterpolationAngularVelocity" void setInterpolationAngularVelocity(btVector3 const& angvel_0);
  public function extern "setInterpolationLinearVelocity" void setInterpolationLinearVelocity(btVector3 const& linvel_0);
  public function extern "setInterpolationWorldTransform" void setInterpolationWorldTransform(btTransform const& trans_0);
  public function extern "setInvInertiaDiagLocal" void setInvInertiaDiagLocal(btVector3 const& diagInvInertia_0);
  public function extern "setIslandTag" void setIslandTag(int tag_0);
  public function extern "setLinearFactor" void setLinearFactor(btVector3 const& linearFactor_0);
  public function extern "setLinearVelocity" void setLinearVelocity(btVector3 const& lin_vel_0);
  public function extern "setMassProps" void setMassProps(btScalar mass_0, btVector3 const& inertia_1);
  public function extern "setMotionState" void setMotionState(rptr{btMotionState} motionState_0);
  public function extern "setNewBroadphaseProxy" void setNewBroadphaseProxy(rptr{btBroadphaseProxy} broadphaseProxy_0);
  public function extern "setRestitution" void setRestitution(btScalar rest_0);
  public function extern "setRollingFriction" void setRollingFriction(btScalar frict_0);
  public function extern "setSleepingThresholds" void setSleepingThresholds(btScalar linear_0, btScalar angular_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPointer_0);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTrans_0);
  public function extern "translate" void translate(btVector3 const& v_0);
  public function extern "updateDeactivation" void updateDeactivation(btScalar timeStep_0);
  public function extern "updateInertiaTensor" void updateInertiaTensor();
  public function extern "wantsSleeping" bool wantsSleeping();
  public int m_contactSolverType;
  public int m_frictionSolverType;
}
public pure struct extern "::btRigidBody::btRigidBodyConstructionInfo" "nodefault" btRigidBody_btRigidBodyConstructionInfo(btScalar mass_0, rptr{btMotionState} motionState_1, rptr{btCollisionShape} collisionShape_2, btVector3 const& localInertia_3)  {
  public btScalar m_mass;
  public rptr{btMotionState} m_motionState;
  public btTransform m_startWorldTransform;
  public rptr{btCollisionShape} m_collisionShape;
  public btVector3 m_localInertia;
  public btScalar m_linearDamping;
  public btScalar m_angularDamping;
  public btScalar m_friction;
  public btScalar m_rollingFriction;
  public btScalar m_restitution;
  public btScalar m_linearSleepingThreshold;
  public btScalar m_angularSleepingThreshold;
  public bool m_additionalDamping;
  public btScalar m_additionalDampingFactor;
  public btScalar m_additionalLinearDampingThresholdSqr;
  public btScalar m_additionalAngularDampingThresholdSqr;
  public btScalar m_additionalAngularDampingFactor;
}
public pure struct extern "::btRigidBodyDoubleData" btRigidBodyDoubleData {
  public btCollisionObjectDoubleData m_collisionObjectData;
  public btMatrix3x3DoubleData m_invInertiaTensorWorld;
  public btVector3DoubleData m_linearVelocity;
  public btVector3DoubleData m_angularVelocity;
  public btVector3DoubleData m_angularFactor;
  public btVector3DoubleData m_linearFactor;
  public btVector3DoubleData m_gravity;
  public btVector3DoubleData m_gravity_acceleration;
  public btVector3DoubleData m_invInertiaLocal;
  public btVector3DoubleData m_totalForce;
  public btVector3DoubleData m_totalTorque;
  public double m_inverseMass;
  public double m_linearDamping;
  public double m_angularDamping;
  public double m_additionalDampingFactor;
  public double m_additionalLinearDampingThresholdSqr;
  public double m_additionalAngularDampingThresholdSqr;
  public double m_additionalAngularDampingFactor;
  public double m_linearSleepingThreshold;
  public double m_angularSleepingThreshold;
  public int m_additionalDamping;
  public rawarray{char, 4} m_padding;
}
public pure tsvaluetype struct extern "::btRigidBodyFlags" "extenum" btRigidBodyFlags { }
public extern "BT_DISABLE_WORLD_GRAVITY" btRigidBodyFlags btRigidBodyFlags_BT_DISABLE_WORLD_GRAVITY;
public extern "BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT" btRigidBodyFlags btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_EXPLICIT;
public extern "BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD" btRigidBodyFlags btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_WORLD;
public extern "BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY" btRigidBodyFlags btRigidBodyFlags_BT_ENABLE_GYROSCOPIC_FORCE_IMPLICIT_BODY;
public extern "BT_ENABLE_GYROPSCOPIC_FORCE" btRigidBodyFlags btRigidBodyFlags_BT_ENABLE_GYROPSCOPIC_FORCE;
public pure struct extern "::btRigidBodyFloatData" btRigidBodyFloatData {
  public btCollisionObjectFloatData m_collisionObjectData;
  public btMatrix3x3FloatData m_invInertiaTensorWorld;
  public btVector3FloatData m_linearVelocity;
  public btVector3FloatData m_angularVelocity;
  public btVector3FloatData m_angularFactor;
  public btVector3FloatData m_linearFactor;
  public btVector3FloatData m_gravity;
  public btVector3FloatData m_gravity_acceleration;
  public btVector3FloatData m_invInertiaLocal;
  public btVector3FloatData m_totalForce;
  public btVector3FloatData m_totalTorque;
  public float m_inverseMass;
  public float m_linearDamping;
  public float m_angularDamping;
  public float m_additionalDampingFactor;
  public float m_additionalLinearDampingThresholdSqr;
  public float m_additionalAngularDampingThresholdSqr;
  public float m_additionalAngularDampingFactor;
  public float m_linearSleepingThreshold;
  public float m_angularSleepingThreshold;
  public int m_additionalDamping;
}
public pure struct extern "::btRotationalLimitMotor" btRotationalLimitMotor {
  public function extern "isLimited" bool isLimited();
  public function extern "needApplyTorques" bool needApplyTorques();
  public function extern "solveAngularLimits" btScalar solveAngularLimits(btScalar timeStep_0, btVector3 mutable& axis_1, btScalar jacDiagABInv_2, rptr{btRigidBody} body0_3, rptr{btRigidBody} body1_4);
  public function extern "testLimitValue" int testLimitValue(btScalar test_value_0);
  public btScalar m_loLimit;
  public btScalar m_hiLimit;
  public btScalar m_targetVelocity;
  public btScalar m_maxMotorForce;
  public btScalar m_maxLimitForce;
  public btScalar m_damping;
  public btScalar m_limitSoftness;
  public btScalar m_normalCFM;
  public btScalar m_stopERP;
  public btScalar m_stopCFM;
  public btScalar m_bounce;
  public bool m_enableMotor;
  public btScalar m_currentLimitError;
  public btScalar m_currentPosition;
  public int m_currentLimit;
  public btScalar m_accumulatedImpulse;
}
public pure struct extern "::btRotationalLimitMotor2" btRotationalLimitMotor2 {
  public function extern "isLimited" bool isLimited();
  public function extern "testLimitValue" void testLimitValue(btScalar test_value_0);
  public btScalar m_loLimit;
  public btScalar m_hiLimit;
  public btScalar m_bounce;
  public btScalar m_stopERP;
  public btScalar m_stopCFM;
  public btScalar m_motorERP;
  public btScalar m_motorCFM;
  public bool m_enableMotor;
  public btScalar m_targetVelocity;
  public btScalar m_maxMotorForce;
  public bool m_servoMotor;
  public btScalar m_servoTarget;
  public bool m_enableSpring;
  public btScalar m_springStiffness;
  public bool m_springStiffnessLimited;
  public btScalar m_springDamping;
  public bool m_springDampingLimited;
  public btScalar m_equilibriumPoint;
  public btScalar m_currentLimitError;
  public btScalar m_currentLimitErrorHi;
  public btScalar m_currentPosition;
  public int m_currentLimit;
}
public metafunction btScalar float;
public pure struct extern "::btScaledBvhTriangleMeshShape" "nodefault" btScaledBvhTriangleMeshShape(rptr{btBvhTriangleMeshShape} childShape_0, btVector3 const& localScaling_1)  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getChildShape" rptr{btBvhTriangleMeshShape} getChildShape();
  public function extern "getChildShape" crptr{btBvhTriangleMeshShape} cgetChildShape() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btScaledTriangleMeshShapeData" btScaledTriangleMeshShapeData {
  public btTriangleMeshShapeData m_trimeshShapeData;
  public btVector3FloatData m_localScaling;
}
public pure struct extern "::btSequentialImpulseConstraintSolver" "nonmovable" btSequentialImpulseConstraintSolver {
  public metafunction __base__ {btConstraintSolver};
  public function extern "allSolved" void allSolved(btContactSolverInfo const& _0, rptr{btIDebugDraw} _1);
  public function extern "btRand2" ulong btRand2();
  public function extern "btRandInt2" int btRandInt2(int n_0);
  public function extern "getActiveConstraintRowSolverGeneric" btSingleConstraintRowSolver getActiveConstraintRowSolverGeneric();
  public function extern "getActiveConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getActiveConstraintRowSolverLowerLimit();
  public function extern "getRandSeed" ulong getRandSeed() const;
  public function extern "getSSE2ConstraintRowSolverGeneric" btSingleConstraintRowSolver getSSE2ConstraintRowSolverGeneric();
  public function extern "getSSE2ConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getSSE2ConstraintRowSolverLowerLimit();
  public function extern "getSSE4_1ConstraintRowSolverGeneric" btSingleConstraintRowSolver getSSE4_1ConstraintRowSolverGeneric();
  public function extern "getSSE4_1ConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getSSE4_1ConstraintRowSolverLowerLimit();
  public function extern "getScalarConstraintRowSolverGeneric" btSingleConstraintRowSolver getScalarConstraintRowSolverGeneric();
  public function extern "getScalarConstraintRowSolverLowerLimit" btSingleConstraintRowSolver getScalarConstraintRowSolverLowerLimit();
  public function extern "getSolverType" btConstraintSolverType getSolverType() const;
  public function extern "prepareSolve" void prepareSolve(int _0, int _1);
  public function extern "reset" void reset();
  public function extern "setConstraintRowSolverGeneric" void setConstraintRowSolverGeneric(btSingleConstraintRowSolver rowSolver_0);
  public function extern "setConstraintRowSolverLowerLimit" void setConstraintRowSolverLowerLimit(btSingleConstraintRowSolver rowSolver_0);
  public function extern "setRandSeed" void setRandSeed(ulong seed_0);
  public function extern "solveGroup" btScalar solveGroup(rptr{rptr{btCollisionObject}} bodies_0, int numBodies_1, rptr{rptr{btPersistentManifold}} manifold_2, int numManifolds_3, rptr{rptr{btTypedConstraint}} constraints_4, int numConstraints_5, btContactSolverInfo const& info_6, rptr{btIDebugDraw} debugDrawer_7, rptr{btDispatcher} dispatcher_8);
}
public pure tsvaluetype struct extern "::btSerializationFlags" "extenum" btSerializationFlags { }
public extern "BT_SERIALIZE_NO_BVH" btSerializationFlags btSerializationFlags_BT_SERIALIZE_NO_BVH;
public extern "BT_SERIALIZE_NO_TRIANGLEINFOMAP" btSerializationFlags btSerializationFlags_BT_SERIALIZE_NO_TRIANGLEINFOMAP;
public extern "BT_SERIALIZE_NO_DUPLICATE_ASSERT" btSerializationFlags btSerializationFlags_BT_SERIALIZE_NO_DUPLICATE_ASSERT;
public pure struct extern "::btSerializer" "nonmovable" btSerializer {
  public function extern "allocate" rptr{btChunk} allocate(size_t size_0, int numElements_1);
  public function extern "finalizeChunk" void finalizeChunk(rptr{btChunk} chunk_0, crptr{char} structType_1, int chunkCode_2, rptr{void} oldPtr_3);
  public function extern "findNameForPointer" crptr{char} findNameForPointer(crptr{void} ptr_0) const;
  public function extern "findPointer" rptr{void} findPointer(rptr{void} oldPtr_0);
  public function extern "finishSerialization" void finishSerialization();
  public function extern "getBufferPointer" crptr{uchar} getBufferPointer() const;
  public function extern "getChunk" crptr{btChunk} getChunk(int chunkIndex_0) const;
  public function extern "getCurrentBufferSize" int getCurrentBufferSize() const;
  public function extern "getNumChunks" int getNumChunks() const;
  public function extern "getSerializationFlags" int getSerializationFlags() const;
  public function extern "getUniquePointer" rptr{void} getUniquePointer(rptr{void} oldPtr_0);
  public function extern "registerNameForPointer" void registerNameForPointer(crptr{void} ptr_0, crptr{char} name_1);
  public function extern "serializeName" void serializeName(crptr{char} ptr_0);
  public function extern "setSerializationFlags" void setSerializationFlags(int flags_0);
  public function extern "startSerialization" void startSerialization();
}
public pure struct extern "::btShapeHull" "nodefault" btShapeHull(crptr{btConvexShape} shape_0)  {
  public function extern "buildHull" bool buildHull(btScalar margin_0);
  public function extern "getIndexPointer" crptr{uint} getIndexPointer() const;
  public function extern "getVertexPointer" crptr{btVector3} getVertexPointer() const;
  public function extern "numIndices" int numIndices() const;
  public function extern "numTriangles" int numTriangles() const;
  public function extern "numVertices" int numVertices() const;
}
public metafunction btShapePairCallback rptr{m::list{bool, crptr{btCollisionShape}, crptr{btCollisionShape}}};
public pure struct extern "::btShortIntIndexData" btShortIntIndexData {
  public short m_value;
  public rawarray{char, 2} m_pad;
}
public pure struct extern "::btShortIntIndexTripletData" btShortIntIndexTripletData {
  public rawarray{short, 3} m_values;
  public rawarray{char, 2} m_pad;
}
public pure struct extern "::btSimpleBroadphase" "nodefault" btSimpleBroadphase(int maxProxies_0, rptr{btOverlappingPairCache} overlappingPairCache_1)  {
  public metafunction __base__ {btBroadphaseInterface};
  public function extern "aabbTest" void aabbTest(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, btBroadphaseAabbCallback mutable& callback_2);
  public function extern "calculateOverlappingPairs" void calculateOverlappingPairs(rptr{btDispatcher} dispatcher_0);
  public function extern "createProxy" rptr{btBroadphaseProxy} createProxy(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{btDispatcher} dispatcher_6, rptr{void} multiSapProxy_7);
  public function extern "destroyProxy" void destroyProxy(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "getAabb" void getAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getBroadphaseAabb" void getBroadphaseAabb(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1) const;
  public function extern "getOverlappingPairCache" rptr{btOverlappingPairCache} getOverlappingPairCache();
  public function extern "getOverlappingPairCache" crptr{btOverlappingPairCache} cgetOverlappingPairCache() const;
  public function extern "printStats" void printStats();
  public function extern "rayTest" void rayTest(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btBroadphaseRayCallback mutable& rayCallback_2, btVector3 const& aabbMin_3, btVector3 const& aabbMax_4);
  public function extern "resetPool" void resetPool(rptr{btDispatcher} dispatcher_0);
  public function extern "setAabb" void setAabb(rptr{btBroadphaseProxy} proxy_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2, rptr{btDispatcher} dispatcher_3);
  public function extern "testAabbOverlap" bool testAabbOverlap(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
}
public pure struct extern "::btSimpleBroadphaseProxy" btSimpleBroadphaseProxy {
  public metafunction __base__ {btBroadphaseProxy};
  public function extern "GetNextFree" int GetNextFree() const;
  public function extern "SetNextFree" void SetNextFree(int next_0);
  public function extern "getUid" int getUid() const;
  public int m_nextFree;
  public rptr{void} m_clientObject;
  public short m_collisionFilterGroup;
  public short m_collisionFilterMask;
  public rptr{void} m_multiSapParentProxy;
  public int m_uniqueId;
  public btVector3 m_aabbMin;
  public btVector3 m_aabbMax;
}
public pure struct extern "::btSimpleDynamicsWorld" "nodefault" btSimpleDynamicsWorld(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3)  {
  public metafunction __base__ {btDynamicsWorld, btCollisionWorld};
  public function extern "addAction" void addAction(rptr{btActionInterface} action_0);
  public function extern "addCharacter" void addCharacter(rptr{btActionInterface} character_0);
  public function extern "addCollisionObject" void addCollisionObject(rptr{btCollisionObject} collisionObject_0, short collisionFilterGroup_1, short collisionFilterMask_2);
  public function extern "addConstraint" void addConstraint(rptr{btTypedConstraint} constraint_0, bool disableCollisionsBetweenLinkedBodies_1);
  public function extern "addRigidBody" void addRigidBody1(rptr{btRigidBody} body_0);
  public function extern "addRigidBody" void addRigidBody3(rptr{btRigidBody} body_0, short group_1, short mask_2);
  public function extern "addVehicle" void addVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "clearForces" void clearForces();
  public function extern "computeOverlappingPairs" void computeOverlappingPairs();
  public function extern "contactPairTest" void contactPairTest(rptr{btCollisionObject} colObjA_0, rptr{btCollisionObject} colObjB_1, btCollisionWorld_ContactResultCallback mutable& resultCallback_2);
  public function extern "contactTest" void contactTest(rptr{btCollisionObject} colObj_0, btCollisionWorld_ContactResultCallback mutable& resultCallback_1);
  public function extern "convexSweepTest" void convexSweepTest(crptr{btConvexShape} castShape_0, btTransform const& from_1, btTransform const& to_2, btCollisionWorld_ConvexResultCallback mutable& resultCallback_3, btScalar allowedCcdPenetration_4) const;
  public function extern "debugDrawObject" void debugDrawObject(btTransform const& worldTransform_0, crptr{btCollisionShape} shape_1, btVector3 const& color_2);
  public function extern "debugDrawWorld" void debugDrawWorld();
  public function extern "getBroadphase" rptr{btBroadphaseInterface} getBroadphase();
  public function extern "getBroadphase" crptr{btBroadphaseInterface} cgetBroadphase() const;
  public function extern "getConstraint" rptr{btTypedConstraint} getConstraint(int index_0);
  public function extern "getConstraint" crptr{btTypedConstraint} cgetConstraint(int index_0) const;
  public function extern "getConstraintSolver" rptr{btConstraintSolver} getConstraintSolver();
  public function extern "getDebugDrawer" rptr{btIDebugDraw} getDebugDrawer();
  public function extern "getDispatchInfo" btDispatcherInfo mutable& getDispatchInfo();
  public function extern "getDispatchInfo" btDispatcherInfo const& cgetDispatchInfo() const;
  public function extern "getDispatcher" rptr{btDispatcher} getDispatcher();
  public function extern "getDispatcher" crptr{btDispatcher} cgetDispatcher() const;
  public function extern "getForceUpdateAllAabbs" bool getForceUpdateAllAabbs() const;
  public function extern "getGravity" btVector3 getGravity() const;
  public function extern "getNumCollisionObjects" int getNumCollisionObjects() const;
  public function extern "getNumConstraints" int getNumConstraints() const;
  public function extern "getPairCache" rptr{btOverlappingPairCache} getPairCache();
  public function extern "getSolverInfo" btContactSolverInfo mutable& getSolverInfo();
  public function extern "getWorldType" btDynamicsWorldType getWorldType() const;
  public function extern "getWorldUserInfo" rptr{void} getWorldUserInfo() const;
  public function extern "performDiscreteCollisionDetection" void performDiscreteCollisionDetection();
  public function extern "rayTest" void rayTest(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1, btCollisionWorld_RayResultCallback mutable& resultCallback_2) const;
  public function extern "removeAction" void removeAction(rptr{btActionInterface} action_0);
  public function extern "removeCharacter" void removeCharacter(rptr{btActionInterface} character_0);
  public function extern "removeCollisionObject" void removeCollisionObject(rptr{btCollisionObject} collisionObject_0);
  public function extern "removeConstraint" void removeConstraint(rptr{btTypedConstraint} constraint_0);
  public function extern "removeRigidBody" void removeRigidBody(rptr{btRigidBody} body_0);
  public function extern "removeVehicle" void removeVehicle(rptr{btActionInterface} vehicle_0);
  public function extern "serialize" void serialize(rptr{btSerializer} serializer_0);
  public function extern "setBroadphase" void setBroadphase(rptr{btBroadphaseInterface} pairCache_0);
  public function extern "setConstraintSolver" void setConstraintSolver(rptr{btConstraintSolver} solver_0);
  public function extern "setDebugDrawer" void setDebugDrawer(rptr{btIDebugDraw} debugDrawer_0);
  public function extern "setForceUpdateAllAabbs" void setForceUpdateAllAabbs(bool forceUpdateAllAabbs_0);
  public function extern "setGravity" void setGravity(btVector3 const& gravity_0);
  public function extern "setInternalTickCallback" void setInternalTickCallback(btInternalTickCallback cb_0, rptr{void} worldUserInfo_1, bool isPreTick_2);
  public function extern "setWorldUserInfo" void setWorldUserInfo(rptr{void} worldUserInfo_0);
  public function extern "stepSimulation" int stepSimulation(btScalar timeStep_0, int maxSubSteps_1, btScalar fixedTimeStep_2);
  public function extern "synchronizeMotionStates" void synchronizeMotionStates();
  public function extern "updateAabbs" void updateAabbs();
  public function extern "updateSingleAabb" void updateSingleAabb(rptr{btCollisionObject} colObj_0);
}
public pure struct extern "::btSimplePair" "nodefault" btSimplePair(int indexA_0, int indexB_1)  {
  public int m_indexA;
  public int m_indexB;
}
public pure struct extern "::btSimulationIslandManager" "nonmovable" btSimulationIslandManager {
  public function extern "buildAndProcessIslands" void buildAndProcessIslands(rptr{btDispatcher} dispatcher_0, rptr{btCollisionWorld} collisionWorld_1, rptr{btSimulationIslandManager_IslandCallback} callback_2);
  public function extern "buildIslands" void buildIslands(rptr{btDispatcher} dispatcher_0, rptr{btCollisionWorld} colWorld_1);
  public function extern "findUnions" void findUnions(rptr{btDispatcher} dispatcher_0, rptr{btCollisionWorld} colWorld_1);
  public function extern "getSplitIslands" bool getSplitIslands();
  public function extern "getUnionFind" btUnionFind mutable& getUnionFind();
  public function extern "initUnionFind" void initUnionFind(int n_0);
  public function extern "setSplitIslands" void setSplitIslands(bool doSplitIslands_0);
  public function extern "storeIslandActivationState" void storeIslandActivationState(rptr{btCollisionWorld} world_0);
  public function extern "updateActivationState" void updateActivationState(rptr{btCollisionWorld} colWorld_0, rptr{btDispatcher} dispatcher_1);
}
public metafunction btSingleConstraintRowSolver rptr{m::list{btScalar, rawref{btSolverBody}, rawref{btSolverBody}, crawref{btSolverConstraint}}};
public pure struct extern "::btSliderConstraint" "nodefault" btSliderConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4)  {
  public metafunction __base__ {btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTransforms" void calculateTransforms(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAncorInA" btVector3 getAncorInA();
  public function extern "getAncorInB" btVector3 getAncorInB();
  public function extern "getAngDepth" btScalar getAngDepth();
  public function extern "getAngularPos" btScalar getAngularPos() const;
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDampingDirAng" btScalar getDampingDirAng();
  public function extern "getDampingDirLin" btScalar getDampingDirLin();
  public function extern "getDampingLimAng" btScalar getDampingLimAng();
  public function extern "getDampingLimLin" btScalar getDampingLimLin();
  public function extern "getDampingOrthoAng" btScalar getDampingOrthoAng();
  public function extern "getDampingOrthoLin" btScalar getDampingOrthoLin();
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btScalar rbAinvMass_5, btScalar rbBinvMass_6);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLinDepth" btScalar getLinDepth();
  public function extern "getLinearPos" btScalar getLinearPos() const;
  public function extern "getLowerAngLimit" btScalar getLowerAngLimit();
  public function extern "getLowerLinLimit" btScalar getLowerLinLimit();
  public function extern "getMaxAngMotorForce" btScalar getMaxAngMotorForce();
  public function extern "getMaxLinMotorForce" btScalar getMaxLinMotorForce();
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getPoweredAngMotor" bool getPoweredAngMotor();
  public function extern "getPoweredLinMotor" bool getPoweredLinMotor();
  public function extern "getRestitutionDirAng" btScalar getRestitutionDirAng();
  public function extern "getRestitutionDirLin" btScalar getRestitutionDirLin();
  public function extern "getRestitutionLimAng" btScalar getRestitutionLimAng();
  public function extern "getRestitutionLimLin" btScalar getRestitutionLimLin();
  public function extern "getRestitutionOrthoAng" btScalar getRestitutionOrthoAng();
  public function extern "getRestitutionOrthoLin" btScalar getRestitutionOrthoLin();
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getSoftnessDirAng" btScalar getSoftnessDirAng();
  public function extern "getSoftnessDirLin" btScalar getSoftnessDirLin();
  public function extern "getSoftnessLimAng" btScalar getSoftnessLimAng();
  public function extern "getSoftnessLimLin" btScalar getSoftnessLimLin();
  public function extern "getSoftnessOrthoAng" btScalar getSoftnessOrthoAng();
  public function extern "getSoftnessOrthoLin" btScalar getSoftnessOrthoLin();
  public function extern "getSolveAngLimit" bool getSolveAngLimit();
  public function extern "getSolveLinLimit" bool getSolveLinLimit();
  public function extern "getTargetAngMotorVelocity" btScalar getTargetAngMotorVelocity();
  public function extern "getTargetLinMotorVelocity" btScalar getTargetLinMotorVelocity();
  public function extern "getUid" int getUid() const;
  public function extern "getUpperAngLimit" btScalar getUpperAngLimit();
  public function extern "getUpperLinLimit" btScalar getUpperLinLimit();
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getUseLinearReferenceFrameA" bool getUseLinearReferenceFrameA();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDampingDirAng" void setDampingDirAng(btScalar dampingDirAng_0);
  public function extern "setDampingDirLin" void setDampingDirLin(btScalar dampingDirLin_0);
  public function extern "setDampingLimAng" void setDampingLimAng(btScalar dampingLimAng_0);
  public function extern "setDampingLimLin" void setDampingLimLin(btScalar dampingLimLin_0);
  public function extern "setDampingOrthoAng" void setDampingOrthoAng(btScalar dampingOrthoAng_0);
  public function extern "setDampingOrthoLin" void setDampingOrthoLin(btScalar dampingOrthoLin_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLowerAngLimit" void setLowerAngLimit(btScalar lowerLimit_0);
  public function extern "setLowerLinLimit" void setLowerLinLimit(btScalar lowerLimit_0);
  public function extern "setMaxAngMotorForce" void setMaxAngMotorForce(btScalar maxAngMotorForce_0);
  public function extern "setMaxLinMotorForce" void setMaxLinMotorForce(btScalar maxLinMotorForce_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setPoweredAngMotor" void setPoweredAngMotor(bool onOff_0);
  public function extern "setPoweredLinMotor" void setPoweredLinMotor(bool onOff_0);
  public function extern "setRestitutionDirAng" void setRestitutionDirAng(btScalar restitutionDirAng_0);
  public function extern "setRestitutionDirLin" void setRestitutionDirLin(btScalar restitutionDirLin_0);
  public function extern "setRestitutionLimAng" void setRestitutionLimAng(btScalar restitutionLimAng_0);
  public function extern "setRestitutionLimLin" void setRestitutionLimLin(btScalar restitutionLimLin_0);
  public function extern "setRestitutionOrthoAng" void setRestitutionOrthoAng(btScalar restitutionOrthoAng_0);
  public function extern "setRestitutionOrthoLin" void setRestitutionOrthoLin(btScalar restitutionOrthoLin_0);
  public function extern "setSoftnessDirAng" void setSoftnessDirAng(btScalar softnessDirAng_0);
  public function extern "setSoftnessDirLin" void setSoftnessDirLin(btScalar softnessDirLin_0);
  public function extern "setSoftnessLimAng" void setSoftnessLimAng(btScalar softnessLimAng_0);
  public function extern "setSoftnessLimLin" void setSoftnessLimLin(btScalar softnessLimLin_0);
  public function extern "setSoftnessOrthoAng" void setSoftnessOrthoAng(btScalar softnessOrthoAng_0);
  public function extern "setSoftnessOrthoLin" void setSoftnessOrthoLin(btScalar softnessOrthoLin_0);
  public function extern "setTargetAngMotorVelocity" void setTargetAngMotorVelocity(btScalar targetAngMotorVelocity_0);
  public function extern "setTargetLinMotorVelocity" void setTargetLinMotorVelocity(btScalar targetLinMotorVelocity_0);
  public function extern "setUpperAngLimit" void setUpperAngLimit(btScalar upperLimit_0);
  public function extern "setUpperLinLimit" void setUpperLinLimit(btScalar upperLimit_0);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "testAngLimits" void testAngLimits();
  public function extern "testLinLimits" void testLinLimits();
  public int m_objectType;
}
public pure struct extern "::btSliderConstraintData" btSliderConstraintData {
  public btTypedConstraintData m_typeConstraintData;
  public btTransformFloatData m_rbAFrame;
  public btTransformFloatData m_rbBFrame;
  public float m_linearUpperLimit;
  public float m_linearLowerLimit;
  public float m_angularUpperLimit;
  public float m_angularLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
}
public pure struct extern "::btSliderConstraintDoubleData" btSliderConstraintDoubleData {
  public btTypedConstraintDoubleData m_typeConstraintData;
  public btTransformDoubleData m_rbAFrame;
  public btTransformDoubleData m_rbBFrame;
  public double m_linearUpperLimit;
  public double m_linearLowerLimit;
  public double m_angularUpperLimit;
  public double m_angularLowerLimit;
  public int m_useLinearReferenceFrameA;
  public int m_useOffsetForConstraintFrame;
}
public pure tsvaluetype struct extern "::btSliderFlags" "extenum" btSliderFlags { }
public extern "BT_SLIDER_FLAGS_CFM_DIRLIN" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRLIN;
public extern "BT_SLIDER_FLAGS_ERP_DIRLIN" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRLIN;
public extern "BT_SLIDER_FLAGS_CFM_DIRANG" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_CFM_DIRANG;
public extern "BT_SLIDER_FLAGS_ERP_DIRANG" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_ERP_DIRANG;
public extern "BT_SLIDER_FLAGS_CFM_ORTLIN" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTLIN;
public extern "BT_SLIDER_FLAGS_ERP_ORTLIN" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTLIN;
public extern "BT_SLIDER_FLAGS_CFM_ORTANG" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_CFM_ORTANG;
public extern "BT_SLIDER_FLAGS_ERP_ORTANG" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_ERP_ORTANG;
public extern "BT_SLIDER_FLAGS_CFM_LIMLIN" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMLIN;
public extern "BT_SLIDER_FLAGS_ERP_LIMLIN" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMLIN;
public extern "BT_SLIDER_FLAGS_CFM_LIMANG" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_CFM_LIMANG;
public extern "BT_SLIDER_FLAGS_ERP_LIMANG" btSliderFlags btSliderFlags_BT_SLIDER_FLAGS_ERP_LIMANG;
public pure struct extern "::btSoftBodyDoubleData" "nodefault" btSoftBodyDoubleData private {
}
public pure struct extern "::btSoftBodyFloatData" "nodefault" btSoftBodyFloatData private {
}
public pure struct extern "::btSolve2LinearConstraint" "nodefault" btSolve2LinearConstraint(btScalar tau_0, btScalar damping_1)  {
  public function extern "resolveBilateralPairConstraint" void resolveBilateralPairConstraint(rptr{btRigidBody} body0_0, rptr{btRigidBody} body1_1, btMatrix3x3 const& world2A_2, btMatrix3x3 const& world2B_3, btVector3 const& invInertiaADiag_4, btScalar const invMassA_5, btVector3 const& linvelA_6, btVector3 const& angvelA_7, btVector3 const& rel_posA1_8, btVector3 const& invInertiaBDiag_9, btScalar const invMassB_10, btVector3 const& linvelB_11, btVector3 const& angvelB_12, btVector3 const& rel_posA2_13, btScalar depthA_14, btVector3 const& normalA_15, btVector3 const& rel_posB1_16, btVector3 const& rel_posB2_17, btScalar depthB_18, btVector3 const& normalB_19, btScalar mutable& imp0_20, btScalar mutable& imp1_21);
  public function extern "resolveUnilateralPairConstraint" void resolveUnilateralPairConstraint(rptr{btRigidBody} body0_0, rptr{btRigidBody} body1_1, btMatrix3x3 const& world2A_2, btMatrix3x3 const& world2B_3, btVector3 const& invInertiaADiag_4, btScalar const invMassA_5, btVector3 const& linvelA_6, btVector3 const& angvelA_7, btVector3 const& rel_posA1_8, btVector3 const& invInertiaBDiag_9, btScalar const invMassB_10, btVector3 const& linvelB_11, btVector3 const& angvelB_12, btVector3 const& rel_posA2_13, btScalar depthA_14, btVector3 const& normalA_15, btVector3 const& rel_posB1_16, btVector3 const& rel_posB2_17, btScalar depthB_18, btVector3 const& normalB_19, btScalar mutable& imp0_20, btScalar mutable& imp1_21);
}
public pure struct extern "::btSolverBody" btSolverBody {
  public function extern "applyImpulse" void applyImpulse(btVector3 const& linearComponent_0, btVector3 const& angularComponent_1, btScalar const impulseMagnitude_2);
  public function extern "getAngularVelocity" void getAngularVelocity(btVector3 mutable& angVel_0) const;
  public function extern "getDeltaAngularVelocity" btVector3 const& getDeltaAngularVelocity() const;
  public function extern "getDeltaLinearVelocity" btVector3 const& getDeltaLinearVelocity() const;
  public function extern "getPushVelocity" btVector3 const& getPushVelocity() const;
  public function extern "getTurnVelocity" btVector3 const& getTurnVelocity() const;
  public function extern "getVelocityInLocalPointNoDelta" void getVelocityInLocalPointNoDelta(btVector3 const& rel_pos_0, btVector3 mutable& velocity_1) const;
  public function extern "getVelocityInLocalPointObsolete" void getVelocityInLocalPointObsolete(btVector3 const& rel_pos_0, btVector3 mutable& velocity_1) const;
  public function extern "getWorldTransform" btTransform const& getWorldTransform() const;
  public function extern "internalApplyImpulse" void internalApplyImpulse(btVector3 const& linearComponent_0, btVector3 const& angularComponent_1, btScalar const impulseMagnitude_2);
  public function extern "internalApplyPushImpulse" void internalApplyPushImpulse(btVector3 const& linearComponent_0, btVector3 const& angularComponent_1, btScalar impulseMagnitude_2);
  public function extern "internalGetAngularFactor" btVector3 const& internalGetAngularFactor() const;
  public function extern "internalGetAngularVelocity" void internalGetAngularVelocity(btVector3 mutable& angVel_0) const;
  public function extern "internalGetDeltaAngularVelocity" btVector3 mutable& internalGetDeltaAngularVelocity();
  public function extern "internalGetDeltaLinearVelocity" btVector3 mutable& internalGetDeltaLinearVelocity();
  public function extern "internalGetInvMass" btVector3 const& internalGetInvMass() const;
  public function extern "internalGetPushVelocity" btVector3 mutable& internalGetPushVelocity();
  public function extern "internalGetTurnVelocity" btVector3 mutable& internalGetTurnVelocity();
  public function extern "internalGetVelocityInLocalPointObsolete" void internalGetVelocityInLocalPointObsolete(btVector3 const& rel_pos_0, btVector3 mutable& velocity_1) const;
  public function extern "internalSetInvMass" void internalSetInvMass(btVector3 const& invMass_0);
  public function extern "setWorldTransform" void setWorldTransform(btTransform const& worldTransform_0);
  public function extern "writebackVelocity" void writebackVelocity();
  public function extern "writebackVelocityAndTransform" void writebackVelocityAndTransform(btScalar timeStep_0, btScalar splitImpulseTurnErp_1);
  public btTransform m_worldTransform;
  public btVector3 m_deltaLinearVelocity;
  public btVector3 m_deltaAngularVelocity;
  public btVector3 m_angularFactor;
  public btVector3 m_linearFactor;
  public btVector3 m_invMass;
  public btVector3 m_pushVelocity;
  public btVector3 m_turnVelocity;
  public btVector3 m_linearVelocity;
  public btVector3 m_angularVelocity;
  public btVector3 m_externalForceImpulse;
  public btVector3 m_externalTorqueImpulse;
  public rptr{btRigidBody} m_originalBody;
}
public pure struct extern "::btSolverConstraint" btSolverConstraint {
  public btVector3 m_relpos1CrossNormal;
  public btVector3 m_contactNormal1;
  public btVector3 m_relpos2CrossNormal;
  public btVector3 m_contactNormal2;
  public btVector3 m_angularComponentA;
  public btVector3 m_angularComponentB;
  public btScalar m_appliedPushImpulse;
  public btScalar m_appliedImpulse;
  public btScalar m_friction;
  public btScalar m_jacDiagABInv;
  public btScalar m_rhs;
  public btScalar m_cfm;
  public btScalar m_lowerLimit;
  public btScalar m_upperLimit;
  public btScalar m_rhsPenetration;
  public int m_overrideNumSolverIterations;
  public int m_frictionIndex;
  public int m_solverBodyIdA;
  public int m_solverBodyIdB;
}
public pure tsvaluetype struct extern "::btSolverConstraint::btSolverConstraintType" "extenum" btSolverConstraint_btSolverConstraintType { }
public extern "BT_SOLVER_CONTACT_1D" btSolverConstraint_btSolverConstraintType btSolverConstraint_btSolverConstraintType_BT_SOLVER_CONTACT_1D;
public extern "BT_SOLVER_FRICTION_1D" btSolverConstraint_btSolverConstraintType btSolverConstraint_btSolverConstraintType_BT_SOLVER_FRICTION_1D;
public pure tsvaluetype struct extern "::btSolverMode" "extenum" btSolverMode { }
public extern "SOLVER_RANDMIZE_ORDER" btSolverMode btSolverMode_SOLVER_RANDMIZE_ORDER;
public extern "SOLVER_FRICTION_SEPARATE" btSolverMode btSolverMode_SOLVER_FRICTION_SEPARATE;
public extern "SOLVER_USE_WARMSTARTING" btSolverMode btSolverMode_SOLVER_USE_WARMSTARTING;
public extern "SOLVER_USE_2_FRICTION_DIRECTIONS" btSolverMode btSolverMode_SOLVER_USE_2_FRICTION_DIRECTIONS;
public extern "SOLVER_ENABLE_FRICTION_DIRECTION_CACHING" btSolverMode btSolverMode_SOLVER_ENABLE_FRICTION_DIRECTION_CACHING;
public extern "SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION" btSolverMode btSolverMode_SOLVER_DISABLE_VELOCITY_DEPENDENT_FRICTION_DIRECTION;
public extern "SOLVER_CACHE_FRIENDLY" btSolverMode btSolverMode_SOLVER_CACHE_FRIENDLY;
public extern "SOLVER_SIMD" btSolverMode btSolverMode_SOLVER_SIMD;
public extern "SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS" btSolverMode btSolverMode_SOLVER_INTERLEAVE_CONTACT_AND_FRICTION_CONSTRAINTS;
public extern "SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS" btSolverMode btSolverMode_SOLVER_ALLOW_ZERO_LENGTH_FRICTION_DIRECTIONS;
public pure struct extern "::btSortedOverlappingPairCache" "nonmovable" btSortedOverlappingPairCache {
  public metafunction __base__ {btOverlappingPairCache, btOverlappingPairCallback};
  public function extern "addOverlappingPair" rptr{btBroadphasePair} addOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "cleanOverlappingPair" void cleanOverlappingPair(btBroadphasePair mutable& pair_0, rptr{btDispatcher} dispatcher_1);
  public function extern "cleanProxyFromPairs" void cleanProxyFromPairs(rptr{btBroadphaseProxy} proxy_0, rptr{btDispatcher} dispatcher_1);
  public function extern "findPair" rptr{btBroadphasePair} findPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1);
  public function extern "getNumOverlappingPairs" int getNumOverlappingPairs() const;
  public function extern "getOverlapFilterCallback" rptr{btOverlapFilterCallback} getOverlapFilterCallback();
  public function extern "getOverlappingPairArrayPtr" rptr{btBroadphasePair} getOverlappingPairArrayPtr();
  public function extern "getOverlappingPairArrayPtr" crptr{btBroadphasePair} cgetOverlappingPairArrayPtr() const;
  public function extern "hasDeferredRemoval" bool hasDeferredRemoval();
  public function extern "needsBroadphaseCollision" bool needsBroadphaseCollision(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1) const;
  public function extern "processAllOverlappingPairs" void processAllOverlappingPairs(rptr{btOverlapCallback} _0, rptr{btDispatcher} dispatcher_1);
  public function extern "removeOverlappingPair" rptr{void} removeOverlappingPair(rptr{btBroadphaseProxy} proxy0_0, rptr{btBroadphaseProxy} proxy1_1, rptr{btDispatcher} dispatcher_2);
  public function extern "removeOverlappingPairsContainingProxy" void removeOverlappingPairsContainingProxy(rptr{btBroadphaseProxy} proxy0_0, rptr{btDispatcher} dispatcher_1);
  public function extern "setInternalGhostPairCallback" void setInternalGhostPairCallback(rptr{btOverlappingPairCallback} ghostPairCallback_0);
  public function extern "setOverlapFilterCallback" void setOverlapFilterCallback(rptr{btOverlapFilterCallback} callback_0);
  public function extern "sortOverlappingPairs" void sortOverlappingPairs(rptr{btDispatcher} dispatcher_0);
}
public pure struct extern "::btSpatialForceVector" btSpatialForceVector {
  public function extern "addAngular" void addAngular(btVector3 const& angular_0);
  public function extern "addLinear" void addLinear(btVector3 const& linear_0);
  public function extern "addValue" void addValue(btScalar const& ax_0, btScalar const& ay_1, btScalar const& az_2, btScalar const& lx_3, btScalar const& ly_4, btScalar const& lz_5);
  public function extern "addVector" void addVector(btVector3 const& angular_0, btVector3 const& linear_1);
  public function extern "getAngular" btVector3 const& getAngular() const;
  public function extern "getLinear" btVector3 const& getLinear() const;
  public function extern "setAngular" void setAngular(btVector3 const& angular_0);
  public function extern "setLinear" void setLinear(btVector3 const& linear_0);
  public function extern "setValue" void setValue(btScalar const& ax_0, btScalar const& ay_1, btScalar const& az_2, btScalar const& lx_3, btScalar const& ly_4, btScalar const& lz_5);
  public function extern "setVector" void setVector(btVector3 const& angular_0, btVector3 const& linear_1);
  public function extern "setZero" void setZero();
  public btVector3 m_topVec;
  public btVector3 m_bottomVec;
}
public pure struct extern "::btSpatialMotionVector" btSpatialMotionVector {
  public function extern "addAngular" void addAngular(btVector3 const& angular_0);
  public function extern "addLinear" void addLinear(btVector3 const& linear_0);
  public function extern "addValue" void addValue(btScalar const& ax_0, btScalar const& ay_1, btScalar const& az_2, btScalar const& lx_3, btScalar const& ly_4, btScalar const& lz_5);
  public function extern "addVector" void addVector(btVector3 const& angular_0, btVector3 const& linear_1);
  public function extern "dot" btScalar dot(btSpatialForceVector const& b_0) const;
  public function extern "getAngular" btVector3 const& getAngular() const;
  public function extern "getLinear" btVector3 const& getLinear() const;
  public function extern "setAngular" void setAngular(btVector3 const& angular_0);
  public function extern "setLinear" void setLinear(btVector3 const& linear_0);
  public function extern "setValue" void setValue(btScalar const& ax_0, btScalar const& ay_1, btScalar const& az_2, btScalar const& lx_3, btScalar const& ly_4, btScalar const& lz_5);
  public function extern "setVector" void setVector(btVector3 const& angular_0, btVector3 const& linear_1);
  public function extern "setZero" void setZero();
  public btVector3 m_topVec;
  public btVector3 m_bottomVec;
}
public pure struct extern "::btSpatialTransformationMatrix" btSpatialTransformationMatrix {
  public function extern "transformInverse" void transformInverse(btSymmetricSpatialDyad const& inMat_0, btSymmetricSpatialDyad mutable& outMat_1, btSpatialTransformationMatrix_eOutputOperation outOp_2);
  public btMatrix3x3 m_rotMat;
  public btVector3 m_trnVec;
}
public pure struct extern "::btSphereBoxCollisionAlgorithm" "nodefault" btSphereBoxCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "getSphereDistance" bool getSphereDistance(crptr{btCollisionObjectWrapper} boxObjWrap_0, btVector3 mutable& v3PointOnBox_1, btVector3 mutable& normal_2, btScalar mutable& penetrationDepth_3, btVector3 const& v3SphereCenter_4, btScalar fRadius_5, btScalar maxContactDistance_6);
  public function extern "getSpherePenetration" btScalar getSpherePenetration(btVector3 const& boxHalfExtent_0, btVector3 const& sphereRelPos_1, btVector3 mutable& closestPoint_2, btVector3 mutable& normal_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btSphereShape" "nodefault" btSphereShape(btScalar radius_0)  {
  public metafunction __base__ {btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getRadius" btScalar getRadius() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUnscaledRadius" void setUnscaledRadius(btScalar radius_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btSphereSphereCollisionAlgorithm" "nodefault" btSphereSphereCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} col0Wrap_2, crptr{btCollisionObjectWrapper} col1Wrap_3)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btSphereTriangleCollisionAlgorithm" "nodefault" btSphereTriangleCollisionAlgorithm(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool swapped_4)  {
  public metafunction __base__ {btActivatingCollisionAlgorithm, btCollisionAlgorithm};
  public function extern "calculateTimeOfImpact" btScalar calculateTimeOfImpact(rptr{btCollisionObject} body0_0, rptr{btCollisionObject} body1_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
  public function extern "processCollision" void processCollision(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1, btDispatcherInfo const& dispatchInfo_2, rptr{btManifoldResult} resultOut_3);
}
public pure struct extern "::btStackAlloc" "nodefault" btStackAlloc(uint size_0)  {
  public function extern "allocate" rptr{uchar} allocate(uint size_0);
  public function extern "beginBlock" rptr{btBlock} beginBlock();
  public function extern "create" void create(uint size_0);
  public function extern "destroy" void destroy();
  public function extern "endBlock" void endBlock(rptr{btBlock} block_0);
  public function extern "getAvailableMemory" int getAvailableMemory() const;
}
public pure struct extern "::btStaticPlaneShape" "nodefault" btStaticPlaneShape(btVector3 const& planeNormal_0, btScalar planeConstant_1)  {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getPlaneConstant" btScalar const& getPlaneConstant() const;
  public function extern "getPlaneNormal" btVector3 const& getPlaneNormal() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btStaticPlaneShapeData" btStaticPlaneShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public btVector3FloatData m_localScaling;
  public btVector3FloatData m_planeNormal;
  public float m_planeConstant;
  public rawarray{char, 4} m_pad;
}
public pure struct extern "::btStorageResult" "nonmovable" btStorageResult {
  public metafunction __base__ {btDiscreteCollisionDetectorInterface_Result};
  public function extern "addContactPoint" void addContactPoint(btVector3 const& normalOnBInWorld_0, btVector3 const& pointInWorld_1, btScalar depth_2);
  public function extern "setShapeIdentifiersA" void setShapeIdentifiersA(int partId0_0, int index0_1);
  public function extern "setShapeIdentifiersB" void setShapeIdentifiersB(int partId1_0, int index1_1);
  public btVector3 m_normalOnSurfaceB;
  public btVector3 m_closestPointInB;
  public btScalar m_distance;
}
public pure struct extern "::btStridingMeshInterface" "nonmovable" btStridingMeshInterface {
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
}
public pure struct extern "::btStridingMeshInterfaceData" btStridingMeshInterfaceData {
  public rptr{btMeshPartData} m_meshPartsPtr;
  public btVector3FloatData m_scaling;
  public int m_numMeshParts;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btSubSimplexClosestResult" btSubSimplexClosestResult {
  public function extern "isValid" bool isValid();
  public function extern "reset" void reset();
  public function extern "setBarycentricCoordinates" void setBarycentricCoordinates(btScalar a_0, btScalar b_1, btScalar c_2, btScalar d_3);
  public btVector3 m_closestPointOnSimplex;
  public btUsageBitfield m_usedVertices;
  public rawarray{btScalar, 4} m_barycentricCoords;
  public bool m_degenerate;
}
public pure struct extern "::btSubsimplexConvexCast" "nodefault" btSubsimplexConvexCast(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2)  {
  public metafunction __base__ {btConvexCast};
  public function extern "calcTimeOfImpact" bool calcTimeOfImpact(btTransform const& fromA_0, btTransform const& toA_1, btTransform const& fromB_2, btTransform const& toB_3, btConvexCast_CastResult mutable& result_4);
}
public pure struct extern "::btSymmetricSpatialDyad" btSymmetricSpatialDyad {
  public function extern "addMatrix" void addMatrix(btMatrix3x3 const& topLeftMat_0, btMatrix3x3 const& topRightMat_1, btMatrix3x3 const& bottomLeftMat_2);
  public function extern "setIdentity" void setIdentity();
  public function extern "setMatrix" void setMatrix(btMatrix3x3 const& topLeftMat_0, btMatrix3x3 const& topRightMat_1, btMatrix3x3 const& bottomLeftMat_2);
  public btMatrix3x3 m_topLeftMat;
  public btMatrix3x3 m_topRightMat;
  public btMatrix3x3 m_bottomLeftMat;
}
public pure tsvaluetype struct extern "::btTransform" btTransform {
  public function extern "deSerialize" void deSerialize(btTransformFloatData const& dataIn_0);
  public function extern "deSerializeDouble" void deSerializeDouble(btTransformDoubleData const& dataIn_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btTransformFloatData const& dataIn_0);
  public function extern "getBasis" btMatrix3x3 mutable& getBasis();
  public function extern "getBasis" btMatrix3x3 const& cgetBasis() const;
  public function extern "getOpenGLMatrix" void getOpenGLMatrix(rptr{btScalar} m_0) const;
  public function extern "getOrigin" btVector3 mutable& getOrigin();
  public function extern "getOrigin" btVector3 const& cgetOrigin() const;
  public function extern "getRotation" btQuaternion getRotation() const;
  public function extern "invXform" btVector3 invXform(btVector3 const& inVec_0) const;
  public function extern "inverse" btTransform inverse() const;
  public function extern "inverseTimes" btTransform inverseTimes(btTransform const& t_0) const;
  public function extern "mult" void mult(btTransform const& t1_0, btTransform const& t2_1);
  public function extern "serialize" void serialize(btTransformFloatData mutable& dataOut_0) const;
  public function extern "serializeFloat" void serializeFloat(btTransformFloatData mutable& dataOut_0) const;
  public function extern "setBasis" void setBasis(btMatrix3x3 const& basis_0);
  public function extern "setFromOpenGLMatrix" void setFromOpenGLMatrix(crptr{btScalar} m_0);
  public function extern "setIdentity" void setIdentity();
  public function extern "setOrigin" void setOrigin(btVector3 const& origin_0);
  public function extern "setRotation" void setRotation(btQuaternion const& q_0);
}
public pure struct extern "::btTransformDoubleData" btTransformDoubleData {
  public btMatrix3x3DoubleData m_basis;
  public btVector3DoubleData m_origin;
}
public pure struct extern "::btTransformFloatData" btTransformFloatData {
  public btMatrix3x3FloatData m_basis;
  public btVector3FloatData m_origin;
}
public pure struct extern "::btTransformUtil" btTransformUtil {
}
public pure struct extern "::btTranslationalLimitMotor" btTranslationalLimitMotor {
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "needApplyForce" bool needApplyForce(int limitIndex_0);
  public function extern "solveLinearAxis" btScalar solveLinearAxis(btScalar timeStep_0, btScalar jacDiagABInv_1, btRigidBody mutable& body1_2, btVector3 const& pointInA_3, btRigidBody mutable& body2_4, btVector3 const& pointInB_5, int limit_index_6, btVector3 const& axis_normal_on_a_7, btVector3 const& anchorPos_8);
  public function extern "testLimitValue" int testLimitValue(int limitIndex_0, btScalar test_value_1);
  public btVector3 m_lowerLimit;
  public btVector3 m_upperLimit;
  public btVector3 m_accumulatedImpulse;
  public btScalar m_limitSoftness;
  public btScalar m_damping;
  public btScalar m_restitution;
  public btVector3 m_normalCFM;
  public btVector3 m_stopERP;
  public btVector3 m_stopCFM;
  public rawarray{bool, 3} m_enableMotor;
  public btVector3 m_targetVelocity;
  public btVector3 m_maxMotorForce;
  public btVector3 m_currentLimitError;
  public btVector3 m_currentLinearDiff;
  public rawarray{int, 3} m_currentLimit;
}
public pure struct extern "::btTranslationalLimitMotor2" btTranslationalLimitMotor2 {
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "testLimitValue" void testLimitValue(int limitIndex_0, btScalar test_value_1);
  public btVector3 m_lowerLimit;
  public btVector3 m_upperLimit;
  public btVector3 m_bounce;
  public btVector3 m_stopERP;
  public btVector3 m_stopCFM;
  public btVector3 m_motorERP;
  public btVector3 m_motorCFM;
  public rawarray{bool, 3} m_enableMotor;
  public rawarray{bool, 3} m_servoMotor;
  public rawarray{bool, 3} m_enableSpring;
  public btVector3 m_servoTarget;
  public btVector3 m_springStiffness;
  public rawarray{bool, 3} m_springStiffnessLimited;
  public btVector3 m_springDamping;
  public rawarray{bool, 3} m_springDampingLimited;
  public btVector3 m_equilibriumPoint;
  public btVector3 m_targetVelocity;
  public btVector3 m_maxMotorForce;
  public btVector3 m_currentLimitError;
  public btVector3 m_currentLimitErrorHi;
  public btVector3 m_currentLinearDiff;
  public rawarray{int, 3} m_currentLimit;
}
public pure tsvaluetype struct extern "::btQuantizedBvh::btTraversalMode" "extenum" btQuantizedBvh_btTraversalMode { }
public extern "TRAVERSAL_STACKLESS" btQuantizedBvh_btTraversalMode btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS;
public extern "TRAVERSAL_STACKLESS_CACHE_FRIENDLY" btQuantizedBvh_btTraversalMode btQuantizedBvh_btTraversalMode_TRAVERSAL_STACKLESS_CACHE_FRIENDLY;
public extern "TRAVERSAL_RECURSIVE" btQuantizedBvh_btTraversalMode btQuantizedBvh_btTraversalMode_TRAVERSAL_RECURSIVE;
public pure struct extern "::btTriangle" btTriangle {
  public btVector3 m_vertex0;
  public btVector3 m_vertex1;
  public btVector3 m_vertex2;
  public int m_partId;
  public int m_triangleIndex;
}
public pure struct extern "::btTriangleBuffer" "nonmovable" btTriangleBuffer {
  public metafunction __base__ {btTriangleCallback};
  public function extern "clearBuffer" void clearBuffer();
  public function extern "getNumTriangles" int getNumTriangles() const;
  public function extern "getTriangle" btTriangle const& getTriangle(int index_0) const;
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
}
public pure struct extern "::btTriangleCallback" "nonmovable" btTriangleCallback {
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
}
public pure struct extern "::btTriangleConvexcastCallback" "nodefault" btTriangleConvexcastCallback(crptr{btConvexShape} convexShape_0, btTransform const& convexShapeFrom_1, btTransform const& convexShapeTo_2, btTransform const& triangleToWorld_3, btScalar const triangleCollisionMargin_4)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public function extern "reportHit" btScalar reportHit(btVector3 const& hitNormalLocal_0, btVector3 const& hitPointLocal_1, btScalar hitFraction_2, int partId_3, int triangleIndex_4);
  public crptr{btConvexShape} m_convexShape;
  public btTransform m_convexShapeFrom;
  public btTransform m_convexShapeTo;
  public btTransform m_triangleToWorld;
  public btScalar m_hitFraction;
  public btScalar m_triangleCollisionMargin;
  public btScalar m_allowedPenetration;
}
public pure struct extern "::btTriangleIndexVertexArray" "nonmovable" btTriangleIndexVertexArray {
  public metafunction __base__ {btStridingMeshInterface};
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh_0, PHY_ScalarType indexType_1);
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
}
public pure struct extern "::btTriangleIndexVertexMaterialArray" "nonmovable" btTriangleIndexVertexMaterialArray {
  public metafunction __base__ {btTriangleIndexVertexArray, btStridingMeshInterface};
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh_0, PHY_ScalarType indexType_1);
  public function extern "addMaterialProperties" void addMaterialProperties(btMaterialProperties const& mat_0, PHY_ScalarType triangleType_1);
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "getLockedMaterialBase" void getLockedMaterialBase(rptr{rptr{uchar}} materialBase_0, int mutable& numMaterials_1, PHY_ScalarType mutable& materialType_2, int mutable& materialStride_3, rptr{rptr{uchar}} triangleMaterialBase_4, int mutable& numTriangles_5, int mutable& triangleMaterialStride_6, PHY_ScalarType mutable& triangleType_7, int subpart_8);
  public function extern "getLockedReadOnlyMaterialBase" void getLockedReadOnlyMaterialBase(rptr{crptr{uchar}} materialBase_0, int mutable& numMaterials_1, PHY_ScalarType mutable& materialType_2, int mutable& materialStride_3, rptr{crptr{uchar}} triangleMaterialBase_4, int mutable& numTriangles_5, int mutable& triangleMaterialStride_6, PHY_ScalarType mutable& triangleType_7, int subpart_8);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
}
public pure struct extern "::btTriangleInfo" btTriangleInfo {
  public int m_flags;
  public btScalar m_edgeV0V1Angle;
  public btScalar m_edgeV1V2Angle;
  public btScalar m_edgeV2V0Angle;
}
public pure struct extern "::btTriangleInfoData" btTriangleInfoData {
  public int m_flags;
  public float m_edgeV0V1Angle;
  public float m_edgeV1V2Angle;
  public float m_edgeV2V0Angle;
}
public pure struct extern "::btTriangleInfoMapData" btTriangleInfoMapData {
  public rptr{int} m_hashTablePtr;
  public rptr{int} m_nextPtr;
  public rptr{btTriangleInfoData} m_valueArrayPtr;
  public rptr{int} m_keyArrayPtr;
  public float m_convexEpsilon;
  public float m_planarEpsilon;
  public float m_equalVertexThreshold;
  public float m_edgeDistanceThreshold;
  public float m_zeroAreaThreshold;
  public int m_nextSize;
  public int m_hashTableSize;
  public int m_numValues;
  public int m_numKeys;
  public rawarray{char, 4} m_padding;
}
public pure struct extern "::btTriangleMesh" "nodefault" btTriangleMesh(bool use32bitIndices_0, bool use4componentVertices_1)  {
  public metafunction __base__ {btTriangleIndexVertexArray, btStridingMeshInterface};
  public function extern "InternalProcessAllTriangles" void InternalProcessAllTriangles(rptr{btInternalTriangleIndexCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "addIndex" void addIndex(int index_0);
  public function extern "addIndexedMesh" void addIndexedMesh(btIndexedMesh const& mesh_0, PHY_ScalarType indexType_1);
  public function extern "addTriangle" void addTriangle(btVector3 const& vertex0_0, btVector3 const& vertex1_1, btVector3 const& vertex2_2, bool removeDuplicateVertices_3);
  public function extern "addTriangleIndices" void addTriangleIndices(int index1_0, int index2_1, int index3_2);
  public function extern "calculateAabbBruteForce" void calculateAabbBruteForce(btVector3 mutable& aabbMin_0, btVector3 mutable& aabbMax_1);
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "findOrAddVertex" int findOrAddVertex(btVector3 const& vertex_0, bool removeDuplicateVertices_1);
  public function extern "getLockedReadOnlyVertexIndexBase" void getLockedReadOnlyVertexIndexBase(rptr{crptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{crptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8) const;
  public function extern "getLockedVertexIndexBase" void getLockedVertexIndexBase(rptr{rptr{uchar}} vertexbase_0, int mutable& numverts_1, PHY_ScalarType mutable& type_2, int mutable& stride_3, rptr{rptr{uchar}} indexbase_4, int mutable& indexstride_5, int mutable& numfaces_6, PHY_ScalarType mutable& indicestype_7, int subpart_8);
  public function extern "getNumSubParts" int getNumSubParts() const;
  public function extern "getNumTriangles" int getNumTriangles() const;
  public function extern "getPremadeAabb" void getPremadeAabb(rptr{btVector3} aabbMin_0, rptr{btVector3} aabbMax_1) const;
  public function extern "getScaling" btVector3 const& getScaling() const;
  public function extern "getUse32bitIndices" bool getUse32bitIndices() const;
  public function extern "getUse4componentVertices" bool getUse4componentVertices() const;
  public function extern "hasPremadeAabb" bool hasPremadeAabb() const;
  public function extern "preallocateIndices" void preallocateIndices(int numindices_0);
  public function extern "preallocateVertices" void preallocateVertices(int numverts_0);
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setPremadeAabb" void setPremadeAabb(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1) const;
  public function extern "setScaling" void setScaling(btVector3 const& scaling_0);
  public function extern "unLockReadOnlyVertexBase" void unLockReadOnlyVertexBase(int subpart_0) const;
  public function extern "unLockVertexBase" void unLockVertexBase(int subpart_0);
  public btScalar m_weldingThreshold;
}
public pure struct extern "::btTriangleMeshShape" "nodefault" btTriangleMeshShape private {
  public metafunction __base__ {btConcaveShape, btCollisionShape};
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalAabbMax" btVector3 const& getLocalAabbMax() const;
  public function extern "getLocalAabbMin" btVector3 const& getLocalAabbMin() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMeshInterface" rptr{btStridingMeshInterface} getMeshInterface();
  public function extern "getMeshInterface" crptr{btStridingMeshInterface} cgetMeshInterface() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "processAllTriangles" void processAllTriangles(rptr{btTriangleCallback} callback_0, btVector3 const& aabbMin_1, btVector3 const& aabbMax_2) const;
  public function extern "recalcLocalAabb" void recalcLocalAabb();
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btTriangleMeshShapeData" btTriangleMeshShapeData {
  public btCollisionShapeData m_collisionShapeData;
  public btStridingMeshInterfaceData m_meshInterface;
  public rptr{btQuantizedBvhFloatData} m_quantizedFloatBvh;
  public rptr{btQuantizedBvhDoubleData} m_quantizedDoubleBvh;
  public rptr{btTriangleInfoMapData} m_triangleInfoMap;
  public float m_collisionMargin;
  public rawarray{char, 4} m_pad3;
}
public pure struct extern "::btTriangleRaycastCallback" "nodefault" btTriangleRaycastCallback(btVector3 const& from_0, btVector3 const& to_1, uint flags_2)  {
  public metafunction __base__ {btTriangleCallback};
  public function extern "processTriangle" void processTriangle(rptr{btVector3} triangle_0, int partId_1, int triangleIndex_2);
  public function extern "reportHit" btScalar reportHit(btVector3 const& hitNormalLocal_0, btScalar hitFraction_1, int partId_2, int triangleIndex_3);
  public btVector3 m_from;
  public btVector3 m_to;
  public uint m_flags;
  public btScalar m_hitFraction;
}
public pure struct extern "::btTriangleShape" "nonmovable" btTriangleShape {
  public metafunction __base__ {btPolyhedralConvexShape, btConvexInternalShape, btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calcNormal" void calcNormal(btVector3 mutable& normal_0) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getConvexPolyhedron" crptr{btConvexPolyhedron} getConvexPolyhedron() const;
  public function extern "getEdge" void getEdge(int i_0, btVector3 mutable& pa_1, btVector3 mutable& pb_2) const;
  public function extern "getImplicitShapeDimensions" btVector3 const& getImplicitShapeDimensions() const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getLocalScalingNV" btVector3 const& getLocalScalingNV() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNV" btScalar getMarginNV() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumEdges" int getNumEdges() const;
  public function extern "getNumPlanes" int getNumPlanes() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getNumVertices" int getNumVertices() const;
  public function extern "getPlane" void getPlane(btVector3 mutable& planeNormal_0, btVector3 mutable& planeSupport_1, int i_2) const;
  public function extern "getPlaneEquation" void getPlaneEquation(int i_0, btVector3 mutable& planeNormal_1, btVector3 mutable& planeSupport_2) const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "getVertex" void getVertex(int i_0, btVector3 mutable& vtx_1) const;
  public function extern "getVertexPtr" btVector3 mutable& getVertexPtr(int index_0);
  public function extern "getVertexPtr" btVector3 const& cgetVertexPtr(int index_0) const;
  public function extern "initializePolyhedralFeatures" bool initializePolyhedralFeatures(int shiftVerticesByMargin_0);
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isInside" bool isInside(btVector3 const& pt_0, btScalar tolerance_1) const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setImplicitShapeDimensions" void setImplicitShapeDimensions(btVector3 const& dimensions_0);
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setSafeMargin" void setSafeMargin_btScalar_btScalar(btScalar minDimension_0, btScalar defaultMarginMultiplier_1);
  public function extern "setSafeMargin" void setSafeMargin_btVector3_btScalar(btVector3 const& halfExtents_0, btScalar defaultMarginMultiplier_1);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
  public rawarray{btVector3, 3} m_vertices1;
}
public pure struct extern "::btTypedConstraint" "nodefault" btTypedConstraint(btTypedConstraintType type_0, btRigidBody mutable& rbA_1)  {
  public metafunction __base__ {btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getUid" int getUid() const;
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public int m_objectType;
}
public pure struct extern "::btTypedConstraintData" btTypedConstraintData {
  public rptr{btRigidBodyFloatData} m_rbA;
  public rptr{btRigidBodyFloatData} m_rbB;
  public rptr{char} m_name;
  public int m_objectType;
  public int m_userConstraintType;
  public int m_userConstraintId;
  public int m_needsFeedback;
  public float m_appliedImpulse;
  public float m_dbgDrawSize;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_overrideNumSolverIterations;
  public float m_breakingImpulseThreshold;
  public int m_isEnabled;
}
public pure struct extern "::btTypedConstraintDoubleData" btTypedConstraintDoubleData {
  public rptr{btRigidBodyDoubleData} m_rbA;
  public rptr{btRigidBodyDoubleData} m_rbB;
  public rptr{char} m_name;
  public int m_objectType;
  public int m_userConstraintType;
  public int m_userConstraintId;
  public int m_needsFeedback;
  public double m_appliedImpulse;
  public double m_dbgDrawSize;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_overrideNumSolverIterations;
  public double m_breakingImpulseThreshold;
  public int m_isEnabled;
  public rawarray{char, 4} padding;
}
public pure struct extern "::btTypedConstraintFloatData" btTypedConstraintFloatData {
  public rptr{btRigidBodyFloatData} m_rbA;
  public rptr{btRigidBodyFloatData} m_rbB;
  public rptr{char} m_name;
  public int m_objectType;
  public int m_userConstraintType;
  public int m_userConstraintId;
  public int m_needsFeedback;
  public float m_appliedImpulse;
  public float m_dbgDrawSize;
  public int m_disableCollisionsBetweenLinkedBodies;
  public int m_overrideNumSolverIterations;
  public float m_breakingImpulseThreshold;
  public int m_isEnabled;
}
public pure tsvaluetype struct extern "::btTypedConstraintType" "extenum" btTypedConstraintType { }
public extern "POINT2POINT_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_POINT2POINT_CONSTRAINT_TYPE;
public extern "HINGE_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_HINGE_CONSTRAINT_TYPE;
public extern "CONETWIST_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_CONETWIST_CONSTRAINT_TYPE;
public extern "D6_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_D6_CONSTRAINT_TYPE;
public extern "SLIDER_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_SLIDER_CONSTRAINT_TYPE;
public extern "CONTACT_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_CONTACT_CONSTRAINT_TYPE;
public extern "D6_SPRING_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_D6_SPRING_CONSTRAINT_TYPE;
public extern "GEAR_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_GEAR_CONSTRAINT_TYPE;
public extern "FIXED_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_FIXED_CONSTRAINT_TYPE;
public extern "D6_SPRING_2_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_D6_SPRING_2_CONSTRAINT_TYPE;
public extern "MAX_CONSTRAINT_TYPE" btTypedConstraintType btTypedConstraintType_MAX_CONSTRAINT_TYPE;
public pure struct extern "::btTypedObject" "nodefault" btTypedObject(int objectType_0)  {
  public function extern "getObjectType" int getObjectType() const;
  public int m_objectType;
}
public pure struct extern "::btUniformScalingShape" "nodefault" btUniformScalingShape(rptr{btConvexShape} convexChildShape_0, btScalar uniformScalingFactor_1)  {
  public metafunction __base__ {btConvexShape, btCollisionShape};
  public function extern "batchedUnitVectorGetSupportingVertexWithoutMargin" void batchedUnitVectorGetSupportingVertexWithoutMargin(crptr{btVector3} vectors_0, rptr{btVector3} supportVerticesOut_1, int numVectors_2) const;
  public function extern "calculateLocalInertia" void calculateLocalInertia(btScalar mass_0, btVector3 mutable& inertia_1) const;
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTemporalAabb" void calculateTemporalAabb(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btVector3 mutable& temporalAabbMin_4, btVector3 mutable& temporalAabbMax_5) const;
  public function extern "getAabb" void getAabb(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbNonVirtual" void getAabbNonVirtual(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAabbSlow" void getAabbSlow(btTransform const& t_0, btVector3 mutable& aabbMin_1, btVector3 mutable& aabbMax_2) const;
  public function extern "getAngularMotionDisc" btScalar getAngularMotionDisc() const;
  public function extern "getAnisotropicRollingFrictionDirection" btVector3 getAnisotropicRollingFrictionDirection() const;
  public function extern "getBoundingSphere" void getBoundingSphere(btVector3 mutable& center_0, btScalar mutable& radius_1) const;
  public function extern "getChildShape" rptr{btConvexShape} getChildShape();
  public function extern "getChildShape" crptr{btConvexShape} cgetChildShape() const;
  public function extern "getContactBreakingThreshold" btScalar getContactBreakingThreshold(btScalar defaultContactThresholdFactor_0) const;
  public function extern "getLocalScaling" btVector3 const& getLocalScaling() const;
  public function extern "getMargin" btScalar getMargin() const;
  public function extern "getMarginNonVirtual" btScalar getMarginNonVirtual() const;
  public function extern "getName" crptr{char} getName() const;
  public function extern "getNumPreferredPenetrationDirections" int getNumPreferredPenetrationDirections() const;
  public function extern "getPreferredPenetrationDirection" void getPreferredPenetrationDirection(int index_0, btVector3 mutable& penetrationVector_1) const;
  public function extern "getShapeType" int getShapeType() const;
  public function extern "getUniformScalingFactor" btScalar getUniformScalingFactor() const;
  public function extern "getUserIndex" int getUserIndex() const;
  public function extern "getUserPointer" rptr{void} getUserPointer() const;
  public function extern "isCompound" bool isCompound() const;
  public function extern "isConcave" bool isConcave() const;
  public function extern "isConvex" bool isConvex() const;
  public function extern "isConvex2d" bool isConvex2d() const;
  public function extern "isInfinite" bool isInfinite() const;
  public function extern "isNonMoving" bool isNonMoving() const;
  public function extern "isPolyhedral" bool isPolyhedral() const;
  public function extern "isSoftBody" bool isSoftBody() const;
  public function extern "localGetSupportVertexNonVirtual" btVector3 localGetSupportVertexNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportVertexWithoutMarginNonVirtual" btVector3 localGetSupportVertexWithoutMarginNonVirtual(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertex" btVector3 localGetSupportingVertex(btVector3 const& vec_0) const;
  public function extern "localGetSupportingVertexWithoutMargin" btVector3 localGetSupportingVertexWithoutMargin(btVector3 const& vec_0) const;
  public function extern "project" void project(btTransform const& trans_0, btVector3 const& dir_1, btScalar mutable& min_2, btScalar mutable& max_3) const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "serializeSingleShape" void serializeSingleShape(rptr{btSerializer} serializer_0) const;
  public function extern "setLocalScaling" void setLocalScaling(btVector3 const& scaling_0);
  public function extern "setMargin" void setMargin(btScalar margin_0);
  public function extern "setUserIndex" void setUserIndex(int index_0);
  public function extern "setUserPointer" void setUserPointer(rptr{void} userPtr_0);
}
public pure struct extern "::btUnionFind" btUnionFind {
  public function extern "Free" void Free();
  public function extern "allocate" void allocate(int N_0);
  public function extern "find" int find1(int x_0);
  public function extern "find" int find2(int p_0, int q_1);
  public function extern "getElement" btElement mutable& getElement(int index_0);
  public function extern "getElement" btElement const& cgetElement(int index_0) const;
  public function extern "getNumElements" int getNumElements() const;
  public function extern "isRoot" bool isRoot(int x_0) const;
  public function extern "reset" void reset(int N_0);
  public function extern "sortIslands" void sortIslands();
  public function extern "unite" void unite(int p_0, int q_1);
}
public pure struct extern "::btUniversalConstraint" "nodefault" btUniversalConstraint(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& anchor_2, btVector3 const& axis1_3, btVector3 const& axis2_4)  {
  public metafunction __base__ {btGeneric6DofConstraint, btTypedConstraint, btTypedObject};
  public function extern "buildJacobian" void buildJacobian();
  public function extern "calcAnchorPos" void calcAnchorPos();
  public function extern "calculateSerializeBufferSize" int calculateSerializeBufferSize() const;
  public function extern "calculateTransforms" void calculateTransforms0();
  public function extern "calculateTransforms" void calculateTransforms2(btTransform const& transA_0, btTransform const& transB_1);
  public function extern "enableFeedback" void enableFeedback(bool needsFeedback_0);
  public function extern "getAnchor" btVector3 const& getAnchor();
  public function extern "getAnchor2" btVector3 const& getAnchor2();
  public function extern "getAngle" btScalar getAngle(int axis_index_0) const;
  public function extern "getAngle1" btScalar getAngle1();
  public function extern "getAngle2" btScalar getAngle2();
  public function extern "getAngularLowerLimit" void getAngularLowerLimit(btVector3 mutable& angularLower_0);
  public function extern "getAngularUpperLimit" void getAngularUpperLimit(btVector3 mutable& angularUpper_0);
  public function extern "getAppliedImpulse" btScalar getAppliedImpulse() const;
  public function extern "getAxis" btVector3 getAxis(int axis_index_0) const;
  public function extern "getAxis1" btVector3 const& getAxis1();
  public function extern "getAxis2" btVector3 const& getAxis2();
  public function extern "getBreakingImpulseThreshold" btScalar getBreakingImpulseThreshold() const;
  public function extern "getCalculatedTransformA" btTransform const& getCalculatedTransformA() const;
  public function extern "getCalculatedTransformB" btTransform const& getCalculatedTransformB() const;
  public function extern "getConstraintType" btTypedConstraintType getConstraintType() const;
  public function extern "getDbgDrawSize" btScalar getDbgDrawSize();
  public function extern "getFrameOffsetA" btTransform mutable& getFrameOffsetA();
  public function extern "getFrameOffsetA" btTransform const& cgetFrameOffsetA() const;
  public function extern "getFrameOffsetB" btTransform mutable& getFrameOffsetB();
  public function extern "getFrameOffsetB" btTransform const& cgetFrameOffsetB() const;
  public function extern "getInfo1" void getInfo1(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo1NonVirtual" void getInfo1NonVirtual(rptr{btTypedConstraint_btConstraintInfo1} info_0);
  public function extern "getInfo2" void getInfo2(rptr{btTypedConstraint_btConstraintInfo2} info_0);
  public function extern "getInfo2NonVirtual" void getInfo2NonVirtual(rptr{btTypedConstraint_btConstraintInfo2} info_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6);
  public function extern "getJointFeedback" rptr{btJointFeedback} getJointFeedback();
  public function extern "getJointFeedback" crptr{btJointFeedback} cgetJointFeedback() const;
  public function extern "getLinearLowerLimit" void getLinearLowerLimit(btVector3 mutable& linearLower_0);
  public function extern "getLinearUpperLimit" void getLinearUpperLimit(btVector3 mutable& linearUpper_0);
  public function extern "getObjectType" int getObjectType() const;
  public function extern "getOverrideNumSolverIterations" int getOverrideNumSolverIterations() const;
  public function extern "getParam" btScalar getParam(int num_0, int axis_1) const;
  public function extern "getRelativePivotPosition" btScalar getRelativePivotPosition(int axis_index_0) const;
  public function extern "getRigidBodyA" btRigidBody mutable& getRigidBodyA();
  public function extern "getRigidBodyA" btRigidBody const& cgetRigidBodyA() const;
  public function extern "getRigidBodyB" btRigidBody mutable& getRigidBodyB();
  public function extern "getRigidBodyB" btRigidBody const& cgetRigidBodyB() const;
  public function extern "getRotationalLimitMotor" rptr{btRotationalLimitMotor} getRotationalLimitMotor(int index_0);
  public function extern "getTranslationalLimitMotor" rptr{btTranslationalLimitMotor} getTranslationalLimitMotor();
  public function extern "getUid" int getUid() const;
  public function extern "getUseFrameOffset" bool getUseFrameOffset();
  public function extern "getUserConstraintId" int getUserConstraintId() const;
  public function extern "getUserConstraintPtr" rptr{void} getUserConstraintPtr();
  public function extern "getUserConstraintType" int getUserConstraintType() const;
  public function extern "get_limit_motor_info2" int get_limit_motor_info2(rptr{btRotationalLimitMotor} limot_0, btTransform const& transA_1, btTransform const& transB_2, btVector3 const& linVelA_3, btVector3 const& linVelB_4, btVector3 const& angVelA_5, btVector3 const& angVelB_6, rptr{btTypedConstraint_btConstraintInfo2} info_7, int row_8, btVector3 mutable& ax1_9, int rotational_10, int rotAllowed_11);
  public function extern "internalGetAppliedImpulse" btScalar internalGetAppliedImpulse();
  public function extern "internalSetAppliedImpulse" void internalSetAppliedImpulse(btScalar appliedImpulse_0);
  public function extern "isEnabled" bool isEnabled() const;
  public function extern "isLimited" bool isLimited(int limitIndex_0);
  public function extern "needsFeedback" bool needsFeedback() const;
  public function extern "serialize" crptr{char} serialize(rptr{void} dataBuffer_0, rptr{btSerializer} serializer_1) const;
  public function extern "setAngularLowerLimit" void setAngularLowerLimit(btVector3 const& angularLower_0);
  public function extern "setAngularUpperLimit" void setAngularUpperLimit(btVector3 const& angularUpper_0);
  public function extern "setAxis" void setAxis(btVector3 const& axis1_0, btVector3 const& axis2_1);
  public function extern "setBreakingImpulseThreshold" void setBreakingImpulseThreshold(btScalar threshold_0);
  public function extern "setDbgDrawSize" void setDbgDrawSize(btScalar dbgDrawSize_0);
  public function extern "setEnabled" void setEnabled(bool enabled_0);
  public function extern "setFrames" void setFrames(btTransform const& frameA_0, btTransform const& frameB_1);
  public function extern "setJointFeedback" void setJointFeedback(rptr{btJointFeedback} jointFeedback_0);
  public function extern "setLimit" void setLimit(int axis_0, btScalar lo_1, btScalar hi_2);
  public function extern "setLinearLowerLimit" void setLinearLowerLimit(btVector3 const& linearLower_0);
  public function extern "setLinearUpperLimit" void setLinearUpperLimit(btVector3 const& linearUpper_0);
  public function extern "setLowerLimit" void setLowerLimit(btScalar ang1min_0, btScalar ang2min_1);
  public function extern "setOverrideNumSolverIterations" void setOverrideNumSolverIterations(int overideNumIterations_0);
  public function extern "setParam" void setParam(int num_0, btScalar value_1, int axis_2);
  public function extern "setUpperLimit" void setUpperLimit(btScalar ang1max_0, btScalar ang2max_1);
  public function extern "setUseFrameOffset" void setUseFrameOffset(bool frameOffsetOnOff_0);
  public function extern "setUserConstraintId" void setUserConstraintId(int uid_0);
  public function extern "setUserConstraintPtr" void setUserConstraintPtr(rptr{void} ptr_0);
  public function extern "setUserConstraintType" void setUserConstraintType(int userConstraintType_0);
  public function extern "solveConstraintObsolete" void solveConstraintObsolete(btSolverBody mutable& _0, btSolverBody mutable& _1, btScalar _2);
  public function extern "testAngularLimitMotor" bool testAngularLimitMotor(int axis_index_0);
  public function extern "updateRHS" void updateRHS(btScalar timeStep_0);
  public bool m_useSolveConstraintObsolete;
  public int m_objectType;
}
public pure struct extern "::btUsageBitfield" btUsageBitfield {
  public function extern "reset" void reset();
  public ushort usedVertexA;
  public ushort usedVertexB;
  public ushort usedVertexC;
  public ushort usedVertexD;
  public ushort unused1;
  public ushort unused2;
  public ushort unused3;
  public ushort unused4;
}
public pure tsvaluetype struct extern "::btVector3" btVector3 {
  public function extern "absolute" btVector3 absolute() const;
  public function extern "angle" btScalar angle(btVector3 const& v_0) const;
  public function extern "closestAxis" int closestAxis() const;
  public function extern "cross" btVector3 cross(btVector3 const& v_0) const;
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn_0);
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn_0);
  public function extern "distance" btScalar distance(btVector3 const& v_0) const;
  public function extern "distance2" btScalar distance2(btVector3 const& v_0) const;
  public function extern "dot" btScalar dot(btVector3 const& v_0) const;
  public function extern "dot3" btVector3 dot3(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2) const;
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0_0, rptr{btVector3} v1_1, rptr{btVector3} v2_2) const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "isZero" bool isZero() const;
  public function extern "length" btScalar length() const;
  public function extern "length2" btScalar length2() const;
  public function extern "lerp" btVector3 lerp(btVector3 const& v_0, btScalar const& t_1) const;
  public function extern "maxAxis" int maxAxis() const;
  public function extern "maxDot" long maxDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "minAxis" int minAxis() const;
  public function extern "minDot" long minDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "norm" btScalar norm() const;
  public function extern "normalize" btVector3 mutable& normalize();
  public function extern "normalized" btVector3 normalized() const;
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis_0, btScalar const angle_1) const;
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut_0) const;
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut_0) const;
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut_0) const;
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0_0, btVector3 const& v1_1, btScalar rt_2);
  public function extern "setMax" void setMax(btVector3 const& other_0);
  public function extern "setMin" void setMin(btVector3 const& other_0);
  public function extern "setValue" void setValue(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "setZero" void setZero();
  public function extern "triple" btScalar triple(btVector3 const& v1_0, btVector3 const& v2_1) const;
  public function extern "w" btScalar const& w() const;
  public function extern "x" btScalar const& x() const;
  public function extern "y" btScalar const& y() const;
  public function extern "z" btScalar const& z() const;
  public rawarray{btScalar, 4} m_floats;
}
public pure struct extern "::btVector3DoubleData" btVector3DoubleData {
  public rawarray{double, 4} m_floats;
}
public pure struct extern "::btVector3FloatData" btVector3FloatData {
  public rawarray{float, 4} m_floats;
}
public pure struct extern "::btVector4" btVector4 {
  public metafunction __base__ {btVector3};
  public function extern "absolute" btVector3 absolute() const;
  public function extern "absolute4" btVector4 absolute4() const;
  public function extern "angle" btScalar angle(btVector3 const& v_0) const;
  public function extern "closestAxis" int closestAxis() const;
  public function extern "closestAxis4" int closestAxis4() const;
  public function extern "cross" btVector3 cross(btVector3 const& v_0) const;
  public function extern "deSerialize" void deSerialize(btVector3FloatData const& dataIn_0);
  public function extern "deSerializeDouble" void deSerializeDouble(btVector3DoubleData const& dataIn_0);
  public function extern "deSerializeFloat" void deSerializeFloat(btVector3FloatData const& dataIn_0);
  public function extern "distance" btScalar distance(btVector3 const& v_0) const;
  public function extern "distance2" btScalar distance2(btVector3 const& v_0) const;
  public function extern "dot" btScalar dot(btVector3 const& v_0) const;
  public function extern "dot3" btVector3 dot3(btVector3 const& v0_0, btVector3 const& v1_1, btVector3 const& v2_2) const;
  public function extern "furthestAxis" int furthestAxis() const;
  public function extern "fuzzyZero" bool fuzzyZero() const;
  public function extern "getSkewSymmetricMatrix" void getSkewSymmetricMatrix(rptr{btVector3} v0_0, rptr{btVector3} v1_1, rptr{btVector3} v2_2) const;
  public function extern "getW" btScalar getW() const;
  public function extern "getX" btScalar const& getX() const;
  public function extern "getY" btScalar const& getY() const;
  public function extern "getZ" btScalar const& getZ() const;
  public function extern "isZero" bool isZero() const;
  public function extern "length" btScalar length() const;
  public function extern "length2" btScalar length2() const;
  public function extern "lerp" btVector3 lerp(btVector3 const& v_0, btScalar const& t_1) const;
  public function extern "maxAxis" int maxAxis() const;
  public function extern "maxAxis4" int maxAxis4() const;
  public function extern "maxDot" long maxDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "minAxis" int minAxis() const;
  public function extern "minAxis4" int minAxis4() const;
  public function extern "minDot" long minDot(crptr{btVector3} array_0, long array_count_1, btScalar mutable& dotOut_2) const;
  public function extern "norm" btScalar norm() const;
  public function extern "normalize" btVector3 mutable& normalize();
  public function extern "normalized" btVector3 normalized() const;
  public function extern "rotate" btVector3 rotate(btVector3 const& wAxis_0, btScalar const angle_1) const;
  public function extern "safeNormalize" btVector3 mutable& safeNormalize();
  public function extern "serialize" void serialize(btVector3FloatData mutable& dataOut_0) const;
  public function extern "serializeDouble" void serializeDouble(btVector3DoubleData mutable& dataOut_0) const;
  public function extern "serializeFloat" void serializeFloat(btVector3FloatData mutable& dataOut_0) const;
  public function extern "setInterpolate3" void setInterpolate3(btVector3 const& v0_0, btVector3 const& v1_1, btScalar rt_2);
  public function extern "setMax" void setMax(btVector3 const& other_0);
  public function extern "setMin" void setMin(btVector3 const& other_0);
  public function extern "setValue" void setValue3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
  public function extern "setValue" void setValue4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
  public function extern "setW" void setW(btScalar _w_0);
  public function extern "setX" void setX(btScalar _x_0);
  public function extern "setY" void setY(btScalar _y_0);
  public function extern "setZ" void setZ(btScalar _z_0);
  public function extern "setZero" void setZero();
  public function extern "triple" btScalar triple(btVector3 const& v1_0, btVector3 const& v2_1) const;
  public function extern "w" btScalar const& w() const;
  public function extern "x" btScalar const& x() const;
  public function extern "y" btScalar const& y() const;
  public function extern "z" btScalar const& z() const;
  public rawarray{btScalar, 4} m_floats;
}
public pure struct extern "::btVectorX<double>" "nodefault" btVectorX_double private {
}
public pure struct extern "::btVectorX<float>" "nodefault" btVectorX_float private {
}
public pure struct extern "::btVehicleRaycaster" "nonmovable" btVehicleRaycaster {
  public function extern "castRay" rptr{void} castRay(btVector3 const& from_0, btVector3 const& to_1, btVehicleRaycaster_btVehicleRaycasterResult mutable& result_2);
}
public pure struct extern "::btVehicleRaycaster::btVehicleRaycasterResult" btVehicleRaycaster_btVehicleRaycasterResult {
  public btVector3 m_hitPointInWorld;
  public btVector3 m_hitNormalInWorld;
  public btScalar m_distFraction;
}
public pure struct extern "::btVehicleTuning" "nodefault" btVehicleTuning private {
}
public pure struct extern "::btRaycastVehicle::btVehicleTuning" btRaycastVehicle_btVehicleTuning {
  public btScalar m_suspensionStiffness;
  public btScalar m_suspensionCompression;
  public btScalar m_suspensionDamping;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_frictionSlip;
  public btScalar m_maxSuspensionForce;
}
public pure struct extern "::btVoronoiSimplexSolver" btVoronoiSimplexSolver {
  public function extern "addVertex" void addVertex(btVector3 const& w_0, btVector3 const& p_1, btVector3 const& q_2);
  public function extern "backup_closest" void backup_closest(btVector3 mutable& v_0);
  public function extern "closest" bool closest(btVector3 mutable& v_0);
  public function extern "closestPtPointTetrahedron" bool closestPtPointTetrahedron(btVector3 const& p_0, btVector3 const& a_1, btVector3 const& b_2, btVector3 const& c_3, btVector3 const& d_4, btSubSimplexClosestResult mutable& finalResult_5);
  public function extern "closestPtPointTriangle" bool closestPtPointTriangle(btVector3 const& p_0, btVector3 const& a_1, btVector3 const& b_2, btVector3 const& c_3, btSubSimplexClosestResult mutable& result_4);
  public function extern "compute_points" void compute_points(btVector3 mutable& p1_0, btVector3 mutable& p2_1);
  public function extern "emptySimplex" bool emptySimplex() const;
  public function extern "fullSimplex" bool fullSimplex() const;
  public function extern "getEqualVertexThreshold" btScalar getEqualVertexThreshold() const;
  public function extern "getSimplex" int getSimplex(rptr{btVector3} pBuf_0, rptr{btVector3} qBuf_1, rptr{btVector3} yBuf_2) const;
  public function extern "inSimplex" bool inSimplex(btVector3 const& w_0);
  public function extern "maxVertex" btScalar maxVertex();
  public function extern "numVertices" int numVertices() const;
  public function extern "pointOutsideOfPlane" int pointOutsideOfPlane(btVector3 const& p_0, btVector3 const& a_1, btVector3 const& b_2, btVector3 const& c_3, btVector3 const& d_4);
  public function extern "reduceVertices" void reduceVertices(btUsageBitfield const& usedVerts_0);
  public function extern "removeVertex" void removeVertex(int index_0);
  public function extern "reset" void reset();
  public function extern "setEqualVertexThreshold" void setEqualVertexThreshold(btScalar threshold_0);
  public function extern "updateClosestVectorAndPoints" bool updateClosestVectorAndPoints();
  public int m_numVertices;
  public rawarray{btVector3, 5} m_simplexVectorW;
  public rawarray{btVector3, 5} m_simplexPointsP;
  public rawarray{btVector3, 5} m_simplexPointsQ;
  public btVector3 m_cachedP1;
  public btVector3 m_cachedP2;
  public btVector3 m_cachedV;
  public btVector3 m_lastW;
  public btScalar m_equalVertexThreshold;
  public bool m_cachedValidClosest;
  public btSubSimplexClosestResult m_cachedBC;
  public bool m_needsUpdate;
}
public pure struct extern "::btWheelInfo" "nodefault" btWheelInfo(btWheelInfoConstructionInfo mutable& ci_0)  {
  public function extern "getSuspensionRestLength" btScalar getSuspensionRestLength() const;
  public function extern "updateWheel" void updateWheel(btRigidBody const& chassis_0, btWheelInfo_RaycastInfo mutable& raycastInfo_1);
  public btWheelInfo_RaycastInfo m_raycastInfo;
  public btTransform m_worldTransform;
  public btVector3 m_chassisConnectionPointCS;
  public btVector3 m_wheelDirectionCS;
  public btVector3 m_wheelAxleCS;
  public btScalar m_suspensionRestLength1;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_wheelsRadius;
  public btScalar m_suspensionStiffness;
  public btScalar m_wheelsDampingCompression;
  public btScalar m_wheelsDampingRelaxation;
  public btScalar m_frictionSlip;
  public btScalar m_steering;
  public btScalar m_rotation;
  public btScalar m_deltaRotation;
  public btScalar m_rollInfluence;
  public btScalar m_maxSuspensionForce;
  public btScalar m_engineForce;
  public btScalar m_brake;
  public bool m_bIsFrontWheel;
  public rptr{void} m_clientInfo;
  public btScalar m_clippedInvContactDotSuspension;
  public btScalar m_suspensionRelativeVelocity;
  public btScalar m_wheelsSuspensionForce;
  public btScalar m_skidInfo;
}
public pure struct extern "::btWheelInfoConstructionInfo" btWheelInfoConstructionInfo {
  public btVector3 m_chassisConnectionCS;
  public btVector3 m_wheelDirectionCS;
  public btVector3 m_wheelAxleCS;
  public btScalar m_suspensionRestLength;
  public btScalar m_maxSuspensionTravelCm;
  public btScalar m_wheelRadius;
  public btScalar m_suspensionStiffness;
  public btScalar m_wheelsDampingCompression;
  public btScalar m_wheelsDampingRelaxation;
  public btScalar m_frictionSlip;
  public btScalar m_maxSuspensionForce;
  public bool m_bIsFrontWheel;
}
public metafunction btAlignedAllocator_btBroadphasePair_16_const_pointer crptr{btBroadphasePair};
public metafunction btAlignedAllocator_int_16_const_pointer crptr{int};
public metafunction btAlignedAllocator_btDbvt_sStkNN_16_const_pointer crptr{btDbvt_sStkNN};
public metafunction btAlignedAllocator_const_btDbvtNode_p_16_const_pointer crptr{crptr{btDbvtNode}};
public metafunction btAlignedAllocator_btDbvt_sStkNPS_16_const_pointer crptr{btDbvt_sStkNPS};
public metafunction btAlignedAllocator_btDbvt_sStkNP_16_const_pointer crptr{btDbvt_sStkNP};
public metafunction btAlignedAllocator_btBroadphaseInterface_p_16_const_pointer crptr{rptr{btBroadphaseInterface}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_pointer crptr{rptr{btMultiSapBroadphase_btBridgeProxy}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_pointer crptr{rptr{btMultiSapBroadphase_btMultiSapProxy}};
public metafunction btAlignedAllocator_btOptimizedBvhNode_16_const_pointer crptr{btOptimizedBvhNode};
public metafunction btAlignedAllocator_btQuantizedBvhNode_16_const_pointer crptr{btQuantizedBvhNode};
public metafunction btAlignedAllocator_btBvhSubtreeInfo_16_const_pointer crptr{btBvhSubtreeInfo};
public metafunction btAlignedAllocator_btPersistentManifold_p_16_const_pointer crptr{rptr{btPersistentManifold}};
public metafunction btAlignedAllocator_const_btCollisionObject_p_16_const_pointer crptr{crptr{btCollisionObject}};
public metafunction btAlignedAllocator_btCollisionObject_p_16_const_pointer crptr{rptr{btCollisionObject}};
public metafunction btAlignedAllocator_btVector3_16_const_pointer crptr{btVector3};
public metafunction btAlignedAllocator_float_16_const_pointer crptr{float};
public metafunction btAlignedAllocator_btCollisionShape_p_16_const_pointer crptr{rptr{btCollisionShape}};
public metafunction btAlignedAllocator_btOptimizedBvh_p_16_const_pointer crptr{rptr{btOptimizedBvh}};
public metafunction btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_pointer crptr{rptr{btTriangleIndexVertexArray}};
public metafunction btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_pointer crptr{rptr{btStridingMeshInterfaceData}};
public metafunction btAlignedAllocator_char_p_16_const_pointer crptr{rptr{char}};
public metafunction btAlignedAllocator_int_p_16_const_pointer crptr{rptr{int}};
public metafunction btAlignedAllocator_short_p_16_const_pointer crptr{rptr{short}};
public metafunction btAlignedAllocator_unsigned_char_p_16_const_pointer crptr{rptr{uchar}};
public metafunction btAlignedAllocator_btVector3FloatData_p_16_const_pointer crptr{rptr{btVector3FloatData}};
public metafunction btAlignedAllocator_btVector3DoubleData_p_16_const_pointer crptr{rptr{btVector3DoubleData}};
public metafunction btAlignedAllocator_btHashPtr_16_const_pointer crptr{btHashPtr};
public metafunction btAlignedAllocator_btHashString_16_const_pointer crptr{btHashString};
public metafunction btAlignedAllocator_const_char_p_16_const_pointer crptr{crptr{char}};
public metafunction btAlignedAllocator_btCollisionAlgorithm_p_16_const_pointer crptr{rptr{btCollisionAlgorithm}};
public metafunction btAlignedAllocator_btSimplePair_16_const_pointer crptr{btSimplePair};
public metafunction btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_pointer crptr{rptr{btQuantizedBvhDoubleData}};
public metafunction btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_pointer crptr{rptr{btQuantizedBvhFloatData}};
public metafunction btAlignedAllocator_btCollisionShapeData_p_16_const_pointer crptr{rptr{btCollisionShapeData}};
public metafunction btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_pointer crptr{rptr{btDynamicsWorldDoubleData}};
public metafunction btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_pointer crptr{rptr{btDynamicsWorldFloatData}};
public metafunction btAlignedAllocator_btRigidBodyDoubleData_p_16_const_pointer crptr{rptr{btRigidBodyDoubleData}};
public metafunction btAlignedAllocator_btRigidBodyFloatData_p_16_const_pointer crptr{rptr{btRigidBodyFloatData}};
public metafunction btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_pointer crptr{rptr{btCollisionObjectDoubleData}};
public metafunction btAlignedAllocator_btCollisionObjectFloatData_p_16_const_pointer crptr{rptr{btCollisionObjectFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintFloatData_p_16_const_pointer crptr{rptr{btTypedConstraintFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_pointer crptr{rptr{btTypedConstraintDoubleData}};
public metafunction btAlignedAllocator_btTypedConstraintData_p_16_const_pointer crptr{rptr{btTypedConstraintData}};
public metafunction btAlignedAllocator_short_16_const_pointer crptr{short};
public metafunction btAlignedAllocator_btHashInt_16_const_pointer crptr{btHashInt};
public metafunction btAlignedAllocator_void_p_16_const_pointer crptr{rptr{void}};
public metafunction btAlignedAllocator_btPointerUid_16_const_pointer crptr{btPointerUid};
public metafunction btAlignedAllocator_btChunk_p_16_const_pointer crptr{rptr{btChunk}};
public metafunction btAlignedAllocator_btTriangleInfo_16_const_pointer crptr{btTriangleInfo};
public metafunction btAlignedAllocator_btElement_16_const_pointer crptr{btElement};
public metafunction btAlignedAllocator_btCompoundShapeChild_16_const_pointer crptr{btCompoundShapeChild};
public metafunction btAlignedAllocator_btFace_16_const_pointer crptr{btFace};
public metafunction btAlignedAllocator_btMaterial_p_16_const_pointer crptr{rptr{btMaterial}};
public metafunction btAlignedAllocator_unsigned_int_16_const_pointer crptr{uint};
public metafunction btAlignedAllocator_btTriangle_16_const_pointer crptr{btTriangle};
public metafunction btAlignedAllocator_btIndexedMesh_16_const_pointer crptr{btIndexedMesh};
public metafunction btAlignedAllocator_btMaterialProperties_16_const_pointer crptr{btMaterialProperties};
public metafunction btAlignedAllocator_unsigned_short_16_const_pointer crptr{ushort};
public metafunction btAlignedAllocator_btTypedConstraint_p_16_const_pointer crptr{rptr{btTypedConstraint}};
public metafunction btAlignedAllocator_btSolverBody_16_const_pointer crptr{btSolverBody};
public metafunction btAlignedAllocator_btSolverConstraint_16_const_pointer crptr{btSolverConstraint};
public metafunction btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_pointer crptr{btTypedConstraint_btConstraintInfo1};
public metafunction btAlignedAllocator_btRigidBody_p_16_const_pointer crptr{rptr{btRigidBody}};
public metafunction btAlignedAllocator_btActionInterface_p_16_const_pointer crptr{rptr{btActionInterface}};
public metafunction btAlignedAllocator_btConvexHullComputer_Edge_16_const_pointer crptr{btConvexHullComputer_Edge};
public metafunction btAlignedAllocator_double_16_const_pointer crptr{double};
public metafunction btAlignedAllocator_btWheelInfo_16_const_pointer crptr{btWheelInfo};
public metafunction btAlignedAllocator_btBroadphasePair_16_const_reference crawref{btBroadphasePair};
public metafunction btAlignedAllocator_int_16_const_reference crawref{int};
public metafunction btAlignedAllocator_btDbvt_sStkNN_16_const_reference crawref{btDbvt_sStkNN};
public metafunction btAlignedAllocator_const_btDbvtNode_p_16_const_reference crawref{crptr{btDbvtNode}};
public metafunction btAlignedAllocator_btDbvt_sStkNPS_16_const_reference crawref{btDbvt_sStkNPS};
public metafunction btAlignedAllocator_btDbvt_sStkNP_16_const_reference crawref{btDbvt_sStkNP};
public metafunction btAlignedAllocator_btBroadphaseInterface_p_16_const_reference crawref{rptr{btBroadphaseInterface}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference crawref{rptr{btMultiSapBroadphase_btBridgeProxy}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference crawref{rptr{btMultiSapBroadphase_btMultiSapProxy}};
public metafunction btAlignedAllocator_btOptimizedBvhNode_16_const_reference crawref{btOptimizedBvhNode};
public metafunction btAlignedAllocator_btQuantizedBvhNode_16_const_reference crawref{btQuantizedBvhNode};
public metafunction btAlignedAllocator_btBvhSubtreeInfo_16_const_reference crawref{btBvhSubtreeInfo};
public metafunction btAlignedAllocator_btPersistentManifold_p_16_const_reference crawref{rptr{btPersistentManifold}};
public metafunction btAlignedAllocator_const_btCollisionObject_p_16_const_reference crawref{crptr{btCollisionObject}};
public metafunction btAlignedAllocator_btCollisionObject_p_16_const_reference crawref{rptr{btCollisionObject}};
public metafunction btAlignedAllocator_btVector3_16_const_reference crawref{btVector3};
public metafunction btAlignedAllocator_float_16_const_reference crawref{float};
public metafunction btAlignedAllocator_btCollisionShape_p_16_const_reference crawref{rptr{btCollisionShape}};
public metafunction btAlignedAllocator_btOptimizedBvh_p_16_const_reference crawref{rptr{btOptimizedBvh}};
public metafunction btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference crawref{rptr{btTriangleIndexVertexArray}};
public metafunction btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference crawref{rptr{btStridingMeshInterfaceData}};
public metafunction btAlignedAllocator_char_p_16_const_reference crawref{rptr{char}};
public metafunction btAlignedAllocator_int_p_16_const_reference crawref{rptr{int}};
public metafunction btAlignedAllocator_short_p_16_const_reference crawref{rptr{short}};
public metafunction btAlignedAllocator_unsigned_char_p_16_const_reference crawref{rptr{uchar}};
public metafunction btAlignedAllocator_btVector3FloatData_p_16_const_reference crawref{rptr{btVector3FloatData}};
public metafunction btAlignedAllocator_btVector3DoubleData_p_16_const_reference crawref{rptr{btVector3DoubleData}};
public metafunction btAlignedAllocator_btHashPtr_16_const_reference crawref{btHashPtr};
public metafunction btAlignedAllocator_btHashString_16_const_reference crawref{btHashString};
public metafunction btAlignedAllocator_const_char_p_16_const_reference crawref{crptr{char}};
public metafunction btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference crawref{rptr{btCollisionAlgorithm}};
public metafunction btAlignedAllocator_btSimplePair_16_const_reference crawref{btSimplePair};
public metafunction btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference crawref{rptr{btQuantizedBvhDoubleData}};
public metafunction btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference crawref{rptr{btQuantizedBvhFloatData}};
public metafunction btAlignedAllocator_btCollisionShapeData_p_16_const_reference crawref{rptr{btCollisionShapeData}};
public metafunction btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference crawref{rptr{btDynamicsWorldDoubleData}};
public metafunction btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference crawref{rptr{btDynamicsWorldFloatData}};
public metafunction btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference crawref{rptr{btRigidBodyDoubleData}};
public metafunction btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference crawref{rptr{btRigidBodyFloatData}};
public metafunction btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference crawref{rptr{btCollisionObjectDoubleData}};
public metafunction btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference crawref{rptr{btCollisionObjectFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference crawref{rptr{btTypedConstraintFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference crawref{rptr{btTypedConstraintDoubleData}};
public metafunction btAlignedAllocator_btTypedConstraintData_p_16_const_reference crawref{rptr{btTypedConstraintData}};
public metafunction btAlignedAllocator_short_16_const_reference crawref{short};
public metafunction btAlignedAllocator_btHashInt_16_const_reference crawref{btHashInt};
public metafunction btAlignedAllocator_void_p_16_const_reference crawref{rptr{void}};
public metafunction btAlignedAllocator_btPointerUid_16_const_reference crawref{btPointerUid};
public metafunction btAlignedAllocator_btChunk_p_16_const_reference crawref{rptr{btChunk}};
public metafunction btAlignedAllocator_btTriangleInfo_16_const_reference crawref{btTriangleInfo};
public metafunction btAlignedAllocator_btElement_16_const_reference crawref{btElement};
public metafunction btAlignedAllocator_btCompoundShapeChild_16_const_reference crawref{btCompoundShapeChild};
public metafunction btAlignedAllocator_btFace_16_const_reference crawref{btFace};
public metafunction btAlignedAllocator_btMaterial_p_16_const_reference crawref{rptr{btMaterial}};
public metafunction btAlignedAllocator_unsigned_int_16_const_reference crawref{uint};
public metafunction btAlignedAllocator_btTriangle_16_const_reference crawref{btTriangle};
public metafunction btAlignedAllocator_btIndexedMesh_16_const_reference crawref{btIndexedMesh};
public metafunction btAlignedAllocator_btMaterialProperties_16_const_reference crawref{btMaterialProperties};
public metafunction btAlignedAllocator_unsigned_short_16_const_reference crawref{ushort};
public metafunction btAlignedAllocator_btTypedConstraint_p_16_const_reference crawref{rptr{btTypedConstraint}};
public metafunction btAlignedAllocator_btSolverBody_16_const_reference crawref{btSolverBody};
public metafunction btAlignedAllocator_btSolverConstraint_16_const_reference crawref{btSolverConstraint};
public metafunction btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference crawref{btTypedConstraint_btConstraintInfo1};
public metafunction btAlignedAllocator_btRigidBody_p_16_const_reference crawref{rptr{btRigidBody}};
public metafunction btAlignedAllocator_btActionInterface_p_16_const_reference crawref{rptr{btActionInterface}};
public metafunction btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference crawref{btConvexHullComputer_Edge};
public metafunction btAlignedAllocator_double_16_const_reference crawref{double};
public metafunction btAlignedAllocator_btWheelInfo_16_const_reference crawref{btWheelInfo};
public pure tsvaluetype struct extern "::btSpatialTransformationMatrix::eOutputOperation" "extenum" btSpatialTransformationMatrix_eOutputOperation { }
public extern "None" btSpatialTransformationMatrix_eOutputOperation btSpatialTransformationMatrix_eOutputOperation_None;
public extern "Add" btSpatialTransformationMatrix_eOutputOperation btSpatialTransformationMatrix_eOutputOperation_Add;
public extern "Subtract" btSpatialTransformationMatrix_eOutputOperation btSpatialTransformationMatrix_eOutputOperation_Subtract;
public pure tsvaluetype struct extern "::btGjkEpaSolver3::sResults::eStatus" "extenum" btGjkEpaSolver3_sResults_eStatus { }
public extern "Separated" btGjkEpaSolver3_sResults_eStatus btGjkEpaSolver3_sResults_eStatus_Separated;
public extern "Penetrating" btGjkEpaSolver3_sResults_eStatus btGjkEpaSolver3_sResults_eStatus_Penetrating;
public extern "GJK_Failed" btGjkEpaSolver3_sResults_eStatus btGjkEpaSolver3_sResults_eStatus_GJK_Failed;
public extern "EPA_Failed" btGjkEpaSolver3_sResults_eStatus btGjkEpaSolver3_sResults_eStatus_EPA_Failed;
public pure tsvaluetype struct extern "::btGjkEpaSolver2::sResults::eStatus" "extenum" btGjkEpaSolver2_sResults_eStatus { }
public extern "Separated" btGjkEpaSolver2_sResults_eStatus btGjkEpaSolver2_sResults_eStatus_Separated;
public extern "Penetrating" btGjkEpaSolver2_sResults_eStatus btGjkEpaSolver2_sResults_eStatus_Penetrating;
public extern "GJK_Failed" btGjkEpaSolver2_sResults_eStatus btGjkEpaSolver2_sResults_eStatus_GJK_Failed;
public extern "EPA_Failed" btGjkEpaSolver2_sResults_eStatus btGjkEpaSolver2_sResults_eStatus_EPA_Failed;
public pure struct extern "::btAlignedObjectArray<btBroadphasePair>::less" "nodefault" btAlignedObjectArray_btBroadphasePair_less private {
}
public pure struct extern "::btAlignedObjectArray<int>::less" "nodefault" btAlignedObjectArray_int_less private {
}
public pure struct extern "::btAlignedObjectArray<btDbvt::sStkNN>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNN_less private {
}
public pure struct extern "::btAlignedObjectArray<const btDbvtNode *>::less" "nodefault" btAlignedObjectArray_const_btDbvtNode_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btDbvt::sStkNPS>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNPS_less private {
}
public pure struct extern "::btAlignedObjectArray<btDbvt::sStkNP>::less" "nodefault" btAlignedObjectArray_btDbvt_sStkNP_less private {
}
public pure struct extern "::btAlignedObjectArray<btPersistentManifold *>::less" "nodefault" btAlignedObjectArray_btPersistentManifold_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btBroadphaseInterface *>::less" "nodefault" btAlignedObjectArray_btBroadphaseInterface_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btBridgeProxy *>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btMultiSapBroadphase::btMultiSapProxy *>::less" "nodefault" btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btOptimizedBvhNode>::less" "nodefault" btAlignedObjectArray_btOptimizedBvhNode_less private {
}
public pure struct extern "::btAlignedObjectArray<btQuantizedBvhNode>::less" "nodefault" btAlignedObjectArray_btQuantizedBvhNode_less private {
}
public pure struct extern "::btAlignedObjectArray<btBvhSubtreeInfo>::less" "nodefault" btAlignedObjectArray_btBvhSubtreeInfo_less private {
}
public pure struct extern "::btAlignedObjectArray<btCollisionObject *>::less" "nodefault" btAlignedObjectArray_btCollisionObject_p_less private {
}
public pure struct extern "::btAlignedObjectArray<const btCollisionObject *>::less" "nodefault" btAlignedObjectArray_const_btCollisionObject_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btVector3>::less" "nodefault" btAlignedObjectArray_btVector3_less private {
}
public pure struct extern "::btAlignedObjectArray<float>::less" "nodefault" btAlignedObjectArray_float_less private {
}
public pure struct extern "::btAlignedObjectArray<btCollisionShape *>::less" "nodefault" btAlignedObjectArray_btCollisionShape_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btOptimizedBvh *>::less" "nodefault" btAlignedObjectArray_btOptimizedBvh_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btTriangleInfoMap *>::less" "nodefault" btAlignedObjectArray_btTriangleInfoMap_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btTriangleIndexVertexArray *>::less" "nodefault" btAlignedObjectArray_btTriangleIndexVertexArray_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btStridingMeshInterfaceData *>::less" "nodefault" btAlignedObjectArray_btStridingMeshInterfaceData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<char *>::less" "nodefault" btAlignedObjectArray_char_p_less private {
}
public pure struct extern "::btAlignedObjectArray<int *>::less" "nodefault" btAlignedObjectArray_int_p_less private {
}
public pure struct extern "::btAlignedObjectArray<short *>::less" "nodefault" btAlignedObjectArray_short_p_less private {
}
public pure struct extern "::btAlignedObjectArray<unsigned char *>::less" "nodefault" btAlignedObjectArray_unsigned_char_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btVector3FloatData *>::less" "nodefault" btAlignedObjectArray_btVector3FloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btVector3DoubleData *>::less" "nodefault" btAlignedObjectArray_btVector3DoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btHashPtr>::less" "nodefault" btAlignedObjectArray_btHashPtr_less private {
}
public pure struct extern "::btAlignedObjectArray<btHashString>::less" "nodefault" btAlignedObjectArray_btHashString_less private {
}
public pure struct extern "::btAlignedObjectArray<const char *>::less" "nodefault" btAlignedObjectArray_const_char_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btCollisionAlgorithm *>::less" "nodefault" btAlignedObjectArray_btCollisionAlgorithm_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btSimplePair>::less" "nodefault" btAlignedObjectArray_btSimplePair_less private {
}
public pure struct extern "::btAlignedObjectArray<btQuantizedBvhDoubleData *>::less" "nodefault" btAlignedObjectArray_btQuantizedBvhDoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btQuantizedBvhFloatData *>::less" "nodefault" btAlignedObjectArray_btQuantizedBvhFloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btCollisionShapeData *>::less" "nodefault" btAlignedObjectArray_btCollisionShapeData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btDynamicsWorldDoubleData *>::less" "nodefault" btAlignedObjectArray_btDynamicsWorldDoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btDynamicsWorldFloatData *>::less" "nodefault" btAlignedObjectArray_btDynamicsWorldFloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btRigidBodyDoubleData *>::less" "nodefault" btAlignedObjectArray_btRigidBodyDoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btRigidBodyFloatData *>::less" "nodefault" btAlignedObjectArray_btRigidBodyFloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btCollisionObjectDoubleData *>::less" "nodefault" btAlignedObjectArray_btCollisionObjectDoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btCollisionObjectFloatData *>::less" "nodefault" btAlignedObjectArray_btCollisionObjectFloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraintFloatData *>::less" "nodefault" btAlignedObjectArray_btTypedConstraintFloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraintDoubleData *>::less" "nodefault" btAlignedObjectArray_btTypedConstraintDoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraintData *>::less" "nodefault" btAlignedObjectArray_btTypedConstraintData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btSoftBodyFloatData *>::less" "nodefault" btAlignedObjectArray_btSoftBodyFloatData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btSoftBodyDoubleData *>::less" "nodefault" btAlignedObjectArray_btSoftBodyDoubleData_p_less private {
}
public pure struct extern "::btAlignedObjectArray<short>::less" "nodefault" btAlignedObjectArray_short_less private {
}
public pure struct extern "::btAlignedObjectArray<btHashInt>::less" "nodefault" btAlignedObjectArray_btHashInt_less private {
}
public pure struct extern "::btAlignedObjectArray<void *>::less" "nodefault" btAlignedObjectArray_void_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btPointerUid>::less" "nodefault" btAlignedObjectArray_btPointerUid_less private {
}
public pure struct extern "::btAlignedObjectArray<btChunk *>::less" "nodefault" btAlignedObjectArray_btChunk_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btTriangleInfo>::less" "nodefault" btAlignedObjectArray_btTriangleInfo_less private {
}
public pure struct extern "::btAlignedObjectArray<btElement>::less" "nodefault" btAlignedObjectArray_btElement_less private {
}
public pure struct extern "::btAlignedObjectArray<btCompoundShapeChild>::less" "nodefault" btAlignedObjectArray_btCompoundShapeChild_less private {
}
public pure struct extern "::btAlignedObjectArray<btFace>::less" "nodefault" btAlignedObjectArray_btFace_less private {
}
public pure struct extern "::btAlignedObjectArray<btMaterial *>::less" "nodefault" btAlignedObjectArray_btMaterial_p_less private {
}
public pure struct extern "::btAlignedObjectArray<unsigned int>::less" "nodefault" btAlignedObjectArray_unsigned_int_less private {
}
public pure struct extern "::btAlignedObjectArray<btTriangle>::less" "nodefault" btAlignedObjectArray_btTriangle_less private {
}
public pure struct extern "::btAlignedObjectArray<btIndexedMesh>::less" "nodefault" btAlignedObjectArray_btIndexedMesh_less private {
}
public pure struct extern "::btAlignedObjectArray<btMaterialProperties>::less" "nodefault" btAlignedObjectArray_btMaterialProperties_less private {
}
public pure struct extern "::btAlignedObjectArray<unsigned short>::less" "nodefault" btAlignedObjectArray_unsigned_short_less private {
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraint *>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btSolverConstraint>::less" "nodefault" btAlignedObjectArray_btSolverConstraint_less private {
}
public pure struct extern "::btAlignedObjectArray<btSolverBody>::less" "nodefault" btAlignedObjectArray_btSolverBody_less private {
}
public pure struct extern "::btAlignedObjectArray<btTypedConstraint::btConstraintInfo1>::less" "nodefault" btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_less private {
}
public pure struct extern "::btAlignedObjectArray<btRigidBody *>::less" "nodefault" btAlignedObjectArray_btRigidBody_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btActionInterface *>::less" "nodefault" btAlignedObjectArray_btActionInterface_p_less private {
}
public pure struct extern "::btAlignedObjectArray<btConvexHullComputer::Edge>::less" "nodefault" btAlignedObjectArray_btConvexHullComputer_Edge_less private {
}
public pure struct extern "::btAlignedObjectArray<GrahamVector3>::less" "nodefault" btAlignedObjectArray_GrahamVector3_less private {
}
public pure struct extern "::btAlignedObjectArray<btAlignedObjectArray<int>>::less" "nodefault" btAlignedObjectArray_btAlignedObjectArray_int_less private {
}
public pure struct extern "::btAlignedObjectArray<double>::less" "nodefault" btAlignedObjectArray_double_less private {
}
public pure struct extern "::btAlignedObjectArray<btWheelInfo>::less" "nodefault" btAlignedObjectArray_btWheelInfo_less private {
}
public pure struct extern "::btCollisionDispatcher::perThreadData" "nodefault" btCollisionDispatcher_perThreadData private {
}
public metafunction btAlignedAllocator_btBroadphasePair_16_pointer rptr{btBroadphasePair};
public metafunction btAlignedAllocator_int_16_pointer rptr{int};
public metafunction btAlignedAllocator_btDbvt_sStkNN_16_pointer rptr{btDbvt_sStkNN};
public metafunction btAlignedAllocator_const_btDbvtNode_p_16_pointer rptr{crptr{btDbvtNode}};
public metafunction btAlignedAllocator_btDbvt_sStkNPS_16_pointer rptr{btDbvt_sStkNPS};
public metafunction btAlignedAllocator_btDbvt_sStkNP_16_pointer rptr{btDbvt_sStkNP};
public metafunction btAlignedAllocator_btBroadphaseInterface_p_16_pointer rptr{rptr{btBroadphaseInterface}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_pointer rptr{rptr{btMultiSapBroadphase_btBridgeProxy}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_pointer rptr{rptr{btMultiSapBroadphase_btMultiSapProxy}};
public metafunction btAlignedAllocator_btOptimizedBvhNode_16_pointer rptr{btOptimizedBvhNode};
public metafunction btAlignedAllocator_btQuantizedBvhNode_16_pointer rptr{btQuantizedBvhNode};
public metafunction btAlignedAllocator_btBvhSubtreeInfo_16_pointer rptr{btBvhSubtreeInfo};
public metafunction btAlignedAllocator_btPersistentManifold_p_16_pointer rptr{rptr{btPersistentManifold}};
public metafunction btAlignedAllocator_const_btCollisionObject_p_16_pointer rptr{crptr{btCollisionObject}};
public metafunction btAlignedAllocator_btCollisionObject_p_16_pointer rptr{rptr{btCollisionObject}};
public metafunction btAlignedAllocator_btVector3_16_pointer rptr{btVector3};
public metafunction btAlignedAllocator_float_16_pointer rptr{float};
public metafunction btAlignedAllocator_btCollisionShape_p_16_pointer rptr{rptr{btCollisionShape}};
public metafunction btAlignedAllocator_btOptimizedBvh_p_16_pointer rptr{rptr{btOptimizedBvh}};
public metafunction btAlignedAllocator_btTriangleIndexVertexArray_p_16_pointer rptr{rptr{btTriangleIndexVertexArray}};
public metafunction btAlignedAllocator_btStridingMeshInterfaceData_p_16_pointer rptr{rptr{btStridingMeshInterfaceData}};
public metafunction btAlignedAllocator_char_p_16_pointer rptr{rptr{char}};
public metafunction btAlignedAllocator_int_p_16_pointer rptr{rptr{int}};
public metafunction btAlignedAllocator_short_p_16_pointer rptr{rptr{short}};
public metafunction btAlignedAllocator_unsigned_char_p_16_pointer rptr{rptr{uchar}};
public metafunction btAlignedAllocator_btVector3FloatData_p_16_pointer rptr{rptr{btVector3FloatData}};
public metafunction btAlignedAllocator_btVector3DoubleData_p_16_pointer rptr{rptr{btVector3DoubleData}};
public metafunction btAlignedAllocator_btHashPtr_16_pointer rptr{btHashPtr};
public metafunction btAlignedAllocator_btHashString_16_pointer rptr{btHashString};
public metafunction btAlignedAllocator_const_char_p_16_pointer rptr{crptr{char}};
public metafunction btAlignedAllocator_btCollisionAlgorithm_p_16_pointer rptr{rptr{btCollisionAlgorithm}};
public metafunction btAlignedAllocator_btSimplePair_16_pointer rptr{btSimplePair};
public metafunction btAlignedAllocator_btQuantizedBvhDoubleData_p_16_pointer rptr{rptr{btQuantizedBvhDoubleData}};
public metafunction btAlignedAllocator_btQuantizedBvhFloatData_p_16_pointer rptr{rptr{btQuantizedBvhFloatData}};
public metafunction btAlignedAllocator_btCollisionShapeData_p_16_pointer rptr{rptr{btCollisionShapeData}};
public metafunction btAlignedAllocator_btDynamicsWorldDoubleData_p_16_pointer rptr{rptr{btDynamicsWorldDoubleData}};
public metafunction btAlignedAllocator_btDynamicsWorldFloatData_p_16_pointer rptr{rptr{btDynamicsWorldFloatData}};
public metafunction btAlignedAllocator_btRigidBodyDoubleData_p_16_pointer rptr{rptr{btRigidBodyDoubleData}};
public metafunction btAlignedAllocator_btRigidBodyFloatData_p_16_pointer rptr{rptr{btRigidBodyFloatData}};
public metafunction btAlignedAllocator_btCollisionObjectDoubleData_p_16_pointer rptr{rptr{btCollisionObjectDoubleData}};
public metafunction btAlignedAllocator_btCollisionObjectFloatData_p_16_pointer rptr{rptr{btCollisionObjectFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintFloatData_p_16_pointer rptr{rptr{btTypedConstraintFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintDoubleData_p_16_pointer rptr{rptr{btTypedConstraintDoubleData}};
public metafunction btAlignedAllocator_btTypedConstraintData_p_16_pointer rptr{rptr{btTypedConstraintData}};
public metafunction btAlignedAllocator_short_16_pointer rptr{short};
public metafunction btAlignedAllocator_btHashInt_16_pointer rptr{btHashInt};
public metafunction btAlignedAllocator_void_p_16_pointer rptr{rptr{void}};
public metafunction btAlignedAllocator_btPointerUid_16_pointer rptr{btPointerUid};
public metafunction btAlignedAllocator_btChunk_p_16_pointer rptr{rptr{btChunk}};
public metafunction btAlignedAllocator_btTriangleInfo_16_pointer rptr{btTriangleInfo};
public metafunction btAlignedAllocator_btElement_16_pointer rptr{btElement};
public metafunction btAlignedAllocator_btCompoundShapeChild_16_pointer rptr{btCompoundShapeChild};
public metafunction btAlignedAllocator_btFace_16_pointer rptr{btFace};
public metafunction btAlignedAllocator_btMaterial_p_16_pointer rptr{rptr{btMaterial}};
public metafunction btAlignedAllocator_unsigned_int_16_pointer rptr{uint};
public metafunction btAlignedAllocator_btTriangle_16_pointer rptr{btTriangle};
public metafunction btAlignedAllocator_btIndexedMesh_16_pointer rptr{btIndexedMesh};
public metafunction btAlignedAllocator_btMaterialProperties_16_pointer rptr{btMaterialProperties};
public metafunction btAlignedAllocator_unsigned_short_16_pointer rptr{ushort};
public metafunction btAlignedAllocator_btTypedConstraint_p_16_pointer rptr{rptr{btTypedConstraint}};
public metafunction btAlignedAllocator_btSolverBody_16_pointer rptr{btSolverBody};
public metafunction btAlignedAllocator_btSolverConstraint_16_pointer rptr{btSolverConstraint};
public metafunction btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_pointer rptr{btTypedConstraint_btConstraintInfo1};
public metafunction btAlignedAllocator_btRigidBody_p_16_pointer rptr{rptr{btRigidBody}};
public metafunction btAlignedAllocator_btActionInterface_p_16_pointer rptr{rptr{btActionInterface}};
public metafunction btAlignedAllocator_btConvexHullComputer_Edge_16_pointer rptr{btConvexHullComputer_Edge};
public metafunction btAlignedAllocator_double_16_pointer rptr{double};
public metafunction btAlignedAllocator_btWheelInfo_16_pointer rptr{btWheelInfo};
public metafunction btAlignedAllocator_btBroadphasePair_16_reference rawref{btBroadphasePair};
public metafunction btAlignedAllocator_int_16_reference rawref{int};
public metafunction btAlignedAllocator_btDbvt_sStkNN_16_reference rawref{btDbvt_sStkNN};
public metafunction btAlignedAllocator_const_btDbvtNode_p_16_reference rawref{crptr{btDbvtNode}};
public metafunction btAlignedAllocator_btDbvt_sStkNPS_16_reference rawref{btDbvt_sStkNPS};
public metafunction btAlignedAllocator_btDbvt_sStkNP_16_reference rawref{btDbvt_sStkNP};
public metafunction btAlignedAllocator_btBroadphaseInterface_p_16_reference rawref{rptr{btBroadphaseInterface}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference rawref{rptr{btMultiSapBroadphase_btBridgeProxy}};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference rawref{rptr{btMultiSapBroadphase_btMultiSapProxy}};
public metafunction btAlignedAllocator_btOptimizedBvhNode_16_reference rawref{btOptimizedBvhNode};
public metafunction btAlignedAllocator_btQuantizedBvhNode_16_reference rawref{btQuantizedBvhNode};
public metafunction btAlignedAllocator_btBvhSubtreeInfo_16_reference rawref{btBvhSubtreeInfo};
public metafunction btAlignedAllocator_btPersistentManifold_p_16_reference rawref{rptr{btPersistentManifold}};
public metafunction btAlignedAllocator_const_btCollisionObject_p_16_reference rawref{crptr{btCollisionObject}};
public metafunction btAlignedAllocator_btCollisionObject_p_16_reference rawref{rptr{btCollisionObject}};
public metafunction btAlignedAllocator_btVector3_16_reference rawref{btVector3};
public metafunction btAlignedAllocator_float_16_reference rawref{float};
public metafunction btAlignedAllocator_btCollisionShape_p_16_reference rawref{rptr{btCollisionShape}};
public metafunction btAlignedAllocator_btOptimizedBvh_p_16_reference rawref{rptr{btOptimizedBvh}};
public metafunction btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference rawref{rptr{btTriangleIndexVertexArray}};
public metafunction btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference rawref{rptr{btStridingMeshInterfaceData}};
public metafunction btAlignedAllocator_char_p_16_reference rawref{rptr{char}};
public metafunction btAlignedAllocator_int_p_16_reference rawref{rptr{int}};
public metafunction btAlignedAllocator_short_p_16_reference rawref{rptr{short}};
public metafunction btAlignedAllocator_unsigned_char_p_16_reference rawref{rptr{uchar}};
public metafunction btAlignedAllocator_btVector3FloatData_p_16_reference rawref{rptr{btVector3FloatData}};
public metafunction btAlignedAllocator_btVector3DoubleData_p_16_reference rawref{rptr{btVector3DoubleData}};
public metafunction btAlignedAllocator_btHashPtr_16_reference rawref{btHashPtr};
public metafunction btAlignedAllocator_btHashString_16_reference rawref{btHashString};
public metafunction btAlignedAllocator_const_char_p_16_reference rawref{crptr{char}};
public metafunction btAlignedAllocator_btCollisionAlgorithm_p_16_reference rawref{rptr{btCollisionAlgorithm}};
public metafunction btAlignedAllocator_btSimplePair_16_reference rawref{btSimplePair};
public metafunction btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference rawref{rptr{btQuantizedBvhDoubleData}};
public metafunction btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference rawref{rptr{btQuantizedBvhFloatData}};
public metafunction btAlignedAllocator_btCollisionShapeData_p_16_reference rawref{rptr{btCollisionShapeData}};
public metafunction btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference rawref{rptr{btDynamicsWorldDoubleData}};
public metafunction btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference rawref{rptr{btDynamicsWorldFloatData}};
public metafunction btAlignedAllocator_btRigidBodyDoubleData_p_16_reference rawref{rptr{btRigidBodyDoubleData}};
public metafunction btAlignedAllocator_btRigidBodyFloatData_p_16_reference rawref{rptr{btRigidBodyFloatData}};
public metafunction btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference rawref{rptr{btCollisionObjectDoubleData}};
public metafunction btAlignedAllocator_btCollisionObjectFloatData_p_16_reference rawref{rptr{btCollisionObjectFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintFloatData_p_16_reference rawref{rptr{btTypedConstraintFloatData}};
public metafunction btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference rawref{rptr{btTypedConstraintDoubleData}};
public metafunction btAlignedAllocator_btTypedConstraintData_p_16_reference rawref{rptr{btTypedConstraintData}};
public metafunction btAlignedAllocator_short_16_reference rawref{short};
public metafunction btAlignedAllocator_btHashInt_16_reference rawref{btHashInt};
public metafunction btAlignedAllocator_void_p_16_reference rawref{rptr{void}};
public metafunction btAlignedAllocator_btPointerUid_16_reference rawref{btPointerUid};
public metafunction btAlignedAllocator_btChunk_p_16_reference rawref{rptr{btChunk}};
public metafunction btAlignedAllocator_btTriangleInfo_16_reference rawref{btTriangleInfo};
public metafunction btAlignedAllocator_btElement_16_reference rawref{btElement};
public metafunction btAlignedAllocator_btCompoundShapeChild_16_reference rawref{btCompoundShapeChild};
public metafunction btAlignedAllocator_btFace_16_reference rawref{btFace};
public metafunction btAlignedAllocator_btMaterial_p_16_reference rawref{rptr{btMaterial}};
public metafunction btAlignedAllocator_unsigned_int_16_reference rawref{uint};
public metafunction btAlignedAllocator_btTriangle_16_reference rawref{btTriangle};
public metafunction btAlignedAllocator_btIndexedMesh_16_reference rawref{btIndexedMesh};
public metafunction btAlignedAllocator_btMaterialProperties_16_reference rawref{btMaterialProperties};
public metafunction btAlignedAllocator_unsigned_short_16_reference rawref{ushort};
public metafunction btAlignedAllocator_btTypedConstraint_p_16_reference rawref{rptr{btTypedConstraint}};
public metafunction btAlignedAllocator_btSolverBody_16_reference rawref{btSolverBody};
public metafunction btAlignedAllocator_btSolverConstraint_16_reference rawref{btSolverConstraint};
public metafunction btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference rawref{btTypedConstraint_btConstraintInfo1};
public metafunction btAlignedAllocator_btRigidBody_p_16_reference rawref{rptr{btRigidBody}};
public metafunction btAlignedAllocator_btActionInterface_p_16_reference rawref{rptr{btActionInterface}};
public metafunction btAlignedAllocator_btConvexHullComputer_Edge_16_reference rawref{btConvexHullComputer_Edge};
public metafunction btAlignedAllocator_double_16_reference rawref{double};
public metafunction btAlignedAllocator_btWheelInfo_16_reference rawref{btWheelInfo};
public pure struct extern "::btGjkEpaSolver3::sResults" btGjkEpaSolver3_sResults {
  public btGjkEpaSolver3_sResults_eStatus status;
  public rawarray{btVector3, 2} witnesses;
  public btVector3 normal;
  public btScalar distance;
}
public pure struct extern "::btGjkEpaSolver2::sResults" btGjkEpaSolver2_sResults {
  public btGjkEpaSolver2_sResults_eStatus status;
  public rawarray{btVector3, 2} witnesses;
  public btVector3 normal;
  public btScalar distance;
}
public pure struct extern "::btDbvt::sStkCLN" "nodefault" btDbvt_sStkCLN(crptr{btDbvtNode} n_0, rptr{btDbvtNode} p_1)  {
  public crptr{btDbvtNode} node;
  public rptr{btDbvtNode} parent;
}
public pure struct extern "::btDbvt::sStkNN" btDbvt_sStkNN {
  public crptr{btDbvtNode} a;
  public crptr{btDbvtNode} b;
}
public pure struct extern "::btDbvt::sStkNP" "nodefault" btDbvt_sStkNP(crptr{btDbvtNode} n_0, uint m_1)  {
  public crptr{btDbvtNode} node;
  public int mask;
}
public pure struct extern "::btDbvt::sStkNPS" btDbvt_sStkNPS {
  public crptr{btDbvtNode} node;
  public int mask;
  public btScalar value;
}
public metafunction size_type int;
public metafunction btAlignedAllocator_btBroadphasePair_16_value_type btBroadphasePair;
public metafunction btAlignedAllocator_int_16_value_type int;
public metafunction btAlignedAllocator_btDbvt_sStkNN_16_value_type btDbvt_sStkNN;
public metafunction btAlignedAllocator_const_btDbvtNode_p_16_value_type crptr{btDbvtNode};
public metafunction btAlignedAllocator_btDbvt_sStkNPS_16_value_type btDbvt_sStkNPS;
public metafunction btAlignedAllocator_btDbvt_sStkNP_16_value_type btDbvt_sStkNP;
public metafunction btAlignedAllocator_btBroadphaseInterface_p_16_value_type rptr{btBroadphaseInterface};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_value_type rptr{btMultiSapBroadphase_btBridgeProxy};
public metafunction btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_value_type rptr{btMultiSapBroadphase_btMultiSapProxy};
public metafunction btAlignedAllocator_btOptimizedBvhNode_16_value_type btOptimizedBvhNode;
public metafunction btAlignedAllocator_btQuantizedBvhNode_16_value_type btQuantizedBvhNode;
public metafunction btAlignedAllocator_btBvhSubtreeInfo_16_value_type btBvhSubtreeInfo;
public metafunction btAlignedAllocator_btPersistentManifold_p_16_value_type rptr{btPersistentManifold};
public metafunction btAlignedAllocator_const_btCollisionObject_p_16_value_type crptr{btCollisionObject};
public metafunction btAlignedAllocator_btCollisionObject_p_16_value_type rptr{btCollisionObject};
public metafunction btAlignedAllocator_btVector3_16_value_type btVector3;
public metafunction btAlignedAllocator_float_16_value_type float;
public metafunction btAlignedAllocator_btCollisionShape_p_16_value_type rptr{btCollisionShape};
public metafunction btAlignedAllocator_btOptimizedBvh_p_16_value_type rptr{btOptimizedBvh};
public metafunction btAlignedAllocator_btTriangleIndexVertexArray_p_16_value_type rptr{btTriangleIndexVertexArray};
public metafunction btAlignedAllocator_btStridingMeshInterfaceData_p_16_value_type rptr{btStridingMeshInterfaceData};
public metafunction btAlignedAllocator_char_p_16_value_type rptr{char};
public metafunction btAlignedAllocator_int_p_16_value_type rptr{int};
public metafunction btAlignedAllocator_short_p_16_value_type rptr{short};
public metafunction btAlignedAllocator_unsigned_char_p_16_value_type rptr{uchar};
public metafunction btAlignedAllocator_btVector3FloatData_p_16_value_type rptr{btVector3FloatData};
public metafunction btAlignedAllocator_btVector3DoubleData_p_16_value_type rptr{btVector3DoubleData};
public metafunction btAlignedAllocator_btHashPtr_16_value_type btHashPtr;
public metafunction btAlignedAllocator_btHashString_16_value_type btHashString;
public metafunction btAlignedAllocator_const_char_p_16_value_type crptr{char};
public metafunction btAlignedAllocator_btCollisionAlgorithm_p_16_value_type rptr{btCollisionAlgorithm};
public metafunction btAlignedAllocator_btSimplePair_16_value_type btSimplePair;
public metafunction btAlignedAllocator_btQuantizedBvhDoubleData_p_16_value_type rptr{btQuantizedBvhDoubleData};
public metafunction btAlignedAllocator_btQuantizedBvhFloatData_p_16_value_type rptr{btQuantizedBvhFloatData};
public metafunction btAlignedAllocator_btCollisionShapeData_p_16_value_type rptr{btCollisionShapeData};
public metafunction btAlignedAllocator_btDynamicsWorldDoubleData_p_16_value_type rptr{btDynamicsWorldDoubleData};
public metafunction btAlignedAllocator_btDynamicsWorldFloatData_p_16_value_type rptr{btDynamicsWorldFloatData};
public metafunction btAlignedAllocator_btRigidBodyDoubleData_p_16_value_type rptr{btRigidBodyDoubleData};
public metafunction btAlignedAllocator_btRigidBodyFloatData_p_16_value_type rptr{btRigidBodyFloatData};
public metafunction btAlignedAllocator_btCollisionObjectDoubleData_p_16_value_type rptr{btCollisionObjectDoubleData};
public metafunction btAlignedAllocator_btCollisionObjectFloatData_p_16_value_type rptr{btCollisionObjectFloatData};
public metafunction btAlignedAllocator_btTypedConstraintFloatData_p_16_value_type rptr{btTypedConstraintFloatData};
public metafunction btAlignedAllocator_btTypedConstraintDoubleData_p_16_value_type rptr{btTypedConstraintDoubleData};
public metafunction btAlignedAllocator_btTypedConstraintData_p_16_value_type rptr{btTypedConstraintData};
public metafunction btAlignedAllocator_short_16_value_type short;
public metafunction btAlignedAllocator_btHashInt_16_value_type btHashInt;
public metafunction btAlignedAllocator_void_p_16_value_type rptr{void};
public metafunction btAlignedAllocator_btPointerUid_16_value_type btPointerUid;
public metafunction btAlignedAllocator_btChunk_p_16_value_type rptr{btChunk};
public metafunction btAlignedAllocator_btTriangleInfo_16_value_type btTriangleInfo;
public metafunction btAlignedAllocator_btElement_16_value_type btElement;
public metafunction btAlignedAllocator_btCompoundShapeChild_16_value_type btCompoundShapeChild;
public metafunction btAlignedAllocator_btFace_16_value_type btFace;
public metafunction btAlignedAllocator_btMaterial_p_16_value_type rptr{btMaterial};
public metafunction btAlignedAllocator_unsigned_int_16_value_type uint;
public metafunction btAlignedAllocator_btTriangle_16_value_type btTriangle;
public metafunction btAlignedAllocator_btIndexedMesh_16_value_type btIndexedMesh;
public metafunction btAlignedAllocator_btMaterialProperties_16_value_type btMaterialProperties;
public metafunction btAlignedAllocator_unsigned_short_16_value_type ushort;
public metafunction btAlignedAllocator_btTypedConstraint_p_16_value_type rptr{btTypedConstraint};
public metafunction btAlignedAllocator_btSolverBody_16_value_type btSolverBody;
public metafunction btAlignedAllocator_btSolverConstraint_16_value_type btSolverConstraint;
public metafunction btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_value_type btTypedConstraint_btConstraintInfo1;
public metafunction btAlignedAllocator_btRigidBody_p_16_value_type rptr{btRigidBody};
public metafunction btAlignedAllocator_btActionInterface_p_16_value_type rptr{btActionInterface};
public metafunction btAlignedAllocator_btConvexHullComputer_Edge_16_value_type btConvexHullComputer_Edge;
public metafunction btAlignedAllocator_double_16_value_type double;
public metafunction btAlignedAllocator_btWheelInfo_16_value_type btWheelInfo;
public pure struct extern "::btCollisionDispatcher::workerInfo" "nodefault" btCollisionDispatcher_workerInfo private {
}
public pure function extern "::btAabbSupport" btVector3 btAabbSupport(btVector3 const& halfExtents_0, btVector3 const& supportDir_1);
public pure function extern "::btAcos" btScalar btAcos(btScalar x_0);
public pure function extern "::btActivatingCollisionAlgorithm" "nocdecl" btActivatingCollisionAlgorithm btActivatingCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btActivatingCollisionAlgorithm" "nocdecl" btActivatingCollisionAlgorithm btActivatingCollisionAlgorithm3(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2);
public pure function extern "::btAdjustAngleToLimits" btScalar btAdjustAngleToLimits(btScalar angleInRadians_0, btScalar angleLowerLimitInRadians_1, btScalar angleUpperLimitInRadians_2);
public pure function extern "::btAdjustInternalEdgeContacts" void btAdjustInternalEdgeContacts(btManifoldPoint mutable& cp_0, crptr{btCollisionObjectWrapper} trimeshColObj0Wrap_1, crptr{btCollisionObjectWrapper} otherColObj1Wrap_2, int partId0_3, int index0_4, int normalAdjustFlags_5);
public pure function extern "::btAlignPointer" rptr{char} btAlignPointer(rptr{char} unalignedPtr_0, size_t alignment_1);
public pure function extern "::btAlignedAllocInternal" rptr{void} btAlignedAllocInternal(size_t size_0, int alignment_1);
public pure function extern "::btAlignedAllocSetCustom" void btAlignedAllocSetCustom(rptr{btAllocFunc} allocFunc_0, rptr{btFreeFunc} freeFunc_1);
public pure function extern "::btAlignedAllocSetCustomAligned" void btAlignedAllocSetCustomAligned(rptr{btAlignedAllocFunc} allocFunc_0, rptr{btAlignedFreeFunc} freeFunc_1);
public pure function extern "::btAlignedFreeInternal" void btAlignedFreeInternal(rptr{void} ptr_0);
public pure function extern "::btAngle" btScalar btAngle_btQuaternion_btQuaternion(btQuaternion const& q1_0, btQuaternion const& q2_1);
public pure function extern "::btAngle" btScalar btAngle_btVector3_btVector3(btVector3 const& v1_0, btVector3 const& v2_1);
public pure function extern "::btAngleCompareFunc" "nocdecl" btAngleCompareFunc btAngleCompareFunc1(btVector3 const& anchor_0);
public pure function extern "::btAsin" btScalar btAsin(btScalar x_0);
public pure function extern "::btAtan" btScalar btAtan(btScalar x_0);
public pure function extern "::btAtan2" btScalar btAtan2(btScalar x_0, btScalar y_1);
public pure function extern "::btAtan2Fast" btScalar btAtan2Fast(btScalar y_0, btScalar x_1);
public pure function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_1(btVector3 const& pt0_0);
public pure function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_2(btVector3 const& pt0_0, btVector3 const& pt1_1);
public pure function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_3(btVector3 const& pt0_0, btVector3 const& pt1_1, btVector3 const& pt2_2);
public pure function extern "::btBU_Simplex1to4" "nocdecl" btBU_Simplex1to4 btBU_Simplex1to4_4(btVector3 const& pt0_0, btVector3 const& pt1_1, btVector3 const& pt2_2, btVector3 const& pt3_3);
public pure function extern "::btBox2dBox2dCollisionAlgorithm" "nocdecl" btBox2dBox2dCollisionAlgorithm btBox2dBox2dCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btBox2dBox2dCollisionAlgorithm" "nocdecl" btBox2dBox2dCollisionAlgorithm btBox2dBox2dCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3);
public pure function extern "::btBox2dShape" "nocdecl" btBox2dShape btBox2dShape1(btVector3 const& boxHalfExtents_0);
public pure function extern "::btBoxBoxCollisionAlgorithm" "nocdecl" btBoxBoxCollisionAlgorithm btBoxBoxCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btBoxBoxCollisionAlgorithm" "nocdecl" btBoxBoxCollisionAlgorithm btBoxBoxCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3);
public pure function extern "::btBoxBoxDetector" "nocdecl" btBoxBoxDetector btBoxBoxDetector2(crptr{btBoxShape} box1_0, crptr{btBoxShape} box2_1);
public pure function extern "::btBoxShape" "nocdecl" btBoxShape btBoxShape1(btVector3 const& boxHalfExtents_0);
public pure function extern "::btBroadphasePair" "nocdecl" btBroadphasePair btBroadphasePair2(btBroadphaseProxy mutable& proxy0_0, btBroadphaseProxy mutable& proxy1_1);
public pure function extern "::btBroadphaseProxy" "nocdecl" btBroadphaseProxy btBroadphaseProxy6(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} userPtr_2, short collisionFilterGroup_3, short collisionFilterMask_4, rptr{void} multiSapParentProxy_5);
public pure function extern "::btBroadphaseProxy::isCompound" "nocdecl" bool btBroadphaseProxy_isCompound(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isConcave" "nocdecl" bool btBroadphaseProxy_isConcave(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isConvex" "nocdecl" bool btBroadphaseProxy_isConvex(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isConvex2d" "nocdecl" bool btBroadphaseProxy_isConvex2d(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isInfinite" "nocdecl" bool btBroadphaseProxy_isInfinite(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isNonMoving" "nocdecl" bool btBroadphaseProxy_isNonMoving(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isPolyhedral" "nocdecl" bool btBroadphaseProxy_isPolyhedral(int proxyType_0);
public pure function extern "::btBroadphaseProxy::isSoftBody" "nocdecl" bool btBroadphaseProxy_isSoftBody(int proxyType_0);
public pure function extern "::btBvhTriangleMeshShape" "nocdecl" btBvhTriangleMeshShape btBvhTriangleMeshShape3(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2);
public pure function extern "::btBvhTriangleMeshShape" "nocdecl" btBvhTriangleMeshShape btBvhTriangleMeshShape5(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, btVector3 const& bvhAabbMin_2, btVector3 const& bvhAabbMax_3, bool buildBvh_4);
public pure function extern "::btCapsuleShape" "nocdecl" btCapsuleShape btCapsuleShape2(btScalar radius_0, btScalar height_1);
public pure function extern "::btCapsuleShapeX" "nocdecl" btCapsuleShapeX btCapsuleShapeX2(btScalar radius_0, btScalar height_1);
public pure function extern "::btCapsuleShapeZ" "nocdecl" btCapsuleShapeZ btCapsuleShapeZ2(btScalar radius_0, btScalar height_1);
public pure function extern "::btCollisionAlgorithm" "nocdecl" btCollisionAlgorithm btCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btCollisionAlgorithmConstructionInfo" "nocdecl" btCollisionAlgorithmConstructionInfo btCollisionAlgorithmConstructionInfo2(rptr{btDispatcher} dispatcher_0, int temp_1);
public pure function extern "::btCollisionDispatcher" "nocdecl" btCollisionDispatcher btCollisionDispatcher1(rptr{btCollisionConfiguration} collisionConfiguration_0);
public pure function extern "::btCollisionDispatcher::defaultNearCallback" "nocdecl" void btCollisionDispatcher_defaultNearCallback(btBroadphasePair mutable& collisionPair_0, btCollisionDispatcher mutable& dispatcher_1, btDispatcherInfo const& dispatchInfo_2, int thread_id_3);
public pure function extern "::btCollisionObjectWrapper" "nocdecl" btCollisionObjectWrapper btCollisionObjectWrapper6(crptr{btCollisionObjectWrapper} parent_0, crptr{btCollisionShape} shape_1, crptr{btCollisionObject} collisionObject_2, btTransform const& worldTransform_3, int partId_4, int index_5);
public pure function extern "::btCollisionWorld" "nocdecl" btCollisionWorld btCollisionWorld3(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphasePairCache_1, rptr{btCollisionConfiguration} collisionConfiguration_2);
public pure function extern "::btCollisionWorldImporter" "nocdecl" btCollisionWorldImporter btCollisionWorldImporter1(rptr{btCollisionWorld} world_0);
public pure function extern "::btCollisionWorld::AllHitsRayResultCallback" "nocdecl" btCollisionWorld_AllHitsRayResultCallback btCollisionWorld_AllHitsRayResultCallback2(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1);
public pure function extern "::btCollisionWorld::ClosestConvexResultCallback" "nocdecl" btCollisionWorld_ClosestConvexResultCallback btCollisionWorld_ClosestConvexResultCallback2(btVector3 const& convexFromWorld_0, btVector3 const& convexToWorld_1);
public pure function extern "::btCollisionWorld::ClosestRayResultCallback" "nocdecl" btCollisionWorld_ClosestRayResultCallback btCollisionWorld_ClosestRayResultCallback2(btVector3 const& rayFromWorld_0, btVector3 const& rayToWorld_1);
public pure function extern "::btCollisionWorld::LocalConvexResult" "nocdecl" btCollisionWorld_LocalConvexResult btCollisionWorld_LocalConvexResult5(crptr{btCollisionObject} hitCollisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btVector3 const& hitPointLocal_3, btScalar hitFraction_4);
public pure function extern "::btCollisionWorld::LocalRayResult" "nocdecl" btCollisionWorld_LocalRayResult btCollisionWorld_LocalRayResult4(crptr{btCollisionObject} collisionObject_0, rptr{btCollisionWorld_LocalShapeInfo} localShapeInfo_1, btVector3 const& hitNormalLocal_2, btScalar hitFraction_3);
public pure function extern "::btCollisionWorld::objectQuerySingle" "nocdecl" void btCollisionWorld_objectQuerySingle(crptr{btConvexShape} castShape_0, btTransform const& rayFromTrans_1, btTransform const& rayToTrans_2, rptr{btCollisionObject} collisionObject_3, crptr{btCollisionShape} collisionShape_4, btTransform const& colObjWorldTransform_5, btCollisionWorld_ConvexResultCallback mutable& resultCallback_6, btScalar allowedPenetration_7);
public pure function extern "::btCollisionWorld::objectQuerySingleInternal" "nocdecl" void btCollisionWorld_objectQuerySingleInternal(crptr{btConvexShape} castShape_0, btTransform const& convexFromTrans_1, btTransform const& convexToTrans_2, crptr{btCollisionObjectWrapper} colObjWrap_3, btCollisionWorld_ConvexResultCallback mutable& resultCallback_4, btScalar allowedPenetration_5);
public pure function extern "::btCollisionWorld::rayTestSingle" "nocdecl" void btCollisionWorld_rayTestSingle(btTransform const& rayFromTrans_0, btTransform const& rayToTrans_1, rptr{btCollisionObject} collisionObject_2, crptr{btCollisionShape} collisionShape_3, btTransform const& colObjWorldTransform_4, btCollisionWorld_RayResultCallback mutable& resultCallback_5);
public pure function extern "::btCollisionWorld::rayTestSingleInternal" "nocdecl" void btCollisionWorld_rayTestSingleInternal(btTransform const& rayFromTrans_0, btTransform const& rayToTrans_1, crptr{btCollisionObjectWrapper} collisionObjectWrap_2, btCollisionWorld_RayResultCallback mutable& resultCallback_3);
public pure function extern "::btCompoundCollisionAlgorithm" "nocdecl" btCompoundCollisionAlgorithm btCompoundCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public pure function extern "::btCompoundCompoundCollisionAlgorithm" "nocdecl" btCompoundCompoundCollisionAlgorithm btCompoundCompoundCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public pure function extern "::btCompoundShape" "nocdecl" btCompoundShape btCompoundShape1(bool enableDynamicAabbTree_0);
public pure function extern "::btConeShape" "nocdecl" btConeShape btConeShape2(btScalar radius_0, btScalar height_1);
public pure function extern "::btConeShapeX" "nocdecl" btConeShapeX btConeShapeX2(btScalar radius_0, btScalar height_1);
public pure function extern "::btConeShapeZ" "nocdecl" btConeShapeZ btConeShapeZ2(btScalar radius_0, btScalar height_1);
public pure function extern "::btConeTwistConstraint" "nocdecl" btConeTwistConstraint btConeTwistConstraint2(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1);
public pure function extern "::btConeTwistConstraint" "nocdecl" btConeTwistConstraint btConeTwistConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3);
public pure function extern "::btContactConstraint" "nocdecl" btContactConstraint btContactConstraint3(rptr{btPersistentManifold} contactManifold_0, btRigidBody mutable& rbA_1, btRigidBody mutable& rbB_2);
public pure function extern "::btContinuousConvexCollision" "nocdecl" btContinuousConvexCollision btContinuousConvexCollision2(crptr{btConvexShape} shapeA_0, crptr{btStaticPlaneShape} plane_1);
public pure function extern "::btContinuousConvexCollision" "nocdecl" btContinuousConvexCollision btContinuousConvexCollision4(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3);
public pure function extern "::btConvex2dConvex2dAlgorithm" "nocdecl" btConvex2dConvex2dAlgorithm btConvex2dConvex2dAlgorithm8(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, rptr{btVoronoiSimplexSolver} simplexSolver_4, rptr{btConvexPenetrationDepthSolver} pdSolver_5, int numPerturbationIterations_6, int minimumPointsPerturbationThreshold_7);
public pure function extern "::btConvex2dConvex2dAlgorithm::CreateFunc" "nocdecl" btConvex2dConvex2dAlgorithm_CreateFunc btConvex2dConvex2dAlgorithm_CreateFunc2(rptr{btVoronoiSimplexSolver} simplexSolver_0, rptr{btConvexPenetrationDepthSolver} pdSolver_1);
public pure function extern "::btConvex2dShape" "nocdecl" btConvex2dShape btConvex2dShape1(rptr{btConvexShape} convexChildShape_0);
public pure function extern "::btConvexConcaveCollisionAlgorithm" "nocdecl" btConvexConcaveCollisionAlgorithm btConvexConcaveCollisionAlgorithm4(btCollisionAlgorithmConstructionInfo const& ci_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public pure function extern "::btConvexHullShape" "nocdecl" btConvexHullShape btConvexHullShape3(crptr{btScalar} points_0, int numPoints_1, int stride_2);
public pure function extern "::btConvexPlaneCollisionAlgorithm" "nocdecl" btConvexPlaneCollisionAlgorithm btConvexPlaneCollisionAlgorithm7(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4, int numPerturbationIterations_5, int minimumPointsPerturbationThreshold_6);
public pure function extern "::btConvexPointCloudShape" "nocdecl" btConvexPointCloudShape btConvexPointCloudShape4(rptr{btVector3} points_0, int numPoints_1, btVector3 const& localScaling_2, bool computeAabb_3);
public pure function extern "::btConvexSeparatingDistanceUtil" "nocdecl" btConvexSeparatingDistanceUtil btConvexSeparatingDistanceUtil2(btScalar boundingRadiusA_0, btScalar boundingRadiusB_1);
public pure function extern "::btConvexTriangleCallback" "nocdecl" btConvexTriangleCallback btConvexTriangleCallback4(rptr{btDispatcher} dispatcher_0, crptr{btCollisionObjectWrapper} body0Wrap_1, crptr{btCollisionObjectWrapper} body1Wrap_2, bool isSwapped_3);
public pure function extern "::btConvexTriangleMeshShape" "nocdecl" btConvexTriangleMeshShape btConvexTriangleMeshShape2(rptr{btStridingMeshInterface} meshInterface_0, bool calcAabb_1);
public pure function extern "::btCos" btScalar btCos(btScalar x_0);
public pure function extern "::btCpuFeatureUtility::getCpuFeatures" "nocdecl" int btCpuFeatureUtility_getCpuFeatures();
public pure function extern "::btCross" btVector3 btCross(btVector3 const& v1_0, btVector3 const& v2_1);
public pure function extern "::btCylinderShape" "nocdecl" btCylinderShape btCylinderShape1(btVector3 const& halfExtents_0);
public pure function extern "::btCylinderShapeX" "nocdecl" btCylinderShapeX btCylinderShapeX1(btVector3 const& halfExtents_0);
public pure function extern "::btCylinderShapeZ" "nocdecl" btCylinderShapeZ btCylinderShapeZ1(btVector3 const& halfExtents_0);
public pure function extern "::btDbvtAabbMm::FromCE" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCE(btVector3 const& c_0, btVector3 const& e_1);
public pure function extern "::btDbvtAabbMm::FromCR" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromCR(btVector3 const& c_0, btScalar r_1);
public pure function extern "::btDbvtAabbMm::FromMM" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromMM(btVector3 const& mi_0, btVector3 const& mx_1);
public pure function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints_btVector3_cp_int(crptr{btVector3} pts_0, int n_1);
public pure function extern "::btDbvtAabbMm::FromPoints" "nocdecl" btDbvtAabbMm btDbvtAabbMm_FromPoints_btVector3_cp_p_int(rptr{crptr{btVector3}} ppts_0, int n_1);
public pure function extern "::btDbvtBroadphase" "nocdecl" btDbvtBroadphase btDbvtBroadphase1(rptr{btOverlappingPairCache} paircache_0);
public pure function extern "::btDbvtBroadphase::benchmark" "nocdecl" void btDbvtBroadphase_benchmark(rptr{btBroadphaseInterface} _0);
public pure function extern "::btDbvtProxy" "nocdecl" btDbvtProxy btDbvtProxy5(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, rptr{void} userPtr_2, short collisionFilterGroup_3, short collisionFilterMask_4);
public pure function extern "::btDbvt::benchmark" "nocdecl" void btDbvt_benchmark();
public pure function extern "::btDbvt::collideKDOP" "nocdecl" void btDbvt_collideKDOP(crptr{btDbvtNode} root_0, crptr{btVector3} normals_1, crptr{btScalar} offsets_2, int count_3, btDbvt_ICollide mutable& policy_4);
public pure function extern "::btDbvt::collideOCL" "nocdecl" void btDbvt_collideOCL(crptr{btDbvtNode} root_0, crptr{btVector3} normals_1, crptr{btScalar} offsets_2, btVector3 const& sortaxis_3, int count_4, btDbvt_ICollide mutable& policy_5, bool fullsort_6);
public pure function extern "::btDbvt::collideTU" "nocdecl" void btDbvt_collideTU(crptr{btDbvtNode} root_0, btDbvt_ICollide mutable& policy_1);
public pure function extern "::btDbvt::countLeaves" "nocdecl" int btDbvt_countLeaves(crptr{btDbvtNode} node_0);
public pure function extern "::btDbvt::enumLeaves" "nocdecl" void btDbvt_enumLeaves(crptr{btDbvtNode} root_0, btDbvt_ICollide mutable& policy_1);
public pure function extern "::btDbvt::enumNodes" "nocdecl" void btDbvt_enumNodes(crptr{btDbvtNode} root_0, btDbvt_ICollide mutable& policy_1);
public pure function extern "::btDbvt::maxdepth" "nocdecl" int btDbvt_maxdepth(crptr{btDbvtNode} node_0);
public pure function extern "::btDbvt::nearest" "nocdecl" int btDbvt_nearest(crptr{int} i_0, crptr{btDbvt_sStkNPS} a_1, btScalar v_2, int l_3, int h_4);
public pure function extern "::btDbvt::rayTest" "nocdecl" void btDbvt_rayTest(crptr{btDbvtNode} root_0, btVector3 const& rayFrom_1, btVector3 const& rayTo_2, btDbvt_ICollide mutable& policy_3);
public pure function extern "::btDbvt::sStkCLN" "nocdecl" btDbvt_sStkCLN btDbvt_sStkCLN2(crptr{btDbvtNode} n_0, rptr{btDbvtNode} p_1);
public pure function extern "::btDbvt::sStkNN" "nocdecl" btDbvt_sStkNN btDbvt_sStkNN2(crptr{btDbvtNode} na_0, crptr{btDbvtNode} nb_1);
public pure function extern "::btDbvt::sStkNP" "nocdecl" btDbvt_sStkNP btDbvt_sStkNP2(crptr{btDbvtNode} n_0, uint m_1);
public pure function extern "::btDbvt::sStkNPS" "nocdecl" btDbvt_sStkNPS btDbvt_sStkNPS3(crptr{btDbvtNode} n_0, uint m_1, btScalar v_2);
public pure function extern "::btDefaultCollisionConfiguration" "nocdecl" btDefaultCollisionConfiguration btDefaultCollisionConfiguration1(btDefaultCollisionConstructionInfo const& constructionInfo_0);
public pure function extern "::btDefaultMotionState" "nocdecl" btDefaultMotionState btDefaultMotionState2(btTransform const& startTrans_0, btTransform const& centerOfMassOffset_1);
public pure function extern "::btDefaultSerializer" "nocdecl" btDefaultSerializer btDefaultSerializer1(int totalSize_0);
public pure function extern "::btDefaultVehicleRaycaster" "nocdecl" btDefaultVehicleRaycaster btDefaultVehicleRaycaster1(rptr{btDynamicsWorld} world_0);
public pure function extern "::btDegrees" btScalar btDegrees(btScalar x_0);
public pure function extern "::btDiscreteDynamicsWorld" "nocdecl" btDiscreteDynamicsWorld btDiscreteDynamicsWorld4(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3);
public pure function extern "::btDistance" btScalar btDistance(btVector3 const& v1_0, btVector3 const& v2_1);
public pure function extern "::btDistance2" btScalar btDistance2(btVector3 const& v1_0, btVector3 const& v2_1);
public pure function extern "::btDot" btScalar btDot(btVector3 const& v1_0, btVector3 const& v2_1);
public pure function extern "::btDynamicsWorld" "nocdecl" btDynamicsWorld btDynamicsWorld3(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} broadphase_1, rptr{btCollisionConfiguration} collisionConfiguration_2);
public pure function extern "::btEmptyAlgorithm" "nocdecl" btEmptyAlgorithm btEmptyAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btEqual" bool btEqual(btScalar a_0, btScalar eps_1);
public pure function extern "::btExp" btScalar btExp(btScalar x_0);
public pure function extern "::btFabs" btScalar btFabs(btScalar x_0);
public pure function extern "::btFmod" btScalar btFmod(btScalar x_0, btScalar y_1);
public pure function extern "::btFsel" btScalar btFsel(btScalar a_0, btScalar b_1, btScalar c_2);
public pure function extern "::btFuzzyZero" bool btFuzzyZero(btScalar x_0);
public pure function extern "::btGEN_Link" "nocdecl" btGEN_Link btGEN_Link2(rptr{btGEN_Link} next_0, rptr{btGEN_Link} prev_1);
public pure function extern "::btGearConstraint" "nocdecl" btGearConstraint btGearConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& axisInA_2, btVector3 const& axisInB_3, btScalar ratio_4);
public pure function extern "::btGeneric6DofConstraint" "nocdecl" btGeneric6DofConstraint btGeneric6DofConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameB_2);
public pure function extern "::btGeneric6DofConstraint" "nocdecl" btGeneric6DofConstraint btGeneric6DofConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
public pure function extern "::btGeneric6DofSpringConstraint" "nocdecl" btGeneric6DofSpringConstraint btGeneric6DofSpringConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameB_2);
public pure function extern "::btGeneric6DofSpringConstraint" "nocdecl" btGeneric6DofSpringConstraint btGeneric6DofSpringConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
public pure function extern "::btGetInfinityMask" int btGetInfinityMask();
public pure function extern "::btGetVersion" int btGetVersion();
public pure function extern "::btGhostObject::upcast" "nocdecl" crptr{btGhostObject} btGhostObject_upcast_btCollisionObject_cp(crptr{btCollisionObject} colObj_0);
public pure function extern "::btGhostObject::upcast" "nocdecl" rptr{btGhostObject} btGhostObject_upcast_btCollisionObject_p(rptr{btCollisionObject} colObj_0);
public pure function extern "::btGjkConvexCast" "nocdecl" btGjkConvexCast btGjkConvexCast3(crptr{btConvexShape} convexA_0, crptr{btConvexShape} convexB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2);
public pure function extern "::btGjkEpaSolver2::Distance" "nocdecl" bool btGjkEpaSolver2_Distance(crptr{btConvexShape} shape0_0, btTransform const& wtrs0_1, crptr{btConvexShape} shape1_2, btTransform const& wtrs1_3, btVector3 const& guess_4, btGjkEpaSolver2_sResults mutable& results_5);
public pure function extern "::btGjkEpaSolver2::Penetration" "nocdecl" bool btGjkEpaSolver2_Penetration(crptr{btConvexShape} shape0_0, btTransform const& wtrs0_1, crptr{btConvexShape} shape1_2, btTransform const& wtrs1_3, btVector3 const& guess_4, btGjkEpaSolver2_sResults mutable& results_5, bool usemargins_6);
public pure function extern "::btGjkEpaSolver2::SignedDistance" "nocdecl" btScalar btGjkEpaSolver2_SignedDistance5(btVector3 const& position_0, btScalar margin_1, crptr{btConvexShape} shape_2, btTransform const& wtrs_3, btGjkEpaSolver2_sResults mutable& results_4);
public pure function extern "::btGjkEpaSolver2::SignedDistance" "nocdecl" bool btGjkEpaSolver2_SignedDistance6(crptr{btConvexShape} shape0_0, btTransform const& wtrs0_1, crptr{btConvexShape} shape1_2, btTransform const& wtrs1_3, btVector3 const& guess_4, btGjkEpaSolver2_sResults mutable& results_5);
public pure function extern "::btGjkEpaSolver2::StackSizeRequirement" "nocdecl" int btGjkEpaSolver2_StackSizeRequirement();
public pure function extern "::btGjkPairDetector" "nocdecl" btGjkPairDetector btGjkPairDetector4(crptr{btConvexShape} objectA_0, crptr{btConvexShape} objectB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_3);
public pure function extern "::btGjkPairDetector" "nocdecl" btGjkPairDetector btGjkPairDetector8(crptr{btConvexShape} objectA_0, crptr{btConvexShape} objectB_1, int shapeTypeA_2, int shapeTypeB_3, btScalar marginA_4, btScalar marginB_5, rptr{btVoronoiSimplexSolver} simplexSolver_6, rptr{btConvexPenetrationDepthSolver} penetrationDepthSolver_7);
public pure function extern "::btGreaterEqual" bool btGreaterEqual(btScalar a_0, btScalar eps_1);
public pure function extern "::btHashInt" "nocdecl" btHashInt btHashInt1(int uid_0);
public pure function extern "::btHashPtr" "nocdecl" btHashPtr btHashPtr1(crptr{void} ptr_0);
public pure function extern "::btHashString" "nocdecl" btHashString btHashString1(crptr{char} name_0);
public pure function extern "::btHeightfieldTerrainShape" "nocdecl" btHeightfieldTerrainShape btHeightfieldTerrainShape7(int heightStickWidth_0, int heightStickLength_1, crptr{void} heightfieldData_2, btScalar maxHeight_3, int upAxis_4, bool useFloatData_5, bool flipQuadEdges_6);
public pure function extern "::btHeightfieldTerrainShape" "nocdecl" btHeightfieldTerrainShape btHeightfieldTerrainShape9(int heightStickWidth_0, int heightStickLength_1, crptr{void} heightfieldData_2, btScalar heightScale_3, btScalar minHeight_4, btScalar maxHeight_5, int upAxis_6, PHY_ScalarType heightDataType_7, bool flipQuadEdges_8);
public pure function extern "::btHingeAccumulatedAngleConstraint" "nocdecl" btHingeAccumulatedAngleConstraint btHingeAccumulatedAngleConstraint3(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1, bool useReferenceFrameA_2);
public pure function extern "::btHingeAccumulatedAngleConstraint" "nocdecl" btHingeAccumulatedAngleConstraint btHingeAccumulatedAngleConstraint4(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1, btVector3 const& axisInA_2, bool useReferenceFrameA_3);
public pure function extern "::btHingeAccumulatedAngleConstraint" "nocdecl" btHingeAccumulatedAngleConstraint btHingeAccumulatedAngleConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3, bool useReferenceFrameA_4);
public pure function extern "::btHingeAccumulatedAngleConstraint" "nocdecl" btHingeAccumulatedAngleConstraint btHingeAccumulatedAngleConstraint7(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3, btVector3 const& axisInA_4, btVector3 const& axisInB_5, bool useReferenceFrameA_6);
public pure function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint3(btRigidBody mutable& rbA_0, btTransform const& rbAFrame_1, bool useReferenceFrameA_2);
public pure function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint4(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1, btVector3 const& axisInA_2, bool useReferenceFrameA_3);
public pure function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& rbAFrame_2, btTransform const& rbBFrame_3, bool useReferenceFrameA_4);
public pure function extern "::btHingeConstraint" "nocdecl" btHingeConstraint btHingeConstraint7(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3, btVector3 const& axisInA_4, btVector3 const& axisInB_5, bool useReferenceFrameA_6);
public pure function extern "::btInfMaskConverter" "nocdecl" btInfMaskConverter btInfMaskConverter1(int mask_0);
public pure function extern "::btIsNegative" int btIsNegative(btScalar x_0);
public pure function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry4(btVector3 const& axisInA_0, btVector3 const& axisInB_1, btVector3 const& inertiaInvA_2, btVector3 const& inertiaInvB_3);
public pure function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry5(btVector3 const& jointAxis_0, btMatrix3x3 const& world2A_1, btMatrix3x3 const& world2B_2, btVector3 const& inertiaInvA_3, btVector3 const& inertiaInvB_4);
public pure function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry6(btMatrix3x3 const& world2A_0, btVector3 const& rel_pos1_1, btVector3 const& rel_pos2_2, btVector3 const& jointAxis_3, btVector3 const& inertiaInvA_4, btScalar const massInvA_5);
public pure function extern "::btJacobianEntry" "nocdecl" btJacobianEntry btJacobianEntry9(btMatrix3x3 const& world2A_0, btMatrix3x3 const& world2B_1, btVector3 const& rel_pos1_2, btVector3 const& rel_pos2_3, btVector3 const& jointAxis_4, btVector3 const& inertiaInvA_5, btScalar const massInvA_6, btVector3 const& inertiaInvB_7, btScalar const massInvB_8);
public pure function extern "::btKinematicCharacterController" "nocdecl" btKinematicCharacterController btKinematicCharacterController4(rptr{btPairCachingGhostObject} ghostObject_0, rptr{btConvexShape} convexShape_1, btScalar stepHeight_2, int upAxis_3);
public pure function extern "::btLargeDot" btScalar btLargeDot(crptr{btScalar} a_0, crptr{btScalar} b_1, int n_2);
public pure function extern "::btLog" btScalar btLog(btScalar x_0);
public pure function extern "::btMachineIsLittleEndian" bool btMachineIsLittleEndian();
public pure function extern "::btManifoldPoint" "nocdecl" btManifoldPoint btManifoldPoint4(btVector3 const& pointA_0, btVector3 const& pointB_1, btVector3 const& normal_2, btScalar distance_3);
public pure function extern "::btManifoldResult" "nocdecl" btManifoldResult btManifoldResult2(crptr{btCollisionObjectWrapper} body0Wrap_0, crptr{btCollisionObjectWrapper} body1Wrap_1);
public pure function extern "::btManifoldResult::calculateCombinedFriction" "nocdecl" btScalar btManifoldResult_calculateCombinedFriction(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
public pure function extern "::btManifoldResult::calculateCombinedRestitution" "nocdecl" btScalar btManifoldResult_calculateCombinedRestitution(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1);
public pure function extern "::btMaterial" "nocdecl" btMaterial btMaterial2(btScalar fric_0, btScalar rest_1);
public pure function extern "::btMatrix3x3" "nocdecl" btMatrix3x3 btMatrix3x3_1(btQuaternion const& q_0);
public pure function extern "::btMatrix3x3" "nocdecl" btMatrix3x3 btMatrix3x3_9(btScalar const& xx_0, btScalar const& xy_1, btScalar const& xz_2, btScalar const& yx_3, btScalar const& yy_4, btScalar const& yz_5, btScalar const& zx_6, btScalar const& zy_7, btScalar const& zz_8);
public pure function extern "::btMatrix3x3::getIdentity" "nocdecl" btMatrix3x3 const& btMatrix3x3_getIdentity();
public pure function extern "::btMax" float const& btMax(float const& a_0, float const& b_1);
public pure function extern "::btMin" float const& btMin(float const& a_0, float const& b_1);
public pure function extern "::btMinkowskiSumShape" "nocdecl" btMinkowskiSumShape btMinkowskiSumShape2(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1);
public pure function extern "::btMprEq" int btMprEq(float _a_0, float _b_1);
public pure function extern "::btMprIsZero" int btMprIsZero(float val_0);
public pure function extern "::btMprVec3Add" void btMprVec3Add(rptr{btVector3} v_0, crptr{btVector3} w_1);
public pure function extern "::btMprVec3Copy" void btMprVec3Copy(rptr{btVector3} v_0, crptr{btVector3} w_1);
public pure function extern "::btMprVec3Cross" void btMprVec3Cross(rptr{btVector3} d_0, crptr{btVector3} a_1, crptr{btVector3} b_2);
public pure function extern "::btMprVec3Dist2" float btMprVec3Dist2(crptr{btVector3} a_0, crptr{btVector3} b_1);
public pure function extern "::btMprVec3Dot" float btMprVec3Dot(crptr{btVector3} a_0, crptr{btVector3} b_1);
public pure function extern "::btMprVec3Eq" int btMprVec3Eq(crptr{btVector3} a_0, crptr{btVector3} b_1);
public pure function extern "::btMprVec3Len2" float btMprVec3Len2(crptr{btVector3} v_0);
public pure function extern "::btMprVec3Normalize" void btMprVec3Normalize(rptr{btVector3} d_0);
public pure function extern "::btMprVec3PointTriDist2" float btMprVec3PointTriDist2(crptr{btVector3} P_0, crptr{btVector3} x0_1, crptr{btVector3} B_2, crptr{btVector3} C_3, rptr{btVector3} witness_4);
public pure function extern "::btMprVec3Scale" void btMprVec3Scale(rptr{btVector3} d_0, float k_1);
public pure function extern "::btMprVec3Set" void btMprVec3Set(rptr{btVector3} v_0, float x_1, float y_2, float z_3);
public pure function extern "::btMprVec3Sub2" void btMprVec3Sub2(rptr{btVector3} d_0, crptr{btVector3} v_1, crptr{btVector3} w_2);
public pure function extern "::btMultiSapBroadphase" "nocdecl" btMultiSapBroadphase btMultiSapBroadphase2(int maxProxies_0, rptr{btOverlappingPairCache} pairCache_1);
public pure function extern "::btMultiSapBroadphase::btMultiSapProxy" "nocdecl" btMultiSapBroadphase_btMultiSapProxy btMultiSapBroadphase_btMultiSapProxy6(btVector3 const& aabbMin_0, btVector3 const& aabbMax_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5);
public pure function extern "::btMultiSphereShape" "nocdecl" btMultiSphereShape btMultiSphereShape3(crptr{btVector3} positions_0, crptr{btScalar} radi_1, int numSpheres_2);
public pure function extern "::btMultimaterialTriangleMeshShape" "nocdecl" btMultimaterialTriangleMeshShape btMultimaterialTriangleMeshShape3(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, bool buildBvh_2);
public pure function extern "::btMultimaterialTriangleMeshShape" "nocdecl" btMultimaterialTriangleMeshShape btMultimaterialTriangleMeshShape5(rptr{btStridingMeshInterface} meshInterface_0, bool useQuantizedAabbCompression_1, btVector3 const& bvhAabbMin_2, btVector3 const& bvhAabbMax_3, bool buildBvh_4);
public pure function extern "::btNormalizeAngle" btScalar btNormalizeAngle(btScalar angleInRadians_0);
public pure function extern "::btOptimizedBvh::deSerializeInPlace" "nocdecl" rptr{btOptimizedBvh} btOptimizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2);
public pure function extern "::btOutcode" int btOutcode(btVector3 const& p_0, btVector3 const& halfExtent_1);
public pure function extern "::btPersistentManifold" "nocdecl" btPersistentManifold btPersistentManifold5(crptr{btCollisionObject} body0_0, crptr{btCollisionObject} body1_1, int _2, btScalar contactBreakingThreshold_3, btScalar contactProcessingThreshold_4);
public pure function extern "::btPlaneSpace1" void btPlaneSpace1(btVector3 const& n_0, btVector3 mutable& p_1, btVector3 mutable& q_2);
public pure function extern "::btPoint2PointConstraint" "nocdecl" btPoint2PointConstraint btPoint2PointConstraint2(btRigidBody mutable& rbA_0, btVector3 const& pivotInA_1);
public pure function extern "::btPoint2PointConstraint" "nocdecl" btPoint2PointConstraint btPoint2PointConstraint4(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& pivotInA_2, btVector3 const& pivotInB_3);
public pure function extern "::btPolarDecomposition" "nocdecl" btPolarDecomposition btPolarDecomposition2(btScalar tolerance_0, uint maxIterations_1);
public pure function extern "::btPolyhedralContactClipping::clipHullAgainstHull" "nocdecl" void btPolyhedralContactClipping_clipHullAgainstHull(btVector3 const& separatingNormal_0, btConvexPolyhedron const& hullA_1, btConvexPolyhedron const& hullB_2, btTransform const& transA_3, btTransform const& transB_4, btScalar const minDist_5, btScalar maxDist_6, btDiscreteCollisionDetectorInterface_Result mutable& resultOut_7);
public pure function extern "::btPolyhedralContactClipping::findSeparatingAxis" "nocdecl" bool btPolyhedralContactClipping_findSeparatingAxis(btConvexPolyhedron const& hullA_0, btConvexPolyhedron const& hullB_1, btTransform const& transA_2, btTransform const& transB_3, btVector3 mutable& sep_4, btDiscreteCollisionDetectorInterface_Result mutable& resultOut_5);
public pure function extern "::btPoolAllocator" "nocdecl" btPoolAllocator btPoolAllocator2(int elemSize_0, int maxElements_1);
public pure function extern "::btPow" btScalar btPow(btScalar x_0, btScalar y_1);
public pure function extern "::btQuadWord" "nocdecl" btQuadWord btQuadWord3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
public pure function extern "::btQuadWord" "nocdecl" btQuadWord btQuadWord4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
public pure function extern "::btQuantizedBvh::deSerializeInPlace" "nocdecl" rptr{btQuantizedBvh} btQuantizedBvh_deSerializeInPlace(rptr{void} i_alignedDataBuffer_0, uint i_dataBufferSize_1, bool i_swapEndian_2);
public pure function extern "::btQuantizedBvh::getAlignmentSerializationPadding" "nocdecl" uint btQuantizedBvh_getAlignmentSerializationPadding();
public pure function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion2(btVector3 const& _axis_0, btScalar const& _angle_1);
public pure function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion3(btScalar const& yaw_0, btScalar const& pitch_1, btScalar const& roll_2);
public pure function extern "::btQuaternion" "nocdecl" btQuaternion btQuaternion4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
public pure function extern "::btQuaternion::getIdentity" "nocdecl" btQuaternion const& btQuaternion_getIdentity();
public pure function extern "::btRadians" btScalar btRadians(btScalar x_0);
public pure function extern "::btRayAabb" bool btRayAabb(btVector3 const& rayFrom_0, btVector3 const& rayTo_1, btVector3 const& aabbMin_2, btVector3 const& aabbMax_3, btScalar mutable& param_4, btVector3 mutable& normal_5);
public pure function extern "::btRayAabb2" bool btRayAabb2(btVector3 const& rayFrom_0, btVector3 const& rayInvDirection_1, crptr{uint} raySign_2, crptr{btVector3} bounds_3, btScalar mutable& tmin_4, btScalar lambda_min_5, btScalar lambda_max_6);
public pure function extern "::btRaycastVehicle" "nocdecl" btRaycastVehicle btRaycastVehicle3(btRaycastVehicle_btVehicleTuning const& tuning_0, rptr{btRigidBody} chassis_1, rptr{btVehicleRaycaster} raycaster_2);
public pure function extern "::btRigidBody" "nocdecl" btRigidBody btRigidBody1(btRigidBody_btRigidBodyConstructionInfo const& constructionInfo_0);
public pure function extern "::btRigidBody" "nocdecl" btRigidBody btRigidBody4(btScalar mass_0, rptr{btMotionState} motionState_1, rptr{btCollisionShape} collisionShape_2, btVector3 const& localInertia_3);
public pure function extern "::btRigidBody::btRigidBodyConstructionInfo" "nocdecl" btRigidBody_btRigidBodyConstructionInfo btRigidBody_btRigidBodyConstructionInfo4(btScalar mass_0, rptr{btMotionState} motionState_1, rptr{btCollisionShape} collisionShape_2, btVector3 const& localInertia_3);
public pure function extern "::btRigidBody::upcast" "nocdecl" crptr{btRigidBody} btRigidBody_upcast_btCollisionObject_cp(crptr{btCollisionObject} colObj_0);
public pure function extern "::btRigidBody::upcast" "nocdecl" rptr{btRigidBody} btRigidBody_upcast_btCollisionObject_p(rptr{btCollisionObject} colObj_0);
public pure function extern "::btScaledBvhTriangleMeshShape" "nocdecl" btScaledBvhTriangleMeshShape btScaledBvhTriangleMeshShape2(rptr{btBvhTriangleMeshShape} childShape_0, btVector3 const& localScaling_1);
public pure function extern "::btSelect" float btSelect_unsigned_int_float_float(uint condition_0, float valueIfConditionNonZero_1, float valueIfConditionZero_2);
public pure function extern "::btSelect" int btSelect_unsigned_int_int_int(uint condition_0, int valueIfConditionNonZero_1, int valueIfConditionZero_2);
public pure function extern "::btSelect" uint btSelect_unsigned_int_unsigned_int_unsigned_int(uint condition_0, uint valueIfConditionNonZero_1, uint valueIfConditionZero_2);
public pure function extern "::btSetMax" void btSetMax(float mutable& a_0, float const& b_1);
public pure function extern "::btSetMin" void btSetMin(float mutable& a_0, float const& b_1);
public pure function extern "::btShapeHull" "nocdecl" btShapeHull btShapeHull1(crptr{btConvexShape} shape_0);
public pure function extern "::btSimpleBroadphase" "nocdecl" btSimpleBroadphase btSimpleBroadphase2(int maxProxies_0, rptr{btOverlappingPairCache} overlappingPairCache_1);
public pure function extern "::btSimpleBroadphaseProxy" "nocdecl" btSimpleBroadphaseProxy btSimpleBroadphaseProxy7(btVector3 const& minpt_0, btVector3 const& maxpt_1, int shapeType_2, rptr{void} userPtr_3, short collisionFilterGroup_4, short collisionFilterMask_5, rptr{void} multiSapProxy_6);
public pure function extern "::btSimpleBroadphase::aabbOverlap" "nocdecl" bool btSimpleBroadphase_aabbOverlap(rptr{btSimpleBroadphaseProxy} proxy0_0, rptr{btSimpleBroadphaseProxy} proxy1_1);
public pure function extern "::btSimpleDynamicsWorld" "nocdecl" btSimpleDynamicsWorld btSimpleDynamicsWorld4(rptr{btDispatcher} dispatcher_0, rptr{btBroadphaseInterface} pairCache_1, rptr{btConstraintSolver} constraintSolver_2, rptr{btCollisionConfiguration} collisionConfiguration_3);
public pure function extern "::btSimplePair" "nocdecl" btSimplePair btSimplePair2(int indexA_0, int indexB_1);
public pure function extern "::btSin" btScalar btSin(btScalar x_0);
public pure function extern "::btSliderConstraint" "nocdecl" btSliderConstraint btSliderConstraint3(btRigidBody mutable& rbB_0, btTransform const& frameInB_1, bool useLinearReferenceFrameA_2);
public pure function extern "::btSliderConstraint" "nocdecl" btSliderConstraint btSliderConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btTransform const& frameInA_2, btTransform const& frameInB_3, bool useLinearReferenceFrameA_4);
public pure function extern "::btSolve2LinearConstraint" "nocdecl" btSolve2LinearConstraint btSolve2LinearConstraint2(btScalar tau_0, btScalar damping_1);
public pure function extern "::btSpatialForceVector" "nocdecl" btSpatialForceVector btSpatialForceVector2(btVector3 const& angular_0, btVector3 const& linear_1);
public pure function extern "::btSpatialForceVector" "nocdecl" btSpatialForceVector btSpatialForceVector6(btScalar const& ax_0, btScalar const& ay_1, btScalar const& az_2, btScalar const& lx_3, btScalar const& ly_4, btScalar const& lz_5);
public pure function extern "::btSpatialMotionVector" "nocdecl" btSpatialMotionVector btSpatialMotionVector2(btVector3 const& angular_0, btVector3 const& linear_1);
public pure function extern "::btSphereBoxCollisionAlgorithm" "nocdecl" btSphereBoxCollisionAlgorithm btSphereBoxCollisionAlgorithm5(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool isSwapped_4);
public pure function extern "::btSphereShape" "nocdecl" btSphereShape btSphereShape1(btScalar radius_0);
public pure function extern "::btSphereSphereCollisionAlgorithm" "nocdecl" btSphereSphereCollisionAlgorithm btSphereSphereCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btSphereSphereCollisionAlgorithm" "nocdecl" btSphereSphereCollisionAlgorithm btSphereSphereCollisionAlgorithm4(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} col0Wrap_2, crptr{btCollisionObjectWrapper} col1Wrap_3);
public pure function extern "::btSphereTriangleCollisionAlgorithm" "nocdecl" btSphereTriangleCollisionAlgorithm btSphereTriangleCollisionAlgorithm1(btCollisionAlgorithmConstructionInfo const& ci_0);
public pure function extern "::btSphereTriangleCollisionAlgorithm" "nocdecl" btSphereTriangleCollisionAlgorithm btSphereTriangleCollisionAlgorithm5(rptr{btPersistentManifold} mf_0, btCollisionAlgorithmConstructionInfo const& ci_1, crptr{btCollisionObjectWrapper} body0Wrap_2, crptr{btCollisionObjectWrapper} body1Wrap_3, bool swapped_4);
public pure function extern "::btSqrt" btScalar btSqrt(btScalar y_0);
public pure function extern "::btStackAlloc" "nocdecl" btStackAlloc btStackAlloc1(uint size_0);
public pure function extern "::btStaticPlaneShape" "nocdecl" btStaticPlaneShape btStaticPlaneShape2(btVector3 const& planeNormal_0, btScalar planeConstant_1);
public pure function extern "::btStrLen" int btStrLen(crptr{char} str_0);
public pure function extern "::btSubsimplexConvexCast" "nocdecl" btSubsimplexConvexCast btSubsimplexConvexCast3(crptr{btConvexShape} shapeA_0, crptr{btConvexShape} shapeB_1, rptr{btVoronoiSimplexSolver} simplexSolver_2);
public pure function extern "::btSwapEndian" uint btSwapEndian_int(int val_0);
public pure function extern "::btSwapEndian" ushort btSwapEndian_short_int(short val_0);
public pure function extern "::btSwapEndian" ushort btSwapEndian_short_unsigned_int(ushort val_0);
public pure function extern "::btSwapEndian" uint btSwapEndian_unsigned_int(uint val_0);
public pure function extern "::btSwapEndianDouble" void btSwapEndianDouble(double d_0, rptr{uchar} dst_1);
public pure function extern "::btSwapEndianFloat" uint btSwapEndianFloat(float d_0);
public pure function extern "::btSwapScalarEndian" void btSwapScalarEndian(btScalar const& sourceVal_0, btScalar mutable& destVal_1);
public pure function extern "::btSwapVector3Endian" void btSwapVector3Endian(btVector3 const& sourceVec_0, btVector3 mutable& destVec_1);
public pure function extern "::btSymmetricSpatialDyad" "nocdecl" btSymmetricSpatialDyad btSymmetricSpatialDyad3(btMatrix3x3 const& topLeftMat_0, btMatrix3x3 const& topRightMat_1, btMatrix3x3 const& bottomLeftMat_2);
public pure function extern "::btTan" btScalar btTan(btScalar x_0);
public pure function extern "::btTransform" "nocdecl" btTransform btTransform_btMatrix3x3_btVector3(btMatrix3x3 const& b_0, btVector3 const& c_1);
public pure function extern "::btTransform" "nocdecl" btTransform btTransform_btQuaternion_btVector3(btQuaternion const& q_0, btVector3 const& c_1);
public pure function extern "::btTransformAabb" void btTransformAabb5(btVector3 const& halfExtents_0, btScalar margin_1, btTransform const& t_2, btVector3 mutable& aabbMinOut_3, btVector3 mutable& aabbMaxOut_4);
public pure function extern "::btTransformAabb" void btTransformAabb6(btVector3 const& localAabbMin_0, btVector3 const& localAabbMax_1, btScalar margin_2, btTransform const& trans_3, btVector3 mutable& aabbMinOut_4, btVector3 mutable& aabbMaxOut_5);
public pure function extern "::btTransformUtil::calculateDiffAxisAngle" "nocdecl" void btTransformUtil_calculateDiffAxisAngle(btTransform const& transform0_0, btTransform const& transform1_1, btVector3 mutable& axis_2, btScalar mutable& angle_3);
public pure function extern "::btTransformUtil::calculateDiffAxisAngleQuaternion" "nocdecl" void btTransformUtil_calculateDiffAxisAngleQuaternion(btQuaternion const& orn0_0, btQuaternion const& orn1a_1, btVector3 mutable& axis_2, btScalar mutable& angle_3);
public pure function extern "::btTransformUtil::calculateVelocity" "nocdecl" void btTransformUtil_calculateVelocity(btTransform const& transform0_0, btTransform const& transform1_1, btScalar timeStep_2, btVector3 mutable& linVel_3, btVector3 mutable& angVel_4);
public pure function extern "::btTransformUtil::calculateVelocityQuaternion" "nocdecl" void btTransformUtil_calculateVelocityQuaternion(btVector3 const& pos0_0, btVector3 const& pos1_1, btQuaternion const& orn0_2, btQuaternion const& orn1_3, btScalar timeStep_4, btVector3 mutable& linVel_5, btVector3 mutable& angVel_6);
public pure function extern "::btTransformUtil::integrateTransform" "nocdecl" void btTransformUtil_integrateTransform(btTransform const& curTrans_0, btVector3 const& linvel_1, btVector3 const& angvel_2, btScalar timeStep_3, btTransform mutable& predictedTransform_4);
public pure function extern "::btTransform::getIdentity" "nocdecl" btTransform const& btTransform_getIdentity();
public pure function extern "::btTriangleConvexcastCallback" "nocdecl" btTriangleConvexcastCallback btTriangleConvexcastCallback5(crptr{btConvexShape} convexShape_0, btTransform const& convexShapeFrom_1, btTransform const& convexShapeTo_2, btTransform const& triangleToWorld_3, btScalar const triangleCollisionMargin_4);
public pure function extern "::btTriangleIndexVertexArray" "nocdecl" btTriangleIndexVertexArray btTriangleIndexVertexArray6(int numTriangles_0, rptr{int} triangleIndexBase_1, int triangleIndexStride_2, int numVertices_3, rptr{btScalar} vertexBase_4, int vertexStride_5);
public pure function extern "::btTriangleIndexVertexMaterialArray" "nocdecl" btTriangleIndexVertexMaterialArray btTriangleIndexVertexMaterialArray11(int numTriangles_0, rptr{int} triangleIndexBase_1, int triangleIndexStride_2, int numVertices_3, rptr{btScalar} vertexBase_4, int vertexStride_5, int numMaterials_6, rptr{uchar} materialBase_7, int materialStride_8, rptr{int} triangleMaterialsBase_9, int materialIndexStride_10);
public pure function extern "::btTriangleMesh" "nocdecl" btTriangleMesh btTriangleMesh2(bool use32bitIndices_0, bool use4componentVertices_1);
public pure function extern "::btTriangleRaycastCallback" "nocdecl" btTriangleRaycastCallback btTriangleRaycastCallback3(btVector3 const& from_0, btVector3 const& to_1, uint flags_2);
public pure function extern "::btTriangleShape" "nocdecl" btTriangleShape btTriangleShape3(btVector3 const& p0_0, btVector3 const& p1_1, btVector3 const& p2_2);
public pure function extern "::btTriple" btScalar btTriple(btVector3 const& v1_0, btVector3 const& v2_1, btVector3 const& v3_2);
public pure function extern "::btTypedConstraint" "nocdecl" btTypedConstraint btTypedConstraint2(btTypedConstraintType type_0, btRigidBody mutable& rbA_1);
public pure function extern "::btTypedConstraint" "nocdecl" btTypedConstraint btTypedConstraint3(btTypedConstraintType type_0, btRigidBody mutable& rbA_1, btRigidBody mutable& rbB_2);
public pure function extern "::btTypedConstraint::getFixedBody" "nocdecl" btRigidBody mutable& btTypedConstraint_getFixedBody();
public pure function extern "::btTypedObject" "nocdecl" btTypedObject btTypedObject1(int objectType_0);
public pure function extern "::btUnSwapVector3Endian" void btUnSwapVector3Endian(btVector3 mutable& vector_0);
public pure function extern "::btUniformScalingShape" "nocdecl" btUniformScalingShape btUniformScalingShape2(rptr{btConvexShape} convexChildShape_0, btScalar uniformScalingFactor_1);
public pure function extern "::btUniversalConstraint" "nocdecl" btUniversalConstraint btUniversalConstraint5(btRigidBody mutable& rbA_0, btRigidBody mutable& rbB_1, btVector3 const& anchor_2, btVector3 const& axis1_3, btVector3 const& axis2_4);
public pure function extern "::btUnswapEndianDouble" double btUnswapEndianDouble(crptr{uchar} src_0);
public pure function extern "::btUnswapEndianFloat" float btUnswapEndianFloat(uint a_0);
public pure function extern "::btVector3" "nocdecl" btVector3 btVector3_3(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2);
public pure function extern "::btVector4" "nocdecl" btVector4 btVector4_4(btScalar const& _x_0, btScalar const& _y_1, btScalar const& _z_2, btScalar const& _w_3);
public pure function extern "::btWheelInfo" "nocdecl" btWheelInfo btWheelInfo1(btWheelInfoConstructionInfo mutable& ci_0);
private metafunction btDbvt_ICollide_Process__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process1"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process_btDbvtNode_cp_btDbvtNode_cp"}},
    match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt_ICollide, "Process_btDbvtNode_cp_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvt_ICollide_Process__rt{tis}
btDbvt_ICollide_Process(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{btDbvtNode},0}}}) {
    return a0.Process1(a1);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return a0.Process_btDbvtNode_cp_btDbvtNode_cp(a1,a2);
  } else if (match_args{tis, {1,{crptr{btDbvtNode},0},{btScalar,0}}}) {
    return a0.Process_btDbvtNode_cp_btScalar(a1,a2);
  }
}
private metafunction btAlignedAllocator_btActionInterface_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btActionInterface_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btActionInterface_p_16, "address_btAlignedAllocator_btActionInterface_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btActionInterface_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btActionInterface_p_16, "address_btAlignedAllocator_btActionInterface_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btActionInterface_p_16_address__rt{tis}
btAlignedAllocator_btActionInterface_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btActionInterface_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btActionInterface_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btActionInterface_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btActionInterface_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btBroadphaseInterface_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btBroadphaseInterface_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btBroadphaseInterface_p_16, "address_btAlignedAllocator_btBroadphaseInterface_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btBroadphaseInterface_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btBroadphaseInterface_p_16, "address_btAlignedAllocator_btBroadphaseInterface_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btBroadphaseInterface_p_16_address__rt{tis}
btAlignedAllocator_btBroadphaseInterface_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btBroadphaseInterface_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btBroadphaseInterface_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btBroadphaseInterface_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btBroadphaseInterface_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btBroadphasePair_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btBroadphasePair_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btBroadphasePair_16, "address_btAlignedAllocator_btBroadphasePair_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btBroadphasePair_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btBroadphasePair_16, "address_btAlignedAllocator_btBroadphasePair_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btBroadphasePair_16_address__rt{tis}
btAlignedAllocator_btBroadphasePair_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btBroadphasePair_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btBroadphasePair_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btBroadphasePair_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btBroadphasePair_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btBvhSubtreeInfo_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btBvhSubtreeInfo_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btBvhSubtreeInfo_16, "address_btAlignedAllocator_btBvhSubtreeInfo_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btBvhSubtreeInfo_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btBvhSubtreeInfo_16, "address_btAlignedAllocator_btBvhSubtreeInfo_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btBvhSubtreeInfo_16_address__rt{tis}
btAlignedAllocator_btBvhSubtreeInfo_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btBvhSubtreeInfo_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btBvhSubtreeInfo_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btBvhSubtreeInfo_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btBvhSubtreeInfo_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btChunk_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btChunk_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btChunk_p_16, "address_btAlignedAllocator_btChunk_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btChunk_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btChunk_p_16, "address_btAlignedAllocator_btChunk_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btChunk_p_16_address__rt{tis}
btAlignedAllocator_btChunk_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btChunk_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btChunk_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btChunk_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btChunk_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCollisionAlgorithm_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionAlgorithm_p_16, "address_btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCollisionAlgorithm_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionAlgorithm_p_16, "address_btAlignedAllocator_btCollisionAlgorithm_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCollisionAlgorithm_p_16_address__rt{tis}
btAlignedAllocator_btCollisionAlgorithm_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionAlgorithm_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCollisionAlgorithm_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionAlgorithm_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCollisionObjectDoubleData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionObjectDoubleData_p_16, "address_btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionObjectDoubleData_p_16, "address_btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCollisionObjectDoubleData_p_16_address__rt{tis}
btAlignedAllocator_btCollisionObjectDoubleData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionObjectDoubleData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionObjectDoubleData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCollisionObjectFloatData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionObjectFloatData_p_16, "address_btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCollisionObjectFloatData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionObjectFloatData_p_16, "address_btAlignedAllocator_btCollisionObjectFloatData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCollisionObjectFloatData_p_16_address__rt{tis}
btAlignedAllocator_btCollisionObjectFloatData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionObjectFloatData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCollisionObjectFloatData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionObjectFloatData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCollisionObject_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCollisionObject_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionObject_p_16, "address_btAlignedAllocator_btCollisionObject_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCollisionObject_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionObject_p_16, "address_btAlignedAllocator_btCollisionObject_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCollisionObject_p_16_address__rt{tis}
btAlignedAllocator_btCollisionObject_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCollisionObject_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionObject_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCollisionObject_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionObject_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCollisionShapeData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCollisionShapeData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionShapeData_p_16, "address_btAlignedAllocator_btCollisionShapeData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCollisionShapeData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionShapeData_p_16, "address_btAlignedAllocator_btCollisionShapeData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCollisionShapeData_p_16_address__rt{tis}
btAlignedAllocator_btCollisionShapeData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCollisionShapeData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionShapeData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCollisionShapeData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionShapeData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCollisionShape_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCollisionShape_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionShape_p_16, "address_btAlignedAllocator_btCollisionShape_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCollisionShape_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCollisionShape_p_16, "address_btAlignedAllocator_btCollisionShape_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCollisionShape_p_16_address__rt{tis}
btAlignedAllocator_btCollisionShape_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCollisionShape_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionShape_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCollisionShape_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCollisionShape_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btCompoundShapeChild_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btCompoundShapeChild_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCompoundShapeChild_16, "address_btAlignedAllocator_btCompoundShapeChild_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btCompoundShapeChild_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btCompoundShapeChild_16, "address_btAlignedAllocator_btCompoundShapeChild_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btCompoundShapeChild_16_address__rt{tis}
btAlignedAllocator_btCompoundShapeChild_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btCompoundShapeChild_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCompoundShapeChild_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btCompoundShapeChild_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btCompoundShapeChild_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btConvexHullComputer_Edge_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btConvexHullComputer_Edge_16, "address_btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btConvexHullComputer_Edge_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btConvexHullComputer_Edge_16, "address_btAlignedAllocator_btConvexHullComputer_Edge_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btConvexHullComputer_Edge_16_address__rt{tis}
btAlignedAllocator_btConvexHullComputer_Edge_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btConvexHullComputer_Edge_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btConvexHullComputer_Edge_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btConvexHullComputer_Edge_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btDbvt_sStkNN_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNN_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDbvt_sStkNN_16, "address_btAlignedAllocator_btDbvt_sStkNN_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNN_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDbvt_sStkNN_16, "address_btAlignedAllocator_btDbvt_sStkNN_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btDbvt_sStkNN_16_address__rt{tis}
btAlignedAllocator_btDbvt_sStkNN_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNN_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDbvt_sStkNN_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNN_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDbvt_sStkNN_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btDbvt_sStkNPS_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNPS_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDbvt_sStkNPS_16, "address_btAlignedAllocator_btDbvt_sStkNPS_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNPS_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDbvt_sStkNPS_16, "address_btAlignedAllocator_btDbvt_sStkNPS_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btDbvt_sStkNPS_16_address__rt{tis}
btAlignedAllocator_btDbvt_sStkNPS_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNPS_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDbvt_sStkNPS_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNPS_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDbvt_sStkNPS_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btDbvt_sStkNP_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNP_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDbvt_sStkNP_16, "address_btAlignedAllocator_btDbvt_sStkNP_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNP_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDbvt_sStkNP_16, "address_btAlignedAllocator_btDbvt_sStkNP_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btDbvt_sStkNP_16_address__rt{tis}
btAlignedAllocator_btDbvt_sStkNP_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNP_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDbvt_sStkNP_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btDbvt_sStkNP_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDbvt_sStkNP_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btDynamicsWorldDoubleData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDynamicsWorldDoubleData_p_16, "address_btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDynamicsWorldDoubleData_p_16, "address_btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btDynamicsWorldDoubleData_p_16_address__rt{tis}
btAlignedAllocator_btDynamicsWorldDoubleData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDynamicsWorldDoubleData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDynamicsWorldDoubleData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btDynamicsWorldFloatData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDynamicsWorldFloatData_p_16, "address_btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btDynamicsWorldFloatData_p_16, "address_btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btDynamicsWorldFloatData_p_16_address__rt{tis}
btAlignedAllocator_btDynamicsWorldFloatData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDynamicsWorldFloatData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btDynamicsWorldFloatData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btElement_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btElement_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btElement_16, "address_btAlignedAllocator_btElement_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btElement_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btElement_16, "address_btAlignedAllocator_btElement_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btElement_16_address__rt{tis}
btAlignedAllocator_btElement_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btElement_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btElement_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btElement_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btElement_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btFace_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btFace_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btFace_16, "address_btAlignedAllocator_btFace_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btFace_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btFace_16, "address_btAlignedAllocator_btFace_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btFace_16_address__rt{tis}
btAlignedAllocator_btFace_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btFace_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btFace_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btFace_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btFace_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btHashInt_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btHashInt_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btHashInt_16, "address_btAlignedAllocator_btHashInt_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btHashInt_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btHashInt_16, "address_btAlignedAllocator_btHashInt_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btHashInt_16_address__rt{tis}
btAlignedAllocator_btHashInt_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btHashInt_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btHashInt_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btHashInt_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btHashInt_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btHashPtr_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btHashPtr_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btHashPtr_16, "address_btAlignedAllocator_btHashPtr_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btHashPtr_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btHashPtr_16, "address_btAlignedAllocator_btHashPtr_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btHashPtr_16_address__rt{tis}
btAlignedAllocator_btHashPtr_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btHashPtr_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btHashPtr_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btHashPtr_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btHashPtr_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btHashString_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btHashString_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btHashString_16, "address_btAlignedAllocator_btHashString_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btHashString_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btHashString_16, "address_btAlignedAllocator_btHashString_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btHashString_16_address__rt{tis}
btAlignedAllocator_btHashString_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btHashString_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btHashString_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btHashString_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btHashString_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btIndexedMesh_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btIndexedMesh_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btIndexedMesh_16, "address_btAlignedAllocator_btIndexedMesh_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btIndexedMesh_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btIndexedMesh_16, "address_btAlignedAllocator_btIndexedMesh_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btIndexedMesh_16_address__rt{tis}
btAlignedAllocator_btIndexedMesh_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btIndexedMesh_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btIndexedMesh_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btIndexedMesh_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btIndexedMesh_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btMaterialProperties_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btMaterialProperties_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMaterialProperties_16, "address_btAlignedAllocator_btMaterialProperties_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btMaterialProperties_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMaterialProperties_16, "address_btAlignedAllocator_btMaterialProperties_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btMaterialProperties_16_address__rt{tis}
btAlignedAllocator_btMaterialProperties_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btMaterialProperties_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMaterialProperties_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btMaterialProperties_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMaterialProperties_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btMaterial_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btMaterial_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMaterial_p_16, "address_btAlignedAllocator_btMaterial_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btMaterial_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMaterial_p_16, "address_btAlignedAllocator_btMaterial_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btMaterial_p_16_address__rt{tis}
btAlignedAllocator_btMaterial_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btMaterial_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMaterial_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btMaterial_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMaterial_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16, "address_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16, "address_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_address__rt{tis}
btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMultiSapBroadphase_btBridgeProxy_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16, "address_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16, "address_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_address__rt{tis}
btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btMultiSapBroadphase_btMultiSapProxy_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btOptimizedBvhNode_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btOptimizedBvhNode_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btOptimizedBvhNode_16, "address_btAlignedAllocator_btOptimizedBvhNode_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btOptimizedBvhNode_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btOptimizedBvhNode_16, "address_btAlignedAllocator_btOptimizedBvhNode_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btOptimizedBvhNode_16_address__rt{tis}
btAlignedAllocator_btOptimizedBvhNode_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btOptimizedBvhNode_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btOptimizedBvhNode_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btOptimizedBvhNode_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btOptimizedBvhNode_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btOptimizedBvh_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btOptimizedBvh_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btOptimizedBvh_p_16, "address_btAlignedAllocator_btOptimizedBvh_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btOptimizedBvh_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btOptimizedBvh_p_16, "address_btAlignedAllocator_btOptimizedBvh_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btOptimizedBvh_p_16_address__rt{tis}
btAlignedAllocator_btOptimizedBvh_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btOptimizedBvh_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btOptimizedBvh_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btOptimizedBvh_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btOptimizedBvh_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btPersistentManifold_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btPersistentManifold_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btPersistentManifold_p_16, "address_btAlignedAllocator_btPersistentManifold_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btPersistentManifold_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btPersistentManifold_p_16, "address_btAlignedAllocator_btPersistentManifold_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btPersistentManifold_p_16_address__rt{tis}
btAlignedAllocator_btPersistentManifold_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btPersistentManifold_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btPersistentManifold_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btPersistentManifold_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btPersistentManifold_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btPointerUid_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btPointerUid_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btPointerUid_16, "address_btAlignedAllocator_btPointerUid_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btPointerUid_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btPointerUid_16, "address_btAlignedAllocator_btPointerUid_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btPointerUid_16_address__rt{tis}
btAlignedAllocator_btPointerUid_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btPointerUid_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btPointerUid_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btPointerUid_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btPointerUid_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btQuantizedBvhDoubleData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btQuantizedBvhDoubleData_p_16, "address_btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btQuantizedBvhDoubleData_p_16, "address_btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btQuantizedBvhDoubleData_p_16_address__rt{tis}
btAlignedAllocator_btQuantizedBvhDoubleData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btQuantizedBvhDoubleData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btQuantizedBvhDoubleData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btQuantizedBvhFloatData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btQuantizedBvhFloatData_p_16, "address_btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btQuantizedBvhFloatData_p_16, "address_btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btQuantizedBvhFloatData_p_16_address__rt{tis}
btAlignedAllocator_btQuantizedBvhFloatData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btQuantizedBvhFloatData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btQuantizedBvhFloatData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btQuantizedBvhNode_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhNode_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btQuantizedBvhNode_16, "address_btAlignedAllocator_btQuantizedBvhNode_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhNode_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btQuantizedBvhNode_16, "address_btAlignedAllocator_btQuantizedBvhNode_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btQuantizedBvhNode_16_address__rt{tis}
btAlignedAllocator_btQuantizedBvhNode_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhNode_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btQuantizedBvhNode_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btQuantizedBvhNode_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btQuantizedBvhNode_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btRigidBodyDoubleData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btRigidBodyDoubleData_p_16, "address_btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btRigidBodyDoubleData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btRigidBodyDoubleData_p_16, "address_btAlignedAllocator_btRigidBodyDoubleData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btRigidBodyDoubleData_p_16_address__rt{tis}
btAlignedAllocator_btRigidBodyDoubleData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btRigidBodyDoubleData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btRigidBodyDoubleData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btRigidBodyDoubleData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btRigidBodyFloatData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btRigidBodyFloatData_p_16, "address_btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btRigidBodyFloatData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btRigidBodyFloatData_p_16, "address_btAlignedAllocator_btRigidBodyFloatData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btRigidBodyFloatData_p_16_address__rt{tis}
btAlignedAllocator_btRigidBodyFloatData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btRigidBodyFloatData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btRigidBodyFloatData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btRigidBodyFloatData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btRigidBody_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btRigidBody_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btRigidBody_p_16, "address_btAlignedAllocator_btRigidBody_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btRigidBody_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btRigidBody_p_16, "address_btAlignedAllocator_btRigidBody_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btRigidBody_p_16_address__rt{tis}
btAlignedAllocator_btRigidBody_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btRigidBody_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btRigidBody_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btRigidBody_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btRigidBody_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btSimplePair_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btSimplePair_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btSimplePair_16, "address_btAlignedAllocator_btSimplePair_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btSimplePair_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btSimplePair_16, "address_btAlignedAllocator_btSimplePair_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btSimplePair_16_address__rt{tis}
btAlignedAllocator_btSimplePair_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btSimplePair_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btSimplePair_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btSimplePair_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btSimplePair_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btSolverBody_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btSolverBody_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btSolverBody_16, "address_btAlignedAllocator_btSolverBody_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btSolverBody_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btSolverBody_16, "address_btAlignedAllocator_btSolverBody_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btSolverBody_16_address__rt{tis}
btAlignedAllocator_btSolverBody_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btSolverBody_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btSolverBody_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btSolverBody_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btSolverBody_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btSolverConstraint_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btSolverConstraint_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btSolverConstraint_16, "address_btAlignedAllocator_btSolverConstraint_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btSolverConstraint_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btSolverConstraint_16, "address_btAlignedAllocator_btSolverConstraint_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btSolverConstraint_16_address__rt{tis}
btAlignedAllocator_btSolverConstraint_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btSolverConstraint_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btSolverConstraint_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btSolverConstraint_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btSolverConstraint_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btStridingMeshInterfaceData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btStridingMeshInterfaceData_p_16, "address_btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btStridingMeshInterfaceData_p_16, "address_btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btStridingMeshInterfaceData_p_16_address__rt{tis}
btAlignedAllocator_btStridingMeshInterfaceData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btStridingMeshInterfaceData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btStridingMeshInterfaceData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTriangleIndexVertexArray_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTriangleIndexVertexArray_p_16, "address_btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTriangleIndexVertexArray_p_16, "address_btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTriangleIndexVertexArray_p_16_address__rt{tis}
btAlignedAllocator_btTriangleIndexVertexArray_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTriangleIndexVertexArray_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTriangleIndexVertexArray_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTriangleInfo_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTriangleInfo_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTriangleInfo_16, "address_btAlignedAllocator_btTriangleInfo_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTriangleInfo_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTriangleInfo_16, "address_btAlignedAllocator_btTriangleInfo_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTriangleInfo_16_address__rt{tis}
btAlignedAllocator_btTriangleInfo_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTriangleInfo_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTriangleInfo_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTriangleInfo_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTriangleInfo_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTriangle_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTriangle_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTriangle_16, "address_btAlignedAllocator_btTriangle_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTriangle_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTriangle_16, "address_btAlignedAllocator_btTriangle_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTriangle_16_address__rt{tis}
btAlignedAllocator_btTriangle_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTriangle_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTriangle_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTriangle_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTriangle_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTypedConstraintData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraintData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraintData_p_16, "address_btAlignedAllocator_btTypedConstraintData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraintData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraintData_p_16, "address_btAlignedAllocator_btTypedConstraintData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTypedConstraintData_p_16_address__rt{tis}
btAlignedAllocator_btTypedConstraintData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraintData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraintData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraintData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraintData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTypedConstraintDoubleData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraintDoubleData_p_16, "address_btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraintDoubleData_p_16, "address_btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTypedConstraintDoubleData_p_16_address__rt{tis}
btAlignedAllocator_btTypedConstraintDoubleData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraintDoubleData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraintDoubleData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTypedConstraintFloatData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraintFloatData_p_16, "address_btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraintFloatData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraintFloatData_p_16, "address_btAlignedAllocator_btTypedConstraintFloatData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTypedConstraintFloatData_p_16_address__rt{tis}
btAlignedAllocator_btTypedConstraintFloatData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraintFloatData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraintFloatData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraintFloatData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16, "address_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16, "address_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_address__rt{tis}
btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraint_btConstraintInfo1_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btTypedConstraint_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraint_p_16, "address_btAlignedAllocator_btTypedConstraint_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btTypedConstraint_p_16, "address_btAlignedAllocator_btTypedConstraint_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btTypedConstraint_p_16_address__rt{tis}
btAlignedAllocator_btTypedConstraint_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraint_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btTypedConstraint_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btTypedConstraint_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btVector3DoubleData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btVector3DoubleData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btVector3DoubleData_p_16, "address_btAlignedAllocator_btVector3DoubleData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btVector3DoubleData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btVector3DoubleData_p_16, "address_btAlignedAllocator_btVector3DoubleData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btVector3DoubleData_p_16_address__rt{tis}
btAlignedAllocator_btVector3DoubleData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btVector3DoubleData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btVector3DoubleData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btVector3DoubleData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btVector3DoubleData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btVector3FloatData_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btVector3FloatData_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btVector3FloatData_p_16, "address_btAlignedAllocator_btVector3FloatData_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btVector3FloatData_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btVector3FloatData_p_16, "address_btAlignedAllocator_btVector3FloatData_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btVector3FloatData_p_16_address__rt{tis}
btAlignedAllocator_btVector3FloatData_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btVector3FloatData_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btVector3FloatData_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btVector3FloatData_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btVector3FloatData_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btVector3_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btVector3_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btVector3_16, "address_btAlignedAllocator_btVector3_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btVector3_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btVector3_16, "address_btAlignedAllocator_btVector3_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btVector3_16_address__rt{tis}
btAlignedAllocator_btVector3_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btVector3_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btVector3_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btVector3_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btVector3_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_btWheelInfo_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_btWheelInfo_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btWheelInfo_16, "address_btAlignedAllocator_btWheelInfo_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_btWheelInfo_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_btWheelInfo_16, "address_btAlignedAllocator_btWheelInfo_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_btWheelInfo_16_address__rt{tis}
btAlignedAllocator_btWheelInfo_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_btWheelInfo_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_btWheelInfo_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_btWheelInfo_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_btWheelInfo_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_char_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_char_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_char_p_16, "address_btAlignedAllocator_char_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_char_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_char_p_16, "address_btAlignedAllocator_char_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_char_p_16_address__rt{tis}
btAlignedAllocator_char_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_char_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_char_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_char_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_char_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_const_btCollisionObject_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_const_btCollisionObject_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_const_btCollisionObject_p_16, "address_btAlignedAllocator_const_btCollisionObject_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_const_btCollisionObject_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_const_btCollisionObject_p_16, "address_btAlignedAllocator_const_btCollisionObject_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_const_btCollisionObject_p_16_address__rt{tis}
btAlignedAllocator_const_btCollisionObject_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_const_btCollisionObject_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_const_btCollisionObject_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_const_btCollisionObject_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_const_btCollisionObject_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_const_btDbvtNode_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_const_btDbvtNode_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_const_btDbvtNode_p_16, "address_btAlignedAllocator_const_btDbvtNode_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_const_btDbvtNode_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_const_btDbvtNode_p_16, "address_btAlignedAllocator_const_btDbvtNode_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_const_btDbvtNode_p_16_address__rt{tis}
btAlignedAllocator_const_btDbvtNode_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_const_btDbvtNode_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_const_btDbvtNode_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_const_btDbvtNode_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_const_btDbvtNode_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_const_char_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_const_char_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_const_char_p_16, "address_btAlignedAllocator_const_char_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_const_char_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_const_char_p_16, "address_btAlignedAllocator_const_char_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_const_char_p_16_address__rt{tis}
btAlignedAllocator_const_char_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_const_char_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_const_char_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_const_char_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_const_char_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_double_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_double_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_double_16, "address_btAlignedAllocator_double_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_double_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_double_16, "address_btAlignedAllocator_double_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_double_16_address__rt{tis}
btAlignedAllocator_double_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_double_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_double_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_double_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_double_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_float_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_float_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_float_16, "address_btAlignedAllocator_float_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_float_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_float_16, "address_btAlignedAllocator_float_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_float_16_address__rt{tis}
btAlignedAllocator_float_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_float_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_float_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_float_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_float_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_int_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_int_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_int_16, "address_btAlignedAllocator_int_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_int_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_int_16, "address_btAlignedAllocator_int_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_int_16_address__rt{tis}
btAlignedAllocator_int_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_int_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_int_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_int_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_int_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_int_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_int_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_int_p_16, "address_btAlignedAllocator_int_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_int_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_int_p_16, "address_btAlignedAllocator_int_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_int_p_16_address__rt{tis}
btAlignedAllocator_int_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_int_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_int_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_int_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_int_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_short_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_short_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_short_16, "address_btAlignedAllocator_short_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_short_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_short_16, "address_btAlignedAllocator_short_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_short_16_address__rt{tis}
btAlignedAllocator_short_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_short_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_short_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_short_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_short_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_short_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_short_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_short_p_16, "address_btAlignedAllocator_short_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_short_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_short_p_16, "address_btAlignedAllocator_short_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_short_p_16_address__rt{tis}
btAlignedAllocator_short_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_short_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_short_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_short_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_short_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_unsigned_char_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_unsigned_char_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_unsigned_char_p_16, "address_btAlignedAllocator_unsigned_char_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_unsigned_char_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_unsigned_char_p_16, "address_btAlignedAllocator_unsigned_char_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_unsigned_char_p_16_address__rt{tis}
btAlignedAllocator_unsigned_char_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_unsigned_char_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_unsigned_char_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_unsigned_char_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_unsigned_char_p_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_unsigned_int_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_unsigned_int_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_unsigned_int_16, "address_btAlignedAllocator_unsigned_int_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_unsigned_int_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_unsigned_int_16, "address_btAlignedAllocator_unsigned_int_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_unsigned_int_16_address__rt{tis}
btAlignedAllocator_unsigned_int_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_unsigned_int_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_unsigned_int_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_unsigned_int_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_unsigned_int_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_unsigned_short_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_unsigned_short_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_unsigned_short_16, "address_btAlignedAllocator_unsigned_short_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_unsigned_short_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_unsigned_short_16, "address_btAlignedAllocator_unsigned_short_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_unsigned_short_16_address__rt{tis}
btAlignedAllocator_unsigned_short_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_unsigned_short_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_unsigned_short_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_unsigned_short_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_unsigned_short_16_reference(a1);
  }
}
private metafunction btAlignedAllocator_void_p_16_address__rt{tis}
  m::cond{
    match_args{tis, {0,{btAlignedAllocator_void_p_16_const_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_void_p_16, "address_btAlignedAllocator_void_p_16_const_reference"}},
    match_args{tis, {0,{btAlignedAllocator_void_p_16_reference,0}}},
    m::ret_type{m::symbol{btAlignedAllocator_void_p_16, "address_btAlignedAllocator_void_p_16_reference"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedAllocator_void_p_16_address__rt{tis}
btAlignedAllocator_void_p_16_address(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btAlignedAllocator_void_p_16_const_reference,0}}}) {
    return a0.address_btAlignedAllocator_void_p_16_const_reference(a1);
  } else if (match_args{tis, {0,{btAlignedAllocator_void_p_16_reference,0}}}) {
    return a0.address_btAlignedAllocator_void_p_16_reference(a1);
  }
}
private metafunction btAlignedObjectArray_btActionInterface_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btActionInterface_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btActionInterface_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btActionInterface_p_at__rt{tis}
btAlignedObjectArray_btActionInterface_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBroadphaseInterface_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphaseInterface_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphaseInterface_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btBroadphaseInterface_p_at__rt{tis}
btAlignedObjectArray_btBroadphaseInterface_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBroadphasePair_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphasePair, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBroadphasePair, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btBroadphasePair_at__rt{tis}
btAlignedObjectArray_btBroadphasePair_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btBvhSubtreeInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBvhSubtreeInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btBvhSubtreeInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btBvhSubtreeInfo_at__rt{tis}
btAlignedObjectArray_btBvhSubtreeInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btChunk_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btChunk_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btChunk_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btChunk_p_at__rt{tis}
btAlignedObjectArray_btChunk_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionAlgorithm_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionAlgorithm_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionAlgorithm_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCollisionAlgorithm_p_at__rt{tis}
btAlignedObjectArray_btCollisionAlgorithm_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObjectDoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObjectDoubleData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObjectDoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCollisionObjectDoubleData_p_at__rt{tis}
btAlignedObjectArray_btCollisionObjectDoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObjectFloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObjectFloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObjectFloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCollisionObjectFloatData_p_at__rt{tis}
btAlignedObjectArray_btCollisionObjectFloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionObject_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionObject_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCollisionObject_p_at__rt{tis}
btAlignedObjectArray_btCollisionObject_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionShapeData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionShapeData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionShapeData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCollisionShapeData_p_at__rt{tis}
btAlignedObjectArray_btCollisionShapeData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCollisionShape_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionShape_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCollisionShape_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCollisionShape_p_at__rt{tis}
btAlignedObjectArray_btCollisionShape_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btCompoundShapeChild_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCompoundShapeChild, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btCompoundShapeChild, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btCompoundShapeChild_at__rt{tis}
btAlignedObjectArray_btCompoundShapeChild_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btConvexHullComputer_Edge_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btConvexHullComputer_Edge, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btConvexHullComputer_Edge, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btConvexHullComputer_Edge_at__rt{tis}
btAlignedObjectArray_btConvexHullComputer_Edge_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNN_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNN, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNN, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btDbvt_sStkNN_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNN_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNP_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNP, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNP, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btDbvt_sStkNP_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNP_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDbvt_sStkNPS_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNPS, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDbvt_sStkNPS, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btDbvt_sStkNPS_at__rt{tis}
btAlignedObjectArray_btDbvt_sStkNPS_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDynamicsWorldDoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDynamicsWorldDoubleData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDynamicsWorldDoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btDynamicsWorldDoubleData_p_at__rt{tis}
btAlignedObjectArray_btDynamicsWorldDoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btDynamicsWorldFloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDynamicsWorldFloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btDynamicsWorldFloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btDynamicsWorldFloatData_p_at__rt{tis}
btAlignedObjectArray_btDynamicsWorldFloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btElement_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btElement, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btElement, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btElement_at__rt{tis}
btAlignedObjectArray_btElement_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btFace_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btFace, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btFace, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btFace_at__rt{tis}
btAlignedObjectArray_btFace_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashInt_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashInt, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashInt, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btHashInt_at__rt{tis}
btAlignedObjectArray_btHashInt_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashPtr_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashPtr, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashPtr, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btHashPtr_at__rt{tis}
btAlignedObjectArray_btHashPtr_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btHashString_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashString, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btHashString, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btHashString_at__rt{tis}
btAlignedObjectArray_btHashString_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btIndexedMesh_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btIndexedMesh, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btIndexedMesh, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btIndexedMesh_at__rt{tis}
btAlignedObjectArray_btIndexedMesh_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMaterialProperties_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterialProperties, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterialProperties, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btMaterialProperties_at__rt{tis}
btAlignedObjectArray_btMaterialProperties_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMaterial_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterial_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMaterial_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btMaterial_p_at__rt{tis}
btAlignedObjectArray_btMaterial_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at__rt{tis}
btAlignedObjectArray_btMultiSapBroadphase_btBridgeProxy_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at__rt{tis}
btAlignedObjectArray_btMultiSapBroadphase_btMultiSapProxy_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btOptimizedBvhNode_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvhNode, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvhNode, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btOptimizedBvhNode_at__rt{tis}
btAlignedObjectArray_btOptimizedBvhNode_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btOptimizedBvh_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvh_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btOptimizedBvh_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btOptimizedBvh_p_at__rt{tis}
btAlignedObjectArray_btOptimizedBvh_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btPersistentManifold_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPersistentManifold_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPersistentManifold_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btPersistentManifold_p_at__rt{tis}
btAlignedObjectArray_btPersistentManifold_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btPointerUid_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPointerUid, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btPointerUid, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btPointerUid_at__rt{tis}
btAlignedObjectArray_btPointerUid_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btQuantizedBvhDoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhDoubleData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhDoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btQuantizedBvhDoubleData_p_at__rt{tis}
btAlignedObjectArray_btQuantizedBvhDoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btQuantizedBvhFloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhFloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhFloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btQuantizedBvhFloatData_p_at__rt{tis}
btAlignedObjectArray_btQuantizedBvhFloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btQuantizedBvhNode_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhNode, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btQuantizedBvhNode, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btQuantizedBvhNode_at__rt{tis}
btAlignedObjectArray_btQuantizedBvhNode_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btRigidBodyDoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBodyDoubleData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBodyDoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btRigidBodyDoubleData_p_at__rt{tis}
btAlignedObjectArray_btRigidBodyDoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btRigidBodyFloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBodyFloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBodyFloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btRigidBodyFloatData_p_at__rt{tis}
btAlignedObjectArray_btRigidBodyFloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btRigidBody_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBody_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btRigidBody_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btRigidBody_p_at__rt{tis}
btAlignedObjectArray_btRigidBody_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSimplePair_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSimplePair, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSimplePair, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btSimplePair_at__rt{tis}
btAlignedObjectArray_btSimplePair_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSolverBody_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverBody, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverBody, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btSolverBody_at__rt{tis}
btAlignedObjectArray_btSolverBody_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btSolverConstraint_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverConstraint, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btSolverConstraint, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btSolverConstraint_at__rt{tis}
btAlignedObjectArray_btSolverConstraint_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btStridingMeshInterfaceData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btStridingMeshInterfaceData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btStridingMeshInterfaceData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btStridingMeshInterfaceData_p_at__rt{tis}
btAlignedObjectArray_btStridingMeshInterfaceData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangle_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangle, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangle, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTriangle_at__rt{tis}
btAlignedObjectArray_btTriangle_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangleIndexVertexArray_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleIndexVertexArray_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleIndexVertexArray_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTriangleIndexVertexArray_p_at__rt{tis}
btAlignedObjectArray_btTriangleIndexVertexArray_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTriangleInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTriangleInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTriangleInfo_at__rt{tis}
btAlignedObjectArray_btTriangleInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraintData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraintData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraintData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTypedConstraintData_p_at__rt{tis}
btAlignedObjectArray_btTypedConstraintData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraintDoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraintDoubleData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraintDoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTypedConstraintDoubleData_p_at__rt{tis}
btAlignedObjectArray_btTypedConstraintDoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraintFloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraintFloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraintFloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTypedConstraintFloatData_p_at__rt{tis}
btAlignedObjectArray_btTypedConstraintFloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_btConstraintInfo1, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_btConstraintInfo1, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at__rt{tis}
btAlignedObjectArray_btTypedConstraint_btConstraintInfo1_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btTypedConstraint_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btTypedConstraint_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btTypedConstraint_p_at__rt{tis}
btAlignedObjectArray_btTypedConstraint_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btVector3_at__rt{tis}
btAlignedObjectArray_btVector3_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3DoubleData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3DoubleData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3DoubleData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btVector3DoubleData_p_at__rt{tis}
btAlignedObjectArray_btVector3DoubleData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btVector3FloatData_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3FloatData_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btVector3FloatData_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btVector3FloatData_p_at__rt{tis}
btAlignedObjectArray_btVector3FloatData_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_btWheelInfo_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btWheelInfo, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_btWheelInfo, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_btWheelInfo_at__rt{tis}
btAlignedObjectArray_btWheelInfo_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_char_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_char_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_char_p_at__rt{tis}
btAlignedObjectArray_char_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_const_btCollisionObject_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_const_btCollisionObject_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_const_btCollisionObject_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_const_btCollisionObject_p_at__rt{tis}
btAlignedObjectArray_const_btCollisionObject_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_const_btDbvtNode_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_const_btDbvtNode_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_const_btDbvtNode_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_const_btDbvtNode_p_at__rt{tis}
btAlignedObjectArray_const_btDbvtNode_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_const_char_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_const_char_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_const_char_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_const_char_p_at__rt{tis}
btAlignedObjectArray_const_char_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_double_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_double, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_double, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_double_at__rt{tis}
btAlignedObjectArray_double_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_float_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_float, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_float, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_float_at__rt{tis}
btAlignedObjectArray_float_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_int_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_int_at__rt{tis}
btAlignedObjectArray_int_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_int_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_int_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_int_p_at__rt{tis}
btAlignedObjectArray_int_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_short_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_short_at__rt{tis}
btAlignedObjectArray_short_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_short_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_short_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_short_p_at__rt{tis}
btAlignedObjectArray_short_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_char_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_char_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_char_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_unsigned_char_p_at__rt{tis}
btAlignedObjectArray_unsigned_char_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_int_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_int, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_int, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_unsigned_int_at__rt{tis}
btAlignedObjectArray_unsigned_int_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_unsigned_short_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_short, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_unsigned_short, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_unsigned_short_at__rt{tis}
btAlignedObjectArray_unsigned_short_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAlignedObjectArray_void_p_at__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_void_p, "at"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btAlignedObjectArray_void_p, "at"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAlignedObjectArray_void_p_at__rt{tis}
btAlignedObjectArray_void_p_at(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.at(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.at(a1);
  }
}
private metafunction btAxisSweep3Internal_unsigned_int_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_int, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_int, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAxisSweep3Internal_unsigned_int_getOverlappingPairCache__rt{tis}
btAxisSweep3Internal_unsigned_int_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btAxisSweep3Internal_unsigned_short_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_short, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btAxisSweep3Internal_unsigned_short, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAxisSweep3Internal_unsigned_short_getOverlappingPairCache__rt{tis}
btAxisSweep3Internal_unsigned_short_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btBU_Simplex1to4_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBU_Simplex1to4, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBU_Simplex1to4, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBU_Simplex1to4_setSafeMargin__rt{tis}
btBU_Simplex1to4_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btBox2dShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBox2dShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBox2dShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBox2dShape_setSafeMargin__rt{tis}
btBox2dShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btBoxShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBoxShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btBoxShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBoxShape_setSafeMargin__rt{tis}
btBoxShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btBroadphaseInterface_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBroadphaseInterface, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBroadphaseInterface, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBroadphaseInterface_getOverlappingPairCache__rt{tis}
btBroadphaseInterface_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btBvhTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btBvhTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBvhTriangleMeshShape_getMeshInterface__rt{tis}
btBvhTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btCapsuleShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCapsuleShape_setSafeMargin__rt{tis}
btCapsuleShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCapsuleShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeX, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeX, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCapsuleShapeX_setSafeMargin__rt{tis}
btCapsuleShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCapsuleShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeZ, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCapsuleShapeZ, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCapsuleShapeZ_setSafeMargin__rt{tis}
btCapsuleShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCollisionDispatcher_getCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getCollisionConfiguration"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getCollisionConfiguration"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionDispatcher_getCollisionConfiguration__rt{tis}
btCollisionDispatcher_getCollisionConfiguration(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionConfiguration();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionConfiguration();
  }
}
private metafunction btCollisionDispatcher_getInternalManifoldPool__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getInternalManifoldPool"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getInternalManifoldPool"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionDispatcher_getInternalManifoldPool__rt{tis}
btCollisionDispatcher_getInternalManifoldPool(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInternalManifoldPool();
  } else if (match_args{tis, {0}}) {
    return a0.getInternalManifoldPool();
  }
}
private metafunction btCollisionDispatcher_getManifoldByIndexInternal__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getManifoldByIndexInternal"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCollisionDispatcher, "getManifoldByIndexInternal"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionDispatcher_getManifoldByIndexInternal__rt{tis}
btCollisionDispatcher_getManifoldByIndexInternal(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getManifoldByIndexInternal(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getManifoldByIndexInternal(a1);
  }
}
private metafunction btCollisionObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getBroadphaseHandle"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionObject_getBroadphaseHandle__rt{tis}
btCollisionObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btCollisionObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionObject_getCollisionShape__rt{tis}
btCollisionObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btCollisionObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionObject_getInterpolationWorldTransform__rt{tis}
btCollisionObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btCollisionObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionObject, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionObject_getWorldTransform__rt{tis}
btCollisionObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btCollisionWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_getBroadphase__rt{tis}
btCollisionWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btCollisionWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_getDispatchInfo__rt{tis}
btCollisionWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btCollisionWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCollisionWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_getDispatcher__rt{tis}
btCollisionWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btCompoundShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildShape"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCompoundShape_getChildShape__rt{tis}
btCompoundShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildShape(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildShape(a1);
  }
}
private metafunction btCompoundShape_getChildTransform__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildTransform"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btCompoundShape, "getChildTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCompoundShape_getChildTransform__rt{tis}
btCompoundShape_getChildTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getChildTransform(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getChildTransform(a1);
  }
}
private metafunction btCompoundShape_getDynamicAabbTree__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btCompoundShape, "getDynamicAabbTree"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btCompoundShape, "getDynamicAabbTree"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCompoundShape_getDynamicAabbTree__rt{tis}
btCompoundShape_getDynamicAabbTree(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDynamicAabbTree();
  } else if (match_args{tis, {0}}) {
    return a0.getDynamicAabbTree();
  }
}
private metafunction btConeShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeShape_setSafeMargin__rt{tis}
btConeShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeX, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeX, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeShapeX_setSafeMargin__rt{tis}
btConeShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeZ, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeShapeZ, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeShapeZ_setSafeMargin__rt{tis}
btConeShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConeTwistConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeTwistConstraint_getJointFeedback__rt{tis}
btConeTwistConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btConeTwistConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeTwistConstraint_getRigidBodyA__rt{tis}
btConeTwistConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btConeTwistConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConeTwistConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeTwistConstraint_getRigidBodyB__rt{tis}
btConeTwistConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btConeTwistConstraint_setLimit__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeTwistConstraint, "setLimit2"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConeTwistConstraint, "setLimit6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeTwistConstraint_setLimit__rt{tis}
btConeTwistConstraint_setLimit(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setLimit2(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setLimit6(a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btContactConstraint_getContactManifold__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getContactManifold"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getContactManifold"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btContactConstraint_getContactManifold__rt{tis}
btContactConstraint_getContactManifold(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getContactManifold();
  } else if (match_args{tis, {0}}) {
    return a0.getContactManifold();
  }
}
private metafunction btContactConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btContactConstraint_getJointFeedback__rt{tis}
btContactConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btContactConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btContactConstraint_getRigidBodyA__rt{tis}
btContactConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btContactConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btContactConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btContactConstraint_getRigidBodyB__rt{tis}
btContactConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btConvex2dShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvex2dShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvex2dShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvex2dShape_getChildShape__rt{tis}
btConvex2dShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btConvexHullComputer_compute__rt{tis}
  m::cond{
    match_args{tis, {1,{crptr{double},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullComputer, "compute_double_cp_int_int_btScalar_btScalar"}},
    match_args{tis, {1,{crptr{float},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullComputer, "compute_float_cp_int_int_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexHullComputer_compute__rt{tis}
btConvexHullComputer_compute(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{crptr{double},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return a0.compute_double_cp_int_int_btScalar_btScalar(a1,a2,a3,a4,a5);
  } else if (match_args{tis, {1,{crptr{float},0},{int,0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return a0.compute_float_cp_int_int_btScalar_btScalar(a1,a2,a3,a4,a5);
  }
}
private metafunction btConvexHullShape_getUnscaledPoints__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexHullShape, "getUnscaledPoints"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexHullShape, "getUnscaledPoints"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexHullShape_getUnscaledPoints__rt{tis}
btConvexHullShape_getUnscaledPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getUnscaledPoints();
  } else if (match_args{tis, {0}}) {
    return a0.getUnscaledPoints();
  }
}
private metafunction btConvexHullShape_project__rt{tis}
  m::cond{
    match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1}}},
    m::ret_type{m::symbol{btConvexHullShape, "project4"}},
    match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{btConvexHullShape, "project6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexHullShape_project__rt{tis}
btConvexHullShape_project(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1}}}) {
    return a0.project4(a1,a2,a3,a4);
  } else if (match_args{tis, {0,{btTransform,0},{btVector3,0},{btScalar,1},{btScalar,1},{btVector3,1},{btVector3,1}}}) {
    return a0.project6(a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btConvexHullShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexHullShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexHullShape_setSafeMargin__rt{tis}
btConvexHullShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConvexInternalAabbCachingShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalAabbCachingShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalAabbCachingShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexInternalAabbCachingShape_setSafeMargin__rt{tis}
btConvexInternalAabbCachingShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConvexInternalShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexInternalShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexInternalShape_setSafeMargin__rt{tis}
btConvexInternalShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConvexPointCloudShape_getUnscaledPoints__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "getUnscaledPoints"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "getUnscaledPoints"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexPointCloudShape_getUnscaledPoints__rt{tis}
btConvexPointCloudShape_getUnscaledPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getUnscaledPoints();
  } else if (match_args{tis, {0}}) {
    return a0.getUnscaledPoints();
  }
}
private metafunction btConvexPointCloudShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexPointCloudShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexPointCloudShape_setSafeMargin__rt{tis}
btConvexPointCloudShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btConvexTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexTriangleMeshShape_getMeshInterface__rt{tis}
btConvexTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btConvexTriangleMeshShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btConvexTriangleMeshShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexTriangleMeshShape_setSafeMargin__rt{tis}
btConvexTriangleMeshShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCylinderShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCylinderShape_setSafeMargin__rt{tis}
btCylinderShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCylinderShapeX_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeX, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeX, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCylinderShapeX_setSafeMargin__rt{tis}
btCylinderShapeX_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btCylinderShapeZ_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeZ, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btCylinderShapeZ, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCylinderShapeZ_setSafeMargin__rt{tis}
btCylinderShapeZ_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btDbvt_update__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{int,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_int"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume_btScalar"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0}}},
    m::ret_type{m::symbol{btDbvt, "update_btDbvtNode_p_btDbvtVolume_btVector3"}},
    match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btDbvt, "update4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvt_update__rt{tis}
btDbvt_update(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume(a1,a2);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{int,0}}}) {
    return a0.update_btDbvtNode_p_int(a1,a2);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btScalar,0}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume_btScalar(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0}}}) {
    return a0.update_btDbvtNode_p_btDbvtVolume_btVector3(a1,a2,a3);
  } else if (match_args{tis, {1,{rptr{btDbvtNode},0},{btDbvtVolume,1},{btVector3,0},{btScalar,0}}}) {
    return a0.update4(a1,a2,a3,a4);
  }
}
private metafunction btDbvtBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDbvtBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDbvtBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvtBroadphase_getOverlappingPairCache__rt{tis}
btDbvtBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btDiscreteDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "addRigidBody1"}},
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "addRigidBody3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld_addRigidBody__rt{tis}
btDiscreteDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  }
}
private metafunction btDiscreteDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld_getBroadphase__rt{tis}
btDiscreteDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btDiscreteDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getConstraint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld_getConstraint__rt{tis}
btDiscreteDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btDiscreteDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld_getDispatchInfo__rt{tis}
btDiscreteDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btDiscreteDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld_getDispatcher__rt{tis}
btDiscreteDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btDiscreteDynamicsWorld_getSimulationIslandManager__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getSimulationIslandManager"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDiscreteDynamicsWorld, "getSimulationIslandManager"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld_getSimulationIslandManager__rt{tis}
btDiscreteDynamicsWorld_getSimulationIslandManager(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getSimulationIslandManager();
  } else if (match_args{tis, {0}}) {
    return a0.getSimulationIslandManager();
  }
}
private metafunction btDispatcher_getInternalManifoldPool__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDispatcher, "getInternalManifoldPool"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDispatcher, "getInternalManifoldPool"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDispatcher_getInternalManifoldPool__rt{tis}
btDispatcher_getInternalManifoldPool(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInternalManifoldPool();
  } else if (match_args{tis, {0}}) {
    return a0.getInternalManifoldPool();
  }
}
private metafunction btDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "addRigidBody1"}},
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "addRigidBody3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDynamicsWorld_addRigidBody__rt{tis}
btDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  }
}
private metafunction btDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDynamicsWorld_getBroadphase__rt{tis}
btDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "getConstraint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDynamicsWorld_getConstraint__rt{tis}
btDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDynamicsWorld_getDispatchInfo__rt{tis}
btDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDynamicsWorld_getDispatcher__rt{tis}
btDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btGearConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGearConstraint_getJointFeedback__rt{tis}
btGearConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGearConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGearConstraint_getRigidBodyA__rt{tis}
btGearConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGearConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGearConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGearConstraint_getRigidBodyB__rt{tis}
btGearConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "calculateTransforms0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "calculateTransforms2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint_calculateTransforms__rt{tis}
btGeneric6DofConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  }
}
private metafunction btGeneric6DofConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint_getFrameOffsetA__rt{tis}
btGeneric6DofConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btGeneric6DofConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint_getFrameOffsetB__rt{tis}
btGeneric6DofConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btGeneric6DofConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint_getJointFeedback__rt{tis}
btGeneric6DofConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGeneric6DofConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint_getRigidBodyA__rt{tis}
btGeneric6DofConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint_getRigidBodyB__rt{tis}
btGeneric6DofConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofSpringConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "calculateTransforms0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "calculateTransforms2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_calculateTransforms__rt{tis}
btGeneric6DofSpringConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  }
}
private metafunction btGeneric6DofSpringConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_getFrameOffsetA__rt{tis}
btGeneric6DofSpringConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btGeneric6DofSpringConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_getFrameOffsetB__rt{tis}
btGeneric6DofSpringConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btGeneric6DofSpringConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_getJointFeedback__rt{tis}
btGeneric6DofSpringConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btGeneric6DofSpringConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_getRigidBodyA__rt{tis}
btGeneric6DofSpringConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btGeneric6DofSpringConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_getRigidBodyB__rt{tis}
btGeneric6DofSpringConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btGeneric6DofSpringConstraint_setEquilibriumPoint__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint0"}},
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint1"}},
    match_args{tis, {1,{int,0},{btScalar,0}}},
    m::ret_type{m::symbol{btGeneric6DofSpringConstraint, "setEquilibriumPoint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint_setEquilibriumPoint__rt{tis}
btGeneric6DofSpringConstraint_setEquilibriumPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.setEquilibriumPoint0();
  } else if (match_args{tis, {1,{int,0}}}) {
    return a0.setEquilibriumPoint1(a1);
  } else if (match_args{tis, {1,{int,0},{btScalar,0}}}) {
    return a0.setEquilibriumPoint2(a1,a2);
  }
}
private metafunction btGhostObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getBroadphaseHandle"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGhostObject_getBroadphaseHandle__rt{tis}
btGhostObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btGhostObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGhostObject_getCollisionShape__rt{tis}
btGhostObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btGhostObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGhostObject_getInterpolationWorldTransform__rt{tis}
btGhostObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btGhostObject_getOverlappingObject__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btGhostObject, "getOverlappingObject"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btGhostObject, "getOverlappingObject"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGhostObject_getOverlappingObject__rt{tis}
btGhostObject_getOverlappingObject(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  }
}
private metafunction btGhostObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btGhostObject, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btGhostObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGhostObject_getWorldTransform__rt{tis}
btGhostObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btHashMap_btHashInt_btTriangleInfo_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "find"}},
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashInt_btTriangleInfo_find__rt{tis}
btHashMap_btHashInt_btTriangleInfo_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashInt_btTriangleInfo_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_btTriangleInfo, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashInt_btTriangleInfo_getAtIndex__rt{tis}
btHashMap_btHashInt_btTriangleInfo_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashInt_int_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "find"}},
    match_args{tis, {0,{btHashInt,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashInt_int_find__rt{tis}
btHashMap_btHashInt_int_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashInt,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashInt,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashInt_int_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashInt_int, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashInt_int_getAtIndex__rt{tis}
btHashMap_btHashInt_int_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionObject_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btCollisionObject_p_find__rt{tis}
btHashMap_btHashPtr_btCollisionObject_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionObject_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionObject_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btCollisionObject_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btCollisionObject_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionShape_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btCollisionShape_p_find__rt{tis}
btHashMap_btHashPtr_btCollisionShape_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btCollisionShape_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btCollisionShape_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btCollisionShape_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btCollisionShape_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btOptimizedBvh_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btOptimizedBvh_p_find__rt{tis}
btHashMap_btHashPtr_btOptimizedBvh_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btOptimizedBvh_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btOptimizedBvh_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btOptimizedBvh_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_btOptimizedBvh_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_btPointerUid_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btPointerUid_find__rt{tis}
btHashMap_btHashPtr_btPointerUid_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_btPointerUid_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_btPointerUid, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_btPointerUid_getAtIndex__rt{tis}
btHashMap_btHashPtr_btPointerUid_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_const_char_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_const_char_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_const_char_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_const_char_p_find__rt{tis}
btHashMap_btHashPtr_const_char_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_const_char_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_const_char_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_const_char_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_const_char_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_const_char_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashPtr_void_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "find"}},
    match_args{tis, {0,{btHashPtr,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_void_p_find__rt{tis}
btHashMap_btHashPtr_void_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashPtr,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashPtr,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashPtr_void_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashPtr_void_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashPtr_void_p_getAtIndex__rt{tis}
btHashMap_btHashPtr_void_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_btCollisionObject_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionObject_p, "find"}},
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionObject_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashString_btCollisionObject_p_find__rt{tis}
btHashMap_btHashString_btCollisionObject_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_btCollisionObject_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionObject_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionObject_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashString_btCollisionObject_p_getAtIndex__rt{tis}
btHashMap_btHashString_btCollisionObject_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_btCollisionShape_p_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "find"}},
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashString_btCollisionShape_p_find__rt{tis}
btHashMap_btHashString_btCollisionShape_p_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_btCollisionShape_p_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_btCollisionShape_p, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashString_btCollisionShape_p_getAtIndex__rt{tis}
btHashMap_btHashString_btCollisionShape_p_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashMap_btHashString_int_find__rt{tis}
  m::cond{
    match_args{tis, {1,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "find"}},
    match_args{tis, {0,{btHashString,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "find"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashString_int_find__rt{tis}
btHashMap_btHashString_int_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btHashString,0}}}) {
    return a0.find(a1);
  } else if (match_args{tis, {0,{btHashString,0}}}) {
    return a0.find(a1);
  }
}
private metafunction btHashMap_btHashString_int_getAtIndex__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "getAtIndex"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btHashMap_btHashString_int, "getAtIndex"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashMap_btHashString_int_getAtIndex__rt{tis}
btHashMap_btHashString_int_getAtIndex(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getAtIndex(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getAtIndex(a1);
  }
}
private metafunction btHashedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btHashedOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btHashedSimplePairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHashedSimplePairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHashedSimplePairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashedSimplePairCache_getOverlappingPairArrayPtr__rt{tis}
btHashedSimplePairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btHingeAccumulatedAngleConstraint_getAFrame__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getAFrame"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getAFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_getAFrame__rt{tis}
btHingeAccumulatedAngleConstraint_getAFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getAFrame();
  } else if (match_args{tis, {0}}) {
    return a0.getAFrame();
  }
}
private metafunction btHingeAccumulatedAngleConstraint_getBFrame__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getBFrame"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getBFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_getBFrame__rt{tis}
btHingeAccumulatedAngleConstraint_getBFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBFrame();
  } else if (match_args{tis, {0}}) {
    return a0.getBFrame();
  }
}
private metafunction btHingeAccumulatedAngleConstraint_getHingeAngle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getHingeAngle0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getHingeAngle2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_getHingeAngle__rt{tis}
btHingeAccumulatedAngleConstraint_getHingeAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getHingeAngle0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.getHingeAngle2(a1,a2);
  }
}
private metafunction btHingeAccumulatedAngleConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_getJointFeedback__rt{tis}
btHingeAccumulatedAngleConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btHingeAccumulatedAngleConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_getRigidBodyA__rt{tis}
btHingeAccumulatedAngleConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btHingeAccumulatedAngleConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_getRigidBodyB__rt{tis}
btHingeAccumulatedAngleConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btHingeAccumulatedAngleConstraint_setMotorTarget__rt{tis}
  m::cond{
    match_args{tis, {1,{btQuaternion,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "setMotorTarget_btQuaternion_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeAccumulatedAngleConstraint, "setMotorTarget_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint_setMotorTarget__rt{tis}
btHingeAccumulatedAngleConstraint_setMotorTarget(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btQuaternion,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btQuaternion_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btScalar_btScalar(a1,a2);
  }
}
private metafunction btHingeConstraint_getAFrame__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getAFrame"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getAFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_getAFrame__rt{tis}
btHingeConstraint_getAFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getAFrame();
  } else if (match_args{tis, {0}}) {
    return a0.getAFrame();
  }
}
private metafunction btHingeConstraint_getBFrame__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getBFrame"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getBFrame"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_getBFrame__rt{tis}
btHingeConstraint_getBFrame(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBFrame();
  } else if (match_args{tis, {0}}) {
    return a0.getBFrame();
  }
}
private metafunction btHingeConstraint_getHingeAngle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getHingeAngle0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "getHingeAngle2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_getHingeAngle__rt{tis}
btHingeConstraint_getHingeAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getHingeAngle0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.getHingeAngle2(a1,a2);
  }
}
private metafunction btHingeConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_getJointFeedback__rt{tis}
btHingeConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btHingeConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_getRigidBodyA__rt{tis}
btHingeConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btHingeConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btHingeConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_getRigidBodyB__rt{tis}
btHingeConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btHingeConstraint_setMotorTarget__rt{tis}
  m::cond{
    match_args{tis, {1,{btQuaternion,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "setMotorTarget_btQuaternion_btScalar"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btHingeConstraint, "setMotorTarget_btScalar_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint_setMotorTarget__rt{tis}
btHingeConstraint_setMotorTarget(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btQuaternion,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btQuaternion_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setMotorTarget_btScalar_btScalar(a1,a2);
  }
}
private metafunction btIDebugDraw_drawBox__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawBox3"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btTransform,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawBox4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btIDebugDraw_drawBox__rt{tis}
btIDebugDraw_drawBox(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawBox3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btTransform,0},{btVector3,0}}}) {
    return a0.drawBox4(a1,a2,a3,a4);
  }
}
private metafunction btIDebugDraw_drawLine__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawLine3"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawLine4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btIDebugDraw_drawLine__rt{tis}
btIDebugDraw_drawLine(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawLine3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return a0.drawLine4(a1,a2,a3,a4);
  }
}
private metafunction btIDebugDraw_drawSphere__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btTransform,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawSphere_btScalar_btTransform_btVector3"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0},{btVector3,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawSphere_btVector3_btScalar_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btIDebugDraw_drawSphere__rt{tis}
btIDebugDraw_drawSphere(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btTransform,0},{btVector3,0}}}) {
    return a0.drawSphere_btScalar_btTransform_btVector3(a1,a2,a3);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0},{btVector3,0}}}) {
    return a0.drawSphere_btVector3_btScalar_btVector3(a1,a2,a3);
  }
}
private metafunction btIDebugDraw_drawTriangle__rt{tis}
  m::cond{
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawTriangle5"}},
    match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btIDebugDraw, "drawTriangle8"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btIDebugDraw_drawTriangle__rt{tis}
btIDebugDraw_drawTriangle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return a0.drawTriangle5(a1,a2,a3,a4,a5);
  } else if (match_args{tis, {1,{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return a0.drawTriangle8(a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btJacobianEntry_getNonDiagonal__rt{tis}
  m::cond{
    match_args{tis, {0,{btJacobianEntry,0},{btScalar,0}}},
    m::ret_type{m::symbol{btJacobianEntry, "getNonDiagonal2"}},
    match_args{tis, {0,{btJacobianEntry,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btJacobianEntry, "getNonDiagonal3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btJacobianEntry_getNonDiagonal__rt{tis}
btJacobianEntry_getNonDiagonal(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{btJacobianEntry,0},{btScalar,0}}}) {
    return a0.getNonDiagonal2(a1,a2);
  } else if (match_args{tis, {0,{btJacobianEntry,0},{btScalar,0},{btScalar,0}}}) {
    return a0.getNonDiagonal3(a1,a2,a3);
  }
}
private metafunction btManifoldResult_getPersistentManifold__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btManifoldResult, "getPersistentManifold"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btManifoldResult, "getPersistentManifold"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btManifoldResult_getPersistentManifold__rt{tis}
btManifoldResult_getPersistentManifold(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getPersistentManifold();
  } else if (match_args{tis, {0}}) {
    return a0.getPersistentManifold();
  }
}
private metafunction btMinkowskiSumShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMinkowskiSumShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMinkowskiSumShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMinkowskiSumShape_setSafeMargin__rt{tis}
btMinkowskiSumShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btMultiSapBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultiSapBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultiSapBroadphase_getOverlappingPairCache__rt{tis}
btMultiSapBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btMultiSphereShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMultiSphereShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btMultiSphereShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultiSphereShape_setSafeMargin__rt{tis}
btMultiSphereShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btMultimaterialTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btMultimaterialTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btMultimaterialTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultimaterialTriangleMeshShape_getMeshInterface__rt{tis}
btMultimaterialTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btNullPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btNullPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btNullPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btNullPairCache_getOverlappingPairArrayPtr__rt{tis}
btNullPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btOptimizedBvh_serialize__rt{tis}
  m::cond{
    match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}},
    m::ret_type{m::symbol{btOptimizedBvh, "serialize2"}},
    match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}},
    m::ret_type{m::symbol{btOptimizedBvh, "serialize3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btOptimizedBvh_serialize__rt{tis}
btOptimizedBvh_serialize(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}}) {
    return a0.serialize2(a1,a2);
  } else if (match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}}) {
    return a0.serialize3(a1,a2,a3);
  }
}
private metafunction btOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btPairCachingGhostObject_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getBroadphaseHandle"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPairCachingGhostObject_getBroadphaseHandle__rt{tis}
btPairCachingGhostObject_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btPairCachingGhostObject_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPairCachingGhostObject_getCollisionShape__rt{tis}
btPairCachingGhostObject_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btPairCachingGhostObject_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPairCachingGhostObject_getInterpolationWorldTransform__rt{tis}
btPairCachingGhostObject_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btPairCachingGhostObject_getOverlappingObject__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getOverlappingObject"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getOverlappingObject"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPairCachingGhostObject_getOverlappingObject__rt{tis}
btPairCachingGhostObject_getOverlappingObject(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getOverlappingObject(a1);
  }
}
private metafunction btPairCachingGhostObject_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPairCachingGhostObject, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPairCachingGhostObject_getWorldTransform__rt{tis}
btPairCachingGhostObject_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btPersistentManifold_getContactPoint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btPersistentManifold, "getContactPoint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btPersistentManifold, "getContactPoint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPersistentManifold_getContactPoint__rt{tis}
btPersistentManifold_getContactPoint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getContactPoint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getContactPoint(a1);
  }
}
private metafunction btPoint2PointConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPoint2PointConstraint_getJointFeedback__rt{tis}
btPoint2PointConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btPoint2PointConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPoint2PointConstraint_getRigidBodyA__rt{tis}
btPoint2PointConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btPoint2PointConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoint2PointConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPoint2PointConstraint_getRigidBodyB__rt{tis}
btPoint2PointConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btPolyhedralConvexAabbCachingShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexAabbCachingShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexAabbCachingShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPolyhedralConvexAabbCachingShape_setSafeMargin__rt{tis}
btPolyhedralConvexAabbCachingShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btPolyhedralConvexShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btPolyhedralConvexShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPolyhedralConvexShape_setSafeMargin__rt{tis}
btPolyhedralConvexShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btPoolAllocator_getPoolAddress__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btPoolAllocator, "getPoolAddress"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btPoolAllocator, "getPoolAddress"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPoolAllocator_getPoolAddress__rt{tis}
btPoolAllocator_getPoolAddress(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getPoolAddress();
  } else if (match_args{tis, {0}}) {
    return a0.getPoolAddress();
  }
}
private metafunction btQuadWord_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuadWord, "setValue3"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuadWord, "setValue4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btQuadWord_setValue__rt{tis}
btQuadWord_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  }
}
private metafunction btQuantizedBvh_serialize__rt{tis}
  m::cond{
    match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}},
    m::ret_type{m::symbol{btQuantizedBvh, "serialize2"}},
    match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}},
    m::ret_type{m::symbol{btQuantizedBvh, "serialize3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btQuantizedBvh_serialize__rt{tis}
btQuantizedBvh_serialize(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {0,{rptr{void},0},{rptr{btSerializer},0}}}) {
    return a0.serialize2(a1,a2);
  } else if (match_args{tis, {0,{rptr{void},0},{uint,0},{bool,0}}}) {
    return a0.serialize3(a1,a2,a3);
  }
}
private metafunction btQuaternion_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuaternion, "setValue3"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btQuaternion, "setValue4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btQuaternion_setValue__rt{tis}
btQuaternion_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  }
}
private metafunction btRaycastVehicle_getRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRaycastVehicle, "getRigidBody"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRaycastVehicle, "getRigidBody"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRaycastVehicle_getRigidBody__rt{tis}
btRaycastVehicle_getRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBody();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBody();
  }
}
private metafunction btRaycastVehicle_getWheelInfo__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btRaycastVehicle, "getWheelInfo"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btRaycastVehicle, "getWheelInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRaycastVehicle_getWheelInfo__rt{tis}
btRaycastVehicle_getWheelInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getWheelInfo(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getWheelInfo(a1);
  }
}
private metafunction btRigidBody_getBroadphaseHandle__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseHandle"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseHandle"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_getBroadphaseHandle__rt{tis}
btRigidBody_getBroadphaseHandle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseHandle();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseHandle();
  }
}
private metafunction btRigidBody_getBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseProxy"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getBroadphaseProxy"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_getBroadphaseProxy__rt{tis}
btRigidBody_getBroadphaseProxy(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphaseProxy();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphaseProxy();
  }
}
private metafunction btRigidBody_getCollisionShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getCollisionShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getCollisionShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_getCollisionShape__rt{tis}
btRigidBody_getCollisionShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getCollisionShape();
  } else if (match_args{tis, {0}}) {
    return a0.getCollisionShape();
  }
}
private metafunction btRigidBody_getInterpolationWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getInterpolationWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getInterpolationWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_getInterpolationWorldTransform__rt{tis}
btRigidBody_getInterpolationWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getInterpolationWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getInterpolationWorldTransform();
  }
}
private metafunction btRigidBody_getMotionState__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getMotionState"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getMotionState"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_getMotionState__rt{tis}
btRigidBody_getMotionState(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMotionState();
  } else if (match_args{tis, {0}}) {
    return a0.getMotionState();
  }
}
private metafunction btRigidBody_getWorldTransform__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btRigidBody, "getWorldTransform"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btRigidBody, "getWorldTransform"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_getWorldTransform__rt{tis}
btRigidBody_getWorldTransform(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getWorldTransform();
  } else if (match_args{tis, {0}}) {
    return a0.getWorldTransform();
  }
}
private metafunction btRigidBody_setAngularFactor__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0}}},
    m::ret_type{m::symbol{btRigidBody, "setAngularFactor_btScalar"}},
    match_args{tis, {1,{btVector3,0}}},
    m::ret_type{m::symbol{btRigidBody, "setAngularFactor_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_setAngularFactor__rt{tis}
btRigidBody_setAngularFactor(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0}}}) {
    return a0.setAngularFactor_btScalar(a1);
  } else if (match_args{tis, {1,{btVector3,0}}}) {
    return a0.setAngularFactor_btVector3(a1);
  }
}
private metafunction btScaledBvhTriangleMeshShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btScaledBvhTriangleMeshShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btScaledBvhTriangleMeshShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btScaledBvhTriangleMeshShape_getChildShape__rt{tis}
btScaledBvhTriangleMeshShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btSimpleBroadphase_getOverlappingPairCache__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleBroadphase, "getOverlappingPairCache"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleBroadphase, "getOverlappingPairCache"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleBroadphase_getOverlappingPairCache__rt{tis}
btSimpleBroadphase_getOverlappingPairCache(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairCache();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairCache();
  }
}
private metafunction btSimpleDynamicsWorld_addRigidBody__rt{tis}
  m::cond{
    match_args{tis, {1,{rptr{btRigidBody},0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "addRigidBody1"}},
    match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "addRigidBody3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleDynamicsWorld_addRigidBody__rt{tis}
btSimpleDynamicsWorld_addRigidBody(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{rptr{btRigidBody},0}}}) {
    return a0.addRigidBody1(a1);
  } else if (match_args{tis, {1,{rptr{btRigidBody},0},{short,0},{short,0}}}) {
    return a0.addRigidBody3(a1,a2,a3);
  }
}
private metafunction btSimpleDynamicsWorld_getBroadphase__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getBroadphase"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getBroadphase"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleDynamicsWorld_getBroadphase__rt{tis}
btSimpleDynamicsWorld_getBroadphase(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBroadphase();
  } else if (match_args{tis, {0}}) {
    return a0.getBroadphase();
  }
}
private metafunction btSimpleDynamicsWorld_getConstraint__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getConstraint"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getConstraint"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleDynamicsWorld_getConstraint__rt{tis}
btSimpleDynamicsWorld_getConstraint(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getConstraint(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getConstraint(a1);
  }
}
private metafunction btSimpleDynamicsWorld_getDispatchInfo__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatchInfo"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatchInfo"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleDynamicsWorld_getDispatchInfo__rt{tis}
btSimpleDynamicsWorld_getDispatchInfo(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatchInfo();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatchInfo();
  }
}
private metafunction btSimpleDynamicsWorld_getDispatcher__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatcher"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSimpleDynamicsWorld, "getDispatcher"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleDynamicsWorld_getDispatcher__rt{tis}
btSimpleDynamicsWorld_getDispatcher(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getDispatcher();
  } else if (match_args{tis, {0}}) {
    return a0.getDispatcher();
  }
}
private metafunction btSliderConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSliderConstraint_getFrameOffsetA__rt{tis}
btSliderConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btSliderConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSliderConstraint_getFrameOffsetB__rt{tis}
btSliderConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btSliderConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSliderConstraint_getJointFeedback__rt{tis}
btSliderConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btSliderConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSliderConstraint_getRigidBodyA__rt{tis}
btSliderConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btSliderConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSliderConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSliderConstraint_getRigidBodyB__rt{tis}
btSliderConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btSortedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btSortedOverlappingPairCache, "getOverlappingPairArrayPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSortedOverlappingPairCache_getOverlappingPairArrayPtr__rt{tis}
btSortedOverlappingPairCache_getOverlappingPairArrayPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOverlappingPairArrayPtr();
  } else if (match_args{tis, {0}}) {
    return a0.getOverlappingPairArrayPtr();
  }
}
private metafunction btSphereShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSphereShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btSphereShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSphereShape_setSafeMargin__rt{tis}
btSphereShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btTransform_getBasis__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTransform, "getBasis"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTransform, "getBasis"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTransform_getBasis__rt{tis}
btTransform_getBasis(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getBasis();
  } else if (match_args{tis, {0}}) {
    return a0.getBasis();
  }
}
private metafunction btTransform_getOrigin__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTransform, "getOrigin"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTransform, "getOrigin"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTransform_getOrigin__rt{tis}
btTransform_getOrigin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getOrigin();
  } else if (match_args{tis, {0}}) {
    return a0.getOrigin();
  }
}
private metafunction btTriangleMeshShape_getMeshInterface__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTriangleMeshShape, "getMeshInterface"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTriangleMeshShape, "getMeshInterface"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleMeshShape_getMeshInterface__rt{tis}
btTriangleMeshShape_getMeshInterface(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getMeshInterface();
  } else if (match_args{tis, {0}}) {
    return a0.getMeshInterface();
  }
}
private metafunction btTriangleShape_getVertexPtr__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btTriangleShape, "getVertexPtr"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btTriangleShape, "getVertexPtr"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleShape_getVertexPtr__rt{tis}
btTriangleShape_getVertexPtr(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getVertexPtr(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getVertexPtr(a1);
  }
}
private metafunction btTriangleShape_setSafeMargin__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTriangleShape, "setSafeMargin_btScalar_btScalar"}},
    match_args{tis, {1,{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{btTriangleShape, "setSafeMargin_btVector3_btScalar"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleShape_setSafeMargin__rt{tis}
btTriangleShape_setSafeMargin(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btScalar_btScalar(a1,a2);
  } else if (match_args{tis, {1,{btVector3,0},{btScalar,0}}}) {
    return a0.setSafeMargin_btVector3_btScalar(a1,a2);
  }
}
private metafunction btTypedConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTypedConstraint_getJointFeedback__rt{tis}
btTypedConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btTypedConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTypedConstraint_getRigidBodyA__rt{tis}
btTypedConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btTypedConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btTypedConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTypedConstraint_getRigidBodyB__rt{tis}
btTypedConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btUniformScalingShape_getChildShape__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniformScalingShape, "getChildShape"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniformScalingShape, "getChildShape"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniformScalingShape_getChildShape__rt{tis}
btUniformScalingShape_getChildShape(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getChildShape();
  } else if (match_args{tis, {0}}) {
    return a0.getChildShape();
  }
}
private metafunction btUnionFind_find__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "find1"}},
    match_args{tis, {1,{int,0},{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "find2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUnionFind_find__rt{tis}
btUnionFind_find(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.find1(a1);
  } else if (match_args{tis, {1,{int,0},{int,0}}}) {
    return a0.find2(a1,a2);
  }
}
private metafunction btUnionFind_getElement__rt{tis}
  m::cond{
    match_args{tis, {1,{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "getElement"}},
    match_args{tis, {0,{int,0}}},
    m::ret_type{m::symbol{btUnionFind, "getElement"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUnionFind_getElement__rt{tis}
btUnionFind_getElement(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{int,0}}}) {
    return a0.getElement(a1);
  } else if (match_args{tis, {0,{int,0}}}) {
    return a0.getElement(a1);
  }
}
private metafunction btUniversalConstraint_calculateTransforms__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "calculateTransforms0"}},
    match_args{tis, {1,{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{btUniversalConstraint, "calculateTransforms2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint_calculateTransforms__rt{tis}
btUniversalConstraint_calculateTransforms(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.calculateTransforms0();
  } else if (match_args{tis, {1,{btTransform,0},{btTransform,0}}}) {
    return a0.calculateTransforms2(a1,a2);
  }
}
private metafunction btUniversalConstraint_getFrameOffsetA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint_getFrameOffsetA__rt{tis}
btUniversalConstraint_getFrameOffsetA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetA();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetA();
  }
}
private metafunction btUniversalConstraint_getFrameOffsetB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getFrameOffsetB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint_getFrameOffsetB__rt{tis}
btUniversalConstraint_getFrameOffsetB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getFrameOffsetB();
  } else if (match_args{tis, {0}}) {
    return a0.getFrameOffsetB();
  }
}
private metafunction btUniversalConstraint_getJointFeedback__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getJointFeedback"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getJointFeedback"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint_getJointFeedback__rt{tis}
btUniversalConstraint_getJointFeedback(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getJointFeedback();
  } else if (match_args{tis, {0}}) {
    return a0.getJointFeedback();
  }
}
private metafunction btUniversalConstraint_getRigidBodyA__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyA"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyA"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint_getRigidBodyA__rt{tis}
btUniversalConstraint_getRigidBodyA(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyA();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyA();
  }
}
private metafunction btUniversalConstraint_getRigidBodyB__rt{tis}
  m::cond{
    match_args{tis, {1}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyB"}},
    match_args{tis, {0}},
    m::ret_type{m::symbol{btUniversalConstraint, "getRigidBodyB"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint_getRigidBodyB__rt{tis}
btUniversalConstraint_getRigidBodyB(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1}}) {
    return a0.getRigidBodyB();
  } else if (match_args{tis, {0}}) {
    return a0.getRigidBodyB();
  }
}
private metafunction btVector4_setValue__rt{tis}
  m::cond{
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btVector4, "setValue3"}},
    match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{btVector4, "setValue4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btVector4_setValue__rt{tis}
btVector4_setValue(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue3(a1,a2,a3);
  } else if (match_args{tis, {1,{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return a0.setValue4(a1,a2,a3,a4);
  }
}
private metafunction btActivatingCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btActivatingCollisionAlgorithm1"}},
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btActivatingCollisionAlgorithm3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btActivatingCollisionAlgorithm__rt{tis}
btActivatingCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btActivatingCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btActivatingCollisionAlgorithm3(a0,a1,a2);
  }
}
private metafunction btAngle__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0},{btQuaternion,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btAngle_btQuaternion_btQuaternion"}},
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btAngle_btVector3_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAngle__rt{tis}
btAngle(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0},{btQuaternion,0}}}) {
    return btAngle_btQuaternion_btQuaternion(a0,a1);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btAngle_btVector3_btVector3(a0,a1);
  }
}
private metafunction btAngleCompareFunc__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btAngleCompareFunc1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btAngleCompareFunc__rt{tis}
btAngleCompareFunc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btAngleCompareFunc1(a0);
  }
}
private metafunction btBU_Simplex1to4__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBU_Simplex1to4_1"}},
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBU_Simplex1to4_2"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBU_Simplex1to4_3"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBU_Simplex1to4_4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBU_Simplex1to4__rt{tis}
btBU_Simplex1to4_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBU_Simplex1to4_1(a0);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_2(a0,a1);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_3(a0,a1,a2);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btBU_Simplex1to4_4(a0,a1,a2,a3);
  }
}
private metafunction btBox2dBox2dCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBox2dBox2dCollisionAlgorithm1"}},
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBox2dBox2dCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBox2dBox2dCollisionAlgorithm__rt{tis}
btBox2dBox2dCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btBox2dBox2dCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btBox2dBox2dCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btBox2dShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBox2dShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBox2dShape__rt{tis}
btBox2dShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBox2dShape1(a0);
  }
}
private metafunction btBoxBoxCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBoxBoxCollisionAlgorithm1"}},
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBoxBoxCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBoxBoxCollisionAlgorithm__rt{tis}
btBoxBoxCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btBoxBoxCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btBoxBoxCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btBoxBoxDetector__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btBoxShape},0},{crptr{btBoxShape},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBoxBoxDetector2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBoxBoxDetector__rt{tis}
btBoxBoxDetector_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btBoxShape},0},{crptr{btBoxShape},0}}}) {
    return btBoxBoxDetector2(a0,a1);
  }
}
private metafunction btBoxShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBoxShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBoxShape__rt{tis}
btBoxShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btBoxShape1(a0);
  }
}
private metafunction btBroadphasePair__rt{tis}
  m::cond{
    match_args{tis, {{btBroadphaseProxy,1},{btBroadphaseProxy,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBroadphasePair2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBroadphasePair__rt{tis}
btBroadphasePair_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btBroadphaseProxy,1},{btBroadphaseProxy,1}}}) {
    return btBroadphasePair2(a0,a1);
  }
}
private metafunction btBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBroadphaseProxy6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBroadphaseProxy__rt{tis}
btBroadphaseProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}}) {
    return btBroadphaseProxy6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btBvhTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBvhTriangleMeshShape3"}},
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btBvhTriangleMeshShape5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btBvhTriangleMeshShape__rt{tis}
btBvhTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}}) {
    return btBvhTriangleMeshShape3(a0,a1,a2);
  } else if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btBvhTriangleMeshShape5(a0,a1,a2,a3,a4);
  }
}
private metafunction btCapsuleShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCapsuleShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCapsuleShape__rt{tis}
btCapsuleShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShape2(a0,a1);
  }
}
private metafunction btCapsuleShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCapsuleShapeX2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCapsuleShapeX__rt{tis}
btCapsuleShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShapeX2(a0,a1);
  }
}
private metafunction btCapsuleShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCapsuleShapeZ2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCapsuleShapeZ__rt{tis}
btCapsuleShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btCapsuleShapeZ2(a0,a1);
  }
}
private metafunction btCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionAlgorithm__rt{tis}
btCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btCollisionAlgorithm1(a0);
  }
}
private metafunction btCollisionAlgorithmConstructionInfo__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionAlgorithmConstructionInfo2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionAlgorithmConstructionInfo__rt{tis}
btCollisionAlgorithmConstructionInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{int,0}}}) {
    return btCollisionAlgorithmConstructionInfo2(a0,a1);
  }
}
private metafunction btCollisionDispatcher__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionDispatcher1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionDispatcher__rt{tis}
btCollisionDispatcher_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btCollisionConfiguration},0}}}) {
    return btCollisionDispatcher1(a0);
  }
}
private metafunction btCollisionObjectWrapper__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionShape},0},{crptr{btCollisionObject},0},{btTransform,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionObjectWrapper6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionObjectWrapper__rt{tis}
btCollisionObjectWrapper_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionShape},0},{crptr{btCollisionObject},0},{btTransform,0},{int,0},{int,0}}}) {
    return btCollisionObjectWrapper6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btCollisionWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorld3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld__rt{tis}
btCollisionWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}}) {
    return btCollisionWorld3(a0,a1,a2);
  }
}
private metafunction btCollisionWorldImporter__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btCollisionWorld},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorldImporter1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorldImporter__rt{tis}
btCollisionWorldImporter_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btCollisionWorld},0}}}) {
    return btCollisionWorldImporter1(a0);
  }
}
private metafunction btCollisionWorld_AllHitsRayResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorld_AllHitsRayResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_AllHitsRayResultCallback__rt{tis}
btCollisionWorld_AllHitsRayResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_AllHitsRayResultCallback2(a0,a1);
  }
}
private metafunction btCollisionWorld_ClosestConvexResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorld_ClosestConvexResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_ClosestConvexResultCallback__rt{tis}
btCollisionWorld_ClosestConvexResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_ClosestConvexResultCallback2(a0,a1);
  }
}
private metafunction btCollisionWorld_ClosestRayResultCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorld_ClosestRayResultCallback2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_ClosestRayResultCallback__rt{tis}
btCollisionWorld_ClosestRayResultCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btCollisionWorld_ClosestRayResultCallback2(a0,a1);
  }
}
private metafunction btCollisionWorld_LocalConvexResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorld_LocalConvexResult5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_LocalConvexResult__rt{tis}
btCollisionWorld_LocalConvexResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btCollisionWorld_LocalConvexResult5(a0,a1,a2,a3,a4);
  }
}
private metafunction btCollisionWorld_LocalRayResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCollisionWorld_LocalRayResult4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCollisionWorld_LocalRayResult__rt{tis}
btCollisionWorld_LocalRayResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{rptr{btCollisionWorld_LocalShapeInfo},0},{btVector3,0},{btScalar,0}}}) {
    return btCollisionWorld_LocalRayResult4(a0,a1,a2,a3);
  }
}
private metafunction btCompoundCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCompoundCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCompoundCollisionAlgorithm__rt{tis}
btCompoundCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btCompoundCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btCompoundCompoundCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCompoundCompoundCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCompoundCompoundCollisionAlgorithm__rt{tis}
btCompoundCompoundCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btCompoundCompoundCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btCompoundShape__rt{tis}
  m::cond{
    match_args{tis, {{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCompoundShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCompoundShape__rt{tis}
btCompoundShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0}}}) {
    return btCompoundShape1(a0);
  }
}
private metafunction btConeShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConeShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeShape__rt{tis}
btConeShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShape2(a0,a1);
  }
}
private metafunction btConeShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConeShapeX2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeShapeX__rt{tis}
btConeShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShapeX2(a0,a1);
  }
}
private metafunction btConeShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConeShapeZ2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeShapeZ__rt{tis}
btConeShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConeShapeZ2(a0,a1);
  }
}
private metafunction btConeTwistConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConeTwistConstraint2"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConeTwistConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConeTwistConstraint__rt{tis}
btConeTwistConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0}}}) {
    return btConeTwistConstraint2(a0,a1);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0}}}) {
    return btConeTwistConstraint4(a0,a1,a2,a3);
  }
}
private metafunction btContactConstraint__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btRigidBody,1},{btRigidBody,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btContactConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btContactConstraint__rt{tis}
btContactConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btRigidBody,1},{btRigidBody,1}}}) {
    return btContactConstraint3(a0,a1,a2);
  }
}
private metafunction btContinuousConvexCollision__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btStaticPlaneShape},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btContinuousConvexCollision2"}},
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btContinuousConvexCollision4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btContinuousConvexCollision__rt{tis}
btContinuousConvexCollision_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btStaticPlaneShape},0}}}) {
    return btContinuousConvexCollision2(a0,a1);
  } else if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btContinuousConvexCollision4(a0,a1,a2,a3);
  }
}
private metafunction btConvex2dConvex2dAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvex2dConvex2dAlgorithm8"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvex2dConvex2dAlgorithm__rt{tis}
btConvex2dConvex2dAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0},{int,0},{int,0}}}) {
    return btConvex2dConvex2dAlgorithm8(a0,a1,a2,a3,a4,a5,a6,a7);
  }
}
private metafunction btConvex2dConvex2dAlgorithm_CreateFunc__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvex2dConvex2dAlgorithm_CreateFunc2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvex2dConvex2dAlgorithm_CreateFunc__rt{tis}
btConvex2dConvex2dAlgorithm_CreateFunc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btConvex2dConvex2dAlgorithm_CreateFunc2(a0,a1);
  }
}
private metafunction btConvex2dShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btConvexShape},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvex2dShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvex2dShape__rt{tis}
btConvex2dShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btConvexShape},0}}}) {
    return btConvex2dShape1(a0);
  }
}
private metafunction btConvexConcaveCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexConcaveCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexConcaveCollisionAlgorithm__rt{tis}
btConvexConcaveCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btConvexConcaveCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btConvexHullShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btScalar},0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexHullShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexHullShape__rt{tis}
btConvexHullShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btScalar},0},{int,0},{int,0}}}) {
    return btConvexHullShape3(a0,a1,a2);
  }
}
private metafunction btConvexPlaneCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexPlaneCollisionAlgorithm7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexPlaneCollisionAlgorithm__rt{tis}
btConvexPlaneCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0},{int,0},{int,0}}}) {
    return btConvexPlaneCollisionAlgorithm7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btConvexPointCloudShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btVector3},0},{int,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexPointCloudShape4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexPointCloudShape__rt{tis}
btConvexPointCloudShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btVector3},0},{int,0},{btVector3,0},{bool,0}}}) {
    return btConvexPointCloudShape4(a0,a1,a2,a3);
  }
}
private metafunction btConvexSeparatingDistanceUtil__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexSeparatingDistanceUtil2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexSeparatingDistanceUtil__rt{tis}
btConvexSeparatingDistanceUtil_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btConvexSeparatingDistanceUtil2(a0,a1);
  }
}
private metafunction btConvexTriangleCallback__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexTriangleCallback4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexTriangleCallback__rt{tis}
btConvexTriangleCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btConvexTriangleCallback4(a0,a1,a2,a3);
  }
}
private metafunction btConvexTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btConvexTriangleMeshShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btConvexTriangleMeshShape__rt{tis}
btConvexTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0}}}) {
    return btConvexTriangleMeshShape2(a0,a1);
  }
}
private metafunction btCylinderShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCylinderShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCylinderShape__rt{tis}
btCylinderShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShape1(a0);
  }
}
private metafunction btCylinderShapeX__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCylinderShapeX1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCylinderShapeX__rt{tis}
btCylinderShapeX_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShapeX1(a0);
  }
}
private metafunction btCylinderShapeZ__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btCylinderShapeZ1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btCylinderShapeZ__rt{tis}
btCylinderShapeZ_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0}}}) {
    return btCylinderShapeZ1(a0);
  }
}
private metafunction btDbvtAabbMm_FromPoints__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btVector3},0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvtAabbMm_FromPoints_btVector3_cp_int"}},
    match_args{tis, {{rptr{crptr{btVector3}},0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvtAabbMm_FromPoints_btVector3_cp_p_int"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvtAabbMm_FromPoints__rt{tis}
btDbvtAabbMm_FromPoints(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btVector3},0},{int,0}}}) {
    return btDbvtAabbMm_FromPoints_btVector3_cp_int(a0,a1);
  } else if (match_args{tis, {{rptr{crptr{btVector3}},0},{int,0}}}) {
    return btDbvtAabbMm_FromPoints_btVector3_cp_p_int(a0,a1);
  }
}
private metafunction btDbvtBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvtBroadphase1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvtBroadphase__rt{tis}
btDbvtBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btOverlappingPairCache},0}}}) {
    return btDbvtBroadphase1(a0);
  }
}
private metafunction btDbvtProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvtProxy5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvtProxy__rt{tis}
btDbvtProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{rptr{void},0},{short,0},{short,0}}}) {
    return btDbvtProxy5(a0,a1,a2,a3,a4);
  }
}
private metafunction btDbvt_sStkCLN__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{rptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvt_sStkCLN2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvt_sStkCLN__rt{tis}
btDbvt_sStkCLN_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{rptr{btDbvtNode},0}}}) {
    return btDbvt_sStkCLN2(a0,a1);
  }
}
private metafunction btDbvt_sStkNN__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvt_sStkNN2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvt_sStkNN__rt{tis}
btDbvt_sStkNN_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{crptr{btDbvtNode},0}}}) {
    return btDbvt_sStkNN2(a0,a1);
  }
}
private metafunction btDbvt_sStkNP__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{uint,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvt_sStkNP2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvt_sStkNP__rt{tis}
btDbvt_sStkNP_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{uint,0}}}) {
    return btDbvt_sStkNP2(a0,a1);
  }
}
private metafunction btDbvt_sStkNPS__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btDbvtNode},0},{uint,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDbvt_sStkNPS3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDbvt_sStkNPS__rt{tis}
btDbvt_sStkNPS_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btDbvtNode},0},{uint,0},{btScalar,0}}}) {
    return btDbvt_sStkNPS3(a0,a1,a2);
  }
}
private metafunction btDefaultCollisionConfiguration__rt{tis}
  m::cond{
    match_args{tis, {{btDefaultCollisionConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDefaultCollisionConfiguration1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDefaultCollisionConfiguration__rt{tis}
btDefaultCollisionConfiguration_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btDefaultCollisionConstructionInfo,0}}}) {
    return btDefaultCollisionConfiguration1(a0);
  }
}
private metafunction btDefaultMotionState__rt{tis}
  m::cond{
    match_args{tis, {{btTransform,0},{btTransform,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDefaultMotionState2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDefaultMotionState__rt{tis}
btDefaultMotionState_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btTransform,0},{btTransform,0}}}) {
    return btDefaultMotionState2(a0,a1);
  }
}
private metafunction btDefaultSerializer__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDefaultSerializer1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDefaultSerializer__rt{tis}
btDefaultSerializer_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btDefaultSerializer1(a0);
  }
}
private metafunction btDefaultVehicleRaycaster__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDynamicsWorld},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDefaultVehicleRaycaster1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDefaultVehicleRaycaster__rt{tis}
btDefaultVehicleRaycaster_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDynamicsWorld},0}}}) {
    return btDefaultVehicleRaycaster1(a0);
  }
}
private metafunction btDiscreteDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDiscreteDynamicsWorld4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDiscreteDynamicsWorld__rt{tis}
btDiscreteDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}}) {
    return btDiscreteDynamicsWorld4(a0,a1,a2,a3);
  }
}
private metafunction btDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btDynamicsWorld3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btDynamicsWorld__rt{tis}
btDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btCollisionConfiguration},0}}}) {
    return btDynamicsWorld3(a0,a1,a2);
  }
}
private metafunction btEmptyAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btEmptyAlgorithm1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btEmptyAlgorithm__rt{tis}
btEmptyAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btEmptyAlgorithm1(a0);
  }
}
private metafunction btGEN_Link__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btGEN_Link},0},{rptr{btGEN_Link},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGEN_Link2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGEN_Link__rt{tis}
btGEN_Link_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btGEN_Link},0},{rptr{btGEN_Link},0}}}) {
    return btGEN_Link2(a0,a1);
  }
}
private metafunction btGearConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGearConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGearConstraint__rt{tis}
btGearConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btGearConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btGeneric6DofConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGeneric6DofConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGeneric6DofConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofConstraint__rt{tis}
btGeneric6DofConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btGeneric6DofSpringConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGeneric6DofSpringConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGeneric6DofSpringConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGeneric6DofSpringConstraint__rt{tis}
btGeneric6DofSpringConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofSpringConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btGeneric6DofSpringConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btGhostObject_upcast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGhostObject_upcast_btCollisionObject_cp"}},
    match_args{tis, {{rptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGhostObject_upcast_btCollisionObject_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGhostObject_upcast__rt{tis}
btGhostObject_upcast(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btGhostObject_upcast_btCollisionObject_cp(a0);
  } else if (match_args{tis, {{rptr{btCollisionObject},0}}}) {
    return btGhostObject_upcast_btCollisionObject_p(a0);
  }
}
private metafunction btGjkConvexCast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGjkConvexCast3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGjkConvexCast__rt{tis}
btGjkConvexCast_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}}) {
    return btGjkConvexCast3(a0,a1,a2);
  }
}
private metafunction btGjkEpaSolver2_SignedDistance__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0},{crptr{btConvexShape},0},{btTransform,0},{btGjkEpaSolver2_sResults,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGjkEpaSolver2_SignedDistance5"}},
    match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{crptr{btConvexShape},0},{btTransform,0},{btVector3,0},{btGjkEpaSolver2_sResults,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGjkEpaSolver2_SignedDistance6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGjkEpaSolver2_SignedDistance__rt{tis}
btGjkEpaSolver2_SignedDistance(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0},{crptr{btConvexShape},0},{btTransform,0},{btGjkEpaSolver2_sResults,1}}}) {
    return btGjkEpaSolver2_SignedDistance5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{crptr{btConvexShape},0},{btTransform,0},{btVector3,0},{btGjkEpaSolver2_sResults,1}}}) {
    return btGjkEpaSolver2_SignedDistance6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btGjkPairDetector__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGjkPairDetector4"}},
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{int,0},{int,0},{btScalar,0},{btScalar,0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btGjkPairDetector8"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btGjkPairDetector__rt{tis}
btGjkPairDetector_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btGjkPairDetector4(a0,a1,a2,a3);
  } else if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{int,0},{int,0},{btScalar,0},{btScalar,0},{rptr{btVoronoiSimplexSolver},0},{rptr{btConvexPenetrationDepthSolver},0}}}) {
    return btGjkPairDetector8(a0,a1,a2,a3,a4,a5,a6,a7);
  }
}
private metafunction btHashInt__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHashInt1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashInt__rt{tis}
btHashInt_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btHashInt1(a0);
  }
}
private metafunction btHashPtr__rt{tis}
  m::cond{
    match_args{tis, {{crptr{void},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHashPtr1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashPtr__rt{tis}
btHashPtr_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{void},0}}}) {
    return btHashPtr1(a0);
  }
}
private metafunction btHashString__rt{tis}
  m::cond{
    match_args{tis, {{crptr{char},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHashString1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHashString__rt{tis}
btHashString_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{char},0}}}) {
    return btHashString1(a0);
  }
}
private metafunction btHeightfieldTerrainShape__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{int,0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHeightfieldTerrainShape7"}},
    match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{btScalar,0},{btScalar,0},{int,0},{PHY_ScalarType,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHeightfieldTerrainShape9"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHeightfieldTerrainShape__rt{tis}
btHeightfieldTerrainShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{int,0},{bool,0},{bool,0}}}) {
    return btHeightfieldTerrainShape7(a0,a1,a2,a3,a4,a5,a6);
  } else if (match_args{tis, {{int,0},{int,0},{crptr{void},0},{btScalar,0},{btScalar,0},{btScalar,0},{int,0},{PHY_ScalarType,0},{bool,0}}}) {
    return btHeightfieldTerrainShape9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btHingeAccumulatedAngleConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeAccumulatedAngleConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeAccumulatedAngleConstraint4"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeAccumulatedAngleConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeAccumulatedAngleConstraint7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeAccumulatedAngleConstraint__rt{tis}
btHingeAccumulatedAngleConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btHingeAccumulatedAngleConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeAccumulatedAngleConstraint4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btHingeAccumulatedAngleConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeAccumulatedAngleConstraint7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btHingeConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeConstraint4"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeConstraint5"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btHingeConstraint7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btHingeConstraint__rt{tis}
btHingeConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btHingeConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeConstraint4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btHingeConstraint5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btHingeConstraint7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btInfMaskConverter__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btInfMaskConverter1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btInfMaskConverter__rt{tis}
btInfMaskConverter_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btInfMaskConverter1(a0);
  }
}
private metafunction btJacobianEntry__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btJacobianEntry4"}},
    match_args{tis, {{btVector3,0},{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btJacobianEntry5"}},
    match_args{tis, {{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btJacobianEntry6"}},
    match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btJacobianEntry9"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btJacobianEntry__rt{tis}
btJacobianEntry_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btJacobianEntry4(a0,a1,a2,a3);
  } else if (match_args{tis, {{btVector3,0},{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0}}}) {
    return btJacobianEntry5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btJacobianEntry6(a0,a1,a2,a3,a4,a5);
  } else if (match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0},{btVector3,0},{btScalar,0}}}) {
    return btJacobianEntry9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btKinematicCharacterController__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPairCachingGhostObject},0},{rptr{btConvexShape},0},{btScalar,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btKinematicCharacterController4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btKinematicCharacterController__rt{tis}
btKinematicCharacterController_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPairCachingGhostObject},0},{rptr{btConvexShape},0},{btScalar,0},{int,0}}}) {
    return btKinematicCharacterController4(a0,a1,a2,a3);
  }
}
private metafunction btManifoldPoint__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btManifoldPoint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btManifoldPoint__rt{tis}
btManifoldPoint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0},{btScalar,0}}}) {
    return btManifoldPoint4(a0,a1,a2,a3);
  }
}
private metafunction btManifoldResult__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btManifoldResult2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btManifoldResult__rt{tis}
btManifoldResult_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btManifoldResult2(a0,a1);
  }
}
private metafunction btMaterial__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMaterial2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMaterial__rt{tis}
btMaterial_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btMaterial2(a0,a1);
  }
}
private metafunction btMatrix3x3__rt{tis}
  m::cond{
    match_args{tis, {{btQuaternion,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMatrix3x3_1"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMatrix3x3_9"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMatrix3x3__rt{tis}
btMatrix3x3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btQuaternion,0}}}) {
    return btMatrix3x3_1(a0);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btMatrix3x3_9(a0,a1,a2,a3,a4,a5,a6,a7,a8);
  }
}
private metafunction btMinkowskiSumShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMinkowskiSumShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMinkowskiSumShape__rt{tis}
btMinkowskiSumShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0}}}) {
    return btMinkowskiSumShape2(a0,a1);
  }
}
private metafunction btMultiSapBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMultiSapBroadphase2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultiSapBroadphase__rt{tis}
btMultiSapBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}}) {
    return btMultiSapBroadphase2(a0,a1);
  }
}
private metafunction btMultiSapBroadphase_btMultiSapProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMultiSapBroadphase_btMultiSapProxy6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultiSapBroadphase_btMultiSapProxy__rt{tis}
btMultiSapBroadphase_btMultiSapProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0}}}) {
    return btMultiSapBroadphase_btMultiSapProxy6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btMultiSphereShape__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btVector3},0},{crptr{btScalar},0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMultiSphereShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultiSphereShape__rt{tis}
btMultiSphereShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btVector3},0},{crptr{btScalar},0},{int,0}}}) {
    return btMultiSphereShape3(a0,a1,a2);
  }
}
private metafunction btMultimaterialTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMultimaterialTriangleMeshShape3"}},
    match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btMultimaterialTriangleMeshShape5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btMultimaterialTriangleMeshShape__rt{tis}
btMultimaterialTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{bool,0}}}) {
    return btMultimaterialTriangleMeshShape3(a0,a1,a2);
  } else if (match_args{tis, {{rptr{btStridingMeshInterface},0},{bool,0},{btVector3,0},{btVector3,0},{bool,0}}}) {
    return btMultimaterialTriangleMeshShape5(a0,a1,a2,a3,a4);
  }
}
private metafunction btPersistentManifold__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0},{crptr{btCollisionObject},0},{int,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btPersistentManifold5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPersistentManifold__rt{tis}
btPersistentManifold_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0},{crptr{btCollisionObject},0},{int,0},{btScalar,0},{btScalar,0}}}) {
    return btPersistentManifold5(a0,a1,a2,a3,a4);
  }
}
private metafunction btPoint2PointConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btPoint2PointConstraint2"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btPoint2PointConstraint4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPoint2PointConstraint__rt{tis}
btPoint2PointConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btVector3,0}}}) {
    return btPoint2PointConstraint2(a0,a1);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0}}}) {
    return btPoint2PointConstraint4(a0,a1,a2,a3);
  }
}
private metafunction btPolarDecomposition__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{uint,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btPolarDecomposition2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPolarDecomposition__rt{tis}
btPolarDecomposition_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{uint,0}}}) {
    return btPolarDecomposition2(a0,a1);
  }
}
private metafunction btPoolAllocator__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btPoolAllocator2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btPoolAllocator__rt{tis}
btPoolAllocator_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0}}}) {
    return btPoolAllocator2(a0,a1);
  }
}
private metafunction btQuadWord__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btQuadWord3"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btQuadWord4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btQuadWord__rt{tis}
btQuadWord_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuadWord3(a0,a1,a2);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuadWord4(a0,a1,a2,a3);
  }
}
private metafunction btQuaternion__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btQuaternion2"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btQuaternion3"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btQuaternion4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btQuaternion__rt{tis}
btQuaternion_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0}}}) {
    return btQuaternion2(a0,a1);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuaternion3(a0,a1,a2);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btQuaternion4(a0,a1,a2,a3);
  }
}
private metafunction btRaycastVehicle__rt{tis}
  m::cond{
    match_args{tis, {{btRaycastVehicle_btVehicleTuning,0},{rptr{btRigidBody},0},{rptr{btVehicleRaycaster},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btRaycastVehicle3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRaycastVehicle__rt{tis}
btRaycastVehicle_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRaycastVehicle_btVehicleTuning,0},{rptr{btRigidBody},0},{rptr{btVehicleRaycaster},0}}}) {
    return btRaycastVehicle3(a0,a1,a2);
  }
}
private metafunction btRigidBody__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody_btRigidBodyConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btRigidBody1"}},
    match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btRigidBody4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody__rt{tis}
btRigidBody_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody_btRigidBodyConstructionInfo,0}}}) {
    return btRigidBody1(a0);
  } else if (match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}}) {
    return btRigidBody4(a0,a1,a2,a3);
  }
}
private metafunction btRigidBody_btRigidBodyConstructionInfo__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btRigidBody_btRigidBodyConstructionInfo4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_btRigidBodyConstructionInfo__rt{tis}
btRigidBody_btRigidBodyConstructionInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{rptr{btMotionState},0},{rptr{btCollisionShape},0},{btVector3,0}}}) {
    return btRigidBody_btRigidBodyConstructionInfo4(a0,a1,a2,a3);
  }
}
private metafunction btRigidBody_upcast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btRigidBody_upcast_btCollisionObject_cp"}},
    match_args{tis, {{rptr{btCollisionObject},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btRigidBody_upcast_btCollisionObject_p"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btRigidBody_upcast__rt{tis}
btRigidBody_upcast(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btCollisionObject},0}}}) {
    return btRigidBody_upcast_btCollisionObject_cp(a0);
  } else if (match_args{tis, {{rptr{btCollisionObject},0}}}) {
    return btRigidBody_upcast_btCollisionObject_p(a0);
  }
}
private metafunction btScaledBvhTriangleMeshShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btBvhTriangleMeshShape},0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btScaledBvhTriangleMeshShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btScaledBvhTriangleMeshShape__rt{tis}
btScaledBvhTriangleMeshShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btBvhTriangleMeshShape},0},{btVector3,0}}}) {
    return btScaledBvhTriangleMeshShape2(a0,a1);
  }
}
private metafunction btSelect__rt{tis}
  m::cond{
    match_args{tis, {{uint,0},{float,0},{float,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSelect_unsigned_int_float_float"}},
    match_args{tis, {{uint,0},{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSelect_unsigned_int_int_int"}},
    match_args{tis, {{uint,0},{uint,0},{uint,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSelect_unsigned_int_unsigned_int_unsigned_int"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSelect__rt{tis}
btSelect(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{uint,0},{float,0},{float,0}}}) {
    return btSelect_unsigned_int_float_float(a0,a1,a2);
  } else if (match_args{tis, {{uint,0},{int,0},{int,0}}}) {
    return btSelect_unsigned_int_int_int(a0,a1,a2);
  } else if (match_args{tis, {{uint,0},{uint,0},{uint,0}}}) {
    return btSelect_unsigned_int_unsigned_int_unsigned_int(a0,a1,a2);
  }
}
private metafunction btShapeHull__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btShapeHull1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btShapeHull__rt{tis}
btShapeHull_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0}}}) {
    return btShapeHull1(a0);
  }
}
private metafunction btSimpleBroadphase__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSimpleBroadphase2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleBroadphase__rt{tis}
btSimpleBroadphase_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{btOverlappingPairCache},0}}}) {
    return btSimpleBroadphase2(a0,a1);
  }
}
private metafunction btSimpleBroadphaseProxy__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSimpleBroadphaseProxy7"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleBroadphaseProxy__rt{tis}
btSimpleBroadphaseProxy_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{int,0},{rptr{void},0},{short,0},{short,0},{rptr{void},0}}}) {
    return btSimpleBroadphaseProxy7(a0,a1,a2,a3,a4,a5,a6);
  }
}
private metafunction btSimpleDynamicsWorld__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSimpleDynamicsWorld4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimpleDynamicsWorld__rt{tis}
btSimpleDynamicsWorld_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btDispatcher},0},{rptr{btBroadphaseInterface},0},{rptr{btConstraintSolver},0},{rptr{btCollisionConfiguration},0}}}) {
    return btSimpleDynamicsWorld4(a0,a1,a2,a3);
  }
}
private metafunction btSimplePair__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSimplePair2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSimplePair__rt{tis}
btSimplePair_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{int,0}}}) {
    return btSimplePair2(a0,a1);
  }
}
private metafunction btSliderConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSliderConstraint3"}},
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSliderConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSliderConstraint__rt{tis}
btSliderConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btTransform,0},{bool,0}}}) {
    return btSliderConstraint3(a0,a1,a2);
  } else if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btTransform,0},{btTransform,0},{bool,0}}}) {
    return btSliderConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSolve2LinearConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSolve2LinearConstraint2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSolve2LinearConstraint__rt{tis}
btSolve2LinearConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0}}}) {
    return btSolve2LinearConstraint2(a0,a1);
  }
}
private metafunction btSpatialForceVector__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSpatialForceVector2"}},
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSpatialForceVector6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSpatialForceVector__rt{tis}
btSpatialForceVector_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btSpatialForceVector2(a0,a1);
  } else if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btSpatialForceVector6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btSpatialMotionVector__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSpatialMotionVector2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSpatialMotionVector__rt{tis}
btSpatialMotionVector_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0}}}) {
    return btSpatialMotionVector2(a0,a1);
  }
}
private metafunction btSphereBoxCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSphereBoxCollisionAlgorithm5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSphereBoxCollisionAlgorithm__rt{tis}
btSphereBoxCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSphereBoxCollisionAlgorithm5(a0,a1,a2,a3,a4);
  }
}
private metafunction btSphereShape__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSphereShape1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSphereShape__rt{tis}
btSphereShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0}}}) {
    return btSphereShape1(a0);
  }
}
private metafunction btSphereSphereCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSphereSphereCollisionAlgorithm1"}},
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSphereSphereCollisionAlgorithm4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSphereSphereCollisionAlgorithm__rt{tis}
btSphereSphereCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btSphereSphereCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0}}}) {
    return btSphereSphereCollisionAlgorithm4(a0,a1,a2,a3);
  }
}
private metafunction btSphereTriangleCollisionAlgorithm__rt{tis}
  m::cond{
    match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSphereTriangleCollisionAlgorithm1"}},
    match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSphereTriangleCollisionAlgorithm5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSphereTriangleCollisionAlgorithm__rt{tis}
btSphereTriangleCollisionAlgorithm_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btCollisionAlgorithmConstructionInfo,0}}}) {
    return btSphereTriangleCollisionAlgorithm1(a0);
  } else if (match_args{tis, {{rptr{btPersistentManifold},0},{btCollisionAlgorithmConstructionInfo,0},{crptr{btCollisionObjectWrapper},0},{crptr{btCollisionObjectWrapper},0},{bool,0}}}) {
    return btSphereTriangleCollisionAlgorithm5(a0,a1,a2,a3,a4);
  }
}
private metafunction btStackAlloc__rt{tis}
  m::cond{
    match_args{tis, {{uint,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btStackAlloc1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btStackAlloc__rt{tis}
btStackAlloc_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{uint,0}}}) {
    return btStackAlloc1(a0);
  }
}
private metafunction btStaticPlaneShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btStaticPlaneShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btStaticPlaneShape__rt{tis}
btStaticPlaneShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0}}}) {
    return btStaticPlaneShape2(a0,a1);
  }
}
private metafunction btSubsimplexConvexCast__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSubsimplexConvexCast3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSubsimplexConvexCast__rt{tis}
btSubsimplexConvexCast_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{crptr{btConvexShape},0},{rptr{btVoronoiSimplexSolver},0}}}) {
    return btSubsimplexConvexCast3(a0,a1,a2);
  }
}
private metafunction btSwapEndian__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSwapEndian_int"}},
    match_args{tis, {{short,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSwapEndian_short_int"}},
    match_args{tis, {{ushort,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSwapEndian_short_unsigned_int"}},
    match_args{tis, {{uint,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSwapEndian_unsigned_int"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSwapEndian__rt{tis}
btSwapEndian(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btSwapEndian_int(a0);
  } else if (match_args{tis, {{short,0}}}) {
    return btSwapEndian_short_int(a0);
  } else if (match_args{tis, {{ushort,0}}}) {
    return btSwapEndian_short_unsigned_int(a0);
  } else if (match_args{tis, {{uint,0}}}) {
    return btSwapEndian_unsigned_int(a0);
  }
}
private metafunction btSymmetricSpatialDyad__rt{tis}
  m::cond{
    match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btMatrix3x3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btSymmetricSpatialDyad3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btSymmetricSpatialDyad__rt{tis}
btSymmetricSpatialDyad_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btMatrix3x3,0},{btMatrix3x3,0},{btMatrix3x3,0}}}) {
    return btSymmetricSpatialDyad3(a0,a1,a2);
  }
}
private metafunction btTransform__rt{tis}
  m::cond{
    match_args{tis, {{btMatrix3x3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTransform_btMatrix3x3_btVector3"}},
    match_args{tis, {{btQuaternion,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTransform_btQuaternion_btVector3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTransform__rt{tis}
btTransform_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btMatrix3x3,0},{btVector3,0}}}) {
    return btTransform_btMatrix3x3_btVector3(a0,a1);
  } else if (match_args{tis, {{btQuaternion,0},{btVector3,0}}}) {
    return btTransform_btQuaternion_btVector3(a0,a1);
  }
}
private metafunction btTransformAabb__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTransformAabb5"}},
    match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTransformAabb6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTransformAabb__rt{tis}
btTransformAabb(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}}) {
    return btTransformAabb5(a0,a1,a2,a3,a4);
  } else if (match_args{tis, {{btVector3,0},{btVector3,0},{btScalar,0},{btTransform,0},{btVector3,1},{btVector3,1}}}) {
    return btTransformAabb6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btTriangleConvexcastCallback__rt{tis}
  m::cond{
    match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{btTransform,0},{btTransform,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTriangleConvexcastCallback5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleConvexcastCallback__rt{tis}
btTriangleConvexcastCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{crptr{btConvexShape},0},{btTransform,0},{btTransform,0},{btTransform,0},{btScalar,0}}}) {
    return btTriangleConvexcastCallback5(a0,a1,a2,a3,a4);
  }
}
private metafunction btTriangleIndexVertexArray__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTriangleIndexVertexArray6"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleIndexVertexArray__rt{tis}
btTriangleIndexVertexArray_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0}}}) {
    return btTriangleIndexVertexArray6(a0,a1,a2,a3,a4,a5);
  }
}
private metafunction btTriangleIndexVertexMaterialArray__rt{tis}
  m::cond{
    match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0},{int,0},{rptr{uchar},0},{int,0},{rptr{int},0},{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTriangleIndexVertexMaterialArray11"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleIndexVertexMaterialArray__rt{tis}
btTriangleIndexVertexMaterialArray_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0},{rptr{int},0},{int,0},{int,0},{rptr{btScalar},0},{int,0},{int,0},{rptr{uchar},0},{int,0},{rptr{int},0},{int,0}}}) {
    return btTriangleIndexVertexMaterialArray11(a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10);
  }
}
private metafunction btTriangleMesh__rt{tis}
  m::cond{
    match_args{tis, {{bool,0},{bool,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTriangleMesh2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleMesh__rt{tis}
btTriangleMesh_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{bool,0},{bool,0}}}) {
    return btTriangleMesh2(a0,a1);
  }
}
private metafunction btTriangleRaycastCallback__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{uint,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTriangleRaycastCallback3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleRaycastCallback__rt{tis}
btTriangleRaycastCallback_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{uint,0}}}) {
    return btTriangleRaycastCallback3(a0,a1,a2);
  }
}
private metafunction btTriangleShape__rt{tis}
  m::cond{
    match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTriangleShape3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTriangleShape__rt{tis}
btTriangleShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btTriangleShape3(a0,a1,a2);
  }
}
private metafunction btTypedConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTypedConstraint2"}},
    match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1},{btRigidBody,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTypedConstraint3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTypedConstraint__rt{tis}
btTypedConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1}}}) {
    return btTypedConstraint2(a0,a1);
  } else if (match_args{tis, {{btTypedConstraintType,0},{btRigidBody,1},{btRigidBody,1}}}) {
    return btTypedConstraint3(a0,a1,a2);
  }
}
private metafunction btTypedObject__rt{tis}
  m::cond{
    match_args{tis, {{int,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btTypedObject1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btTypedObject__rt{tis}
btTypedObject_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{int,0}}}) {
    return btTypedObject1(a0);
  }
}
private metafunction btUniformScalingShape__rt{tis}
  m::cond{
    match_args{tis, {{rptr{btConvexShape},0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btUniformScalingShape2"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniformScalingShape__rt{tis}
btUniformScalingShape_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{rptr{btConvexShape},0},{btScalar,0}}}) {
    return btUniformScalingShape2(a0,a1);
  }
}
private metafunction btUniversalConstraint__rt{tis}
  m::cond{
    match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btUniversalConstraint5"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btUniversalConstraint__rt{tis}
btUniversalConstraint_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btRigidBody,1},{btRigidBody,1},{btVector3,0},{btVector3,0},{btVector3,0}}}) {
    return btUniversalConstraint5(a0,a1,a2,a3,a4);
  }
}
private metafunction btVector3__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btVector3_3"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btVector3__rt{tis}
btVector3_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btVector3_3(a0,a1,a2);
  }
}
private metafunction btVector4__rt{tis}
  m::cond{
    match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btVector4_4"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btVector4__rt{tis}
btVector4_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btScalar,0},{btScalar,0},{btScalar,0},{btScalar,0}}}) {
    return btVector4_4(a0,a1,a2,a3);
  }
}
private metafunction btWheelInfo__rt{tis}
  m::cond{
    match_args{tis, {{btWheelInfoConstructionInfo,1}}},
    m::ret_type{m::symbol{"bullet_physics::api", "btWheelInfo1"}},
    m::error{m::concat{"invalid argument: ", tis}}};
public pure function {tis}
btWheelInfo__rt{tis}
btWheelInfo_(expand(va::arg_decls_byref{tis}))
{
  if (match_args{tis, {{btWheelInfoConstructionInfo,1}}}) {
    return btWheelInfo1(a0);
  }
}
