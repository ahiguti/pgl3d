
primary 32bit rgba
  value = texelFetch(sampler_voxtmap)
  node_type = int(value.a)
  node_type == 1 (タイル参照)ならtpatを引く
    tpat_sgn := value.rgbの上から2番目のbit。0なら正。
    tpat_rot := value.rgbの最上位bit
      rayの座標からテクスチャの座標を得るのにはsgnを適用後以下を順に適用
        1. .xが真ならxyいれかえ
        2. .yが真ならyzいれかえ
        3. .zが真ならzxいれかえ
    tpscale_log2 := value.rgbの上から3番目のbit。z*4+y*2+x*1。
      2^tpscale_log2倍にパターンを拡大。
    curpos_tp := value.rgbの下5bit
    tpat_coord := tpat_sgn_rotate_tile(...)で計算
    value = texelFetch(sampler_voxtpat, tpat_coord)
    node_type = int(value.a)
  node_type == 0 空白
    distval = value.xyzの何か。空白距離をエンコードしている。
  node_type == 255 壁
    value.rgbは未使用
  node_type >= 160 && node_type <= 254 平面切断
    param_d = node_type - 208 (-48, +46)
    param_abc = distvalの上位4bit - 8
    distvalの下位4bitは未使用
  node_type >= 2 && node_type <= 159 球面切断
    sp_scale = distvalの上位2bit
    sp_center = distvalの下位6bit
    node_type < 64 + 2のとき
      sp_radius = node_type - 1 (1以上64以下)
    node_type >= 64 + 2 のとき裏返し
      sp_radius = node_type - 65 (1以上64以下)
    node_type >= 128 + 2のとき未使用


secondary 32bit rgba
  aval := tex_val.a
    aval_me := avalの上位2bit
      aval_me == 0: 非金属
        mate_diffuse = tex_val.rgb
      aval_me == 1: emissionあり
        mate_emit = tex_val.rgb
      aval_me == 2: 金属
        mate_specular = tex_val.rgb
      aval_me == 3: 金属、emissionあり (これをvoxsurf参照に変更予定)
      既定値
        mate_specular = vec3(0.04)
        mate_diffuse = vec3(0.0)
        mate_emit = vec3(0.0)


(予定)voxsurf参照
  secondaryのaval_me == 3のときにvoxsurfを引く
  value.rgがタイル番号 256x256


raycast_tilemap()
  raycastのジオメトリはsampler_voxtmap, sampler_voxtpatを読む。
  衝突したときにsampler_voxtmax, sampler_voxtpaxを読む。
    value_r = texelFetch(sampler_voxtmax)
    value_r = texelFetch(sampler_voxtpax)
  voxtmax, voxtpaxのテクスチャデータはそれぞれtmap_secとtpat_sec

